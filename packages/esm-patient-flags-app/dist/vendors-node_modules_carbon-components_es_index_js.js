(self["webpackChunk_kenyaemr_esm_patient_flags_app"] = self["webpackChunk_kenyaemr_esm_patient_flags_app"] || []).push([["vendors-node_modules_carbon-components_es_index_js"],{

/***/ "../../node_modules/carbon-components/es/components/accordion/accordion.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/accordion/accordion.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */










var Accordion = /*#__PURE__*/function (_mixin) {
  _inherits(Accordion, _mixin);

  var _super = _createSuper(Accordion);
  /**
   * Accordion.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as an accordion.
   */


  function Accordion(element, options) {
    var _this;

    _classCallCheck(this, Accordion);

    _this = _super.call(this, element, options);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (event) {
      var item = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, _this.options.selectorAccordionItem);

      if (item && !(0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, _this.options.selectorAccordionContent)) {
        _this._toggle(item);
      }
    }));
    /**
     *
     *  DEPRECATE in v8
     *
     *  Swapping to a button elemenet instead of a div
     *  automatically maps click events to keypress as well
     *  This event listener now is only added if user is using
     *  the older markup
     */


    if (!_this._checkIfButton()) {
      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'keypress', function (event) {
        var item = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, _this.options.selectorAccordionItem);

        if (item && !(0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, _this.options.selectorAccordionContent)) {
          _this._handleKeypress(event);
        }
      }));
    }

    return _this;
  }

  _createClass(Accordion, [{
    key: "_checkIfButton",
    value: function _checkIfButton() {
      return this.element.firstElementChild.firstElementChild.nodeName === 'BUTTON';
    }
    /**
     * Handles toggling of active state of accordion via keyboard
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: "_handleKeypress",
    value: function _handleKeypress(event) {
      if (event.which === 13 || event.which === 32) {
        this._toggle(event.target);
      }
    }
  }, {
    key: "_toggle",
    value: function _toggle(element) {
      var heading = element.querySelector(this.options.selectorAccordionItemHeading);
      var expanded = heading.getAttribute('aria-expanded');

      if (expanded !== null) {
        heading.setAttribute('aria-expanded', expanded === 'true' ? 'false' : 'true');
      }

      element.classList.toggle(this.options.classActive);
    }
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode NumberInput.create .create()}, or {@linkcode NumberInput.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode NumberInput.init .init()} works.
     * @property {string} selectorInit The CSS selector to find accordion UIs.
     */

  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-accordion]',
        selectorAccordionItem: ".".concat(prefix, "--accordion__item"),
        selectorAccordionItemHeading: ".".concat(prefix, "--accordion__heading"),
        selectorAccordionContent: ".".concat(prefix, "--accordion__content"),
        classActive: "".concat(prefix, "--accordion__item--active")
      };
    }
    /**
     * The map associating DOM element and accordion UI instance.
     * @type {WeakMap}
     */

  }]);

  Accordion.components = new WeakMap();
  return Accordion;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Accordion);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/checkbox/checkbox.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/checkbox/checkbox.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */








var stateChangeTypes = {
  true: 'true',
  false: 'false',
  mixed: 'mixed'
};

var Checkbox = /*#__PURE__*/function (_mixin) {
  _inherits(Checkbox, _mixin);

  var _super = _createSuper(Checkbox);
  /**
   * Checkbox UI.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a checkbox UI.
   */


  function Checkbox(element, options) {
    var _this;

    _classCallCheck(this, Checkbox);

    _this = _super.call(this, element, options);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (event) {
      _this._handleClick(event);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'focus', function (event) {
      _this._handleFocus(event);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'blur', function (event) {
      _this._handleBlur(event);
    }));

    _this._indeterminateCheckbox();

    _this._initCheckbox();

    return _this;
  }

  _createClass(Checkbox, [{
    key: "_handleClick",
    value: function _handleClick() {
      if (this.element.checked === true) {
        this.element.setAttribute('checked', '');
        this.element.setAttribute('aria-checked', 'true');
        this.element.checked = true; // nested checkboxes inside labels

        if (this.element.parentElement.classList.contains(this.options.classLabel)) {
          this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'true');
        }
      } else if (this.element.checked === false) {
        this.element.removeAttribute('checked');
        this.element.setAttribute('aria-checked', 'false');
        this.element.checked = false; // nested checkboxes inside labels

        if (this.element.parentElement.classList.contains(this.options.classLabel)) {
          this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'false');
        }
      }
    }
  }, {
    key: "_handleFocus",
    value: function _handleFocus() {
      if (this.element.parentElement.classList.contains(this.options.classLabel)) {
        this.element.parentElement.classList.add(this.options.classLabelFocused);
      }
    }
  }, {
    key: "_handleBlur",
    value: function _handleBlur() {
      if (this.element.parentElement.classList.contains(this.options.classLabel)) {
        this.element.parentElement.classList.remove(this.options.classLabelFocused);
      }
    }
    /**
     * Sets the new checkbox state.
     * @param {boolean|string} [state]
     *   The new checkbox state to set. `mixed` to put checkbox in indeterminate state.
     *   If omitted, this method simply makes the style reflect `aria-checked` attribute.
     */

  }, {
    key: "setState",
    value: function setState(state) {
      if (state === undefined || stateChangeTypes[state] === undefined) {
        throw new TypeError('setState expects a value of true, false or mixed.');
      }

      this.element.setAttribute('aria-checked', state);
      this.element.indeterminate = state === stateChangeTypes.mixed;
      this.element.checked = state === stateChangeTypes.true;
      var container = this.element.closest(this.options.selectorContainedCheckboxState);

      if (container) {
        container.setAttribute(this.options.attribContainedCheckboxState, state);
      }
    }
  }, {
    key: "setDisabled",
    value: function setDisabled(value) {
      if (value === undefined) {
        throw new TypeError('setDisabled expects a boolean value of true or false');
      }

      if (value === true) {
        this.element.setAttribute('disabled', true);
      } else if (value === false) {
        this.element.removeAttribute('disabled');
      }

      var container = this.element.closest(this.options.selectorContainedCheckboxDisabled);

      if (container) {
        container.setAttribute(this.options.attribContainedCheckboxDisabled, value);
      }
    }
  }, {
    key: "_indeterminateCheckbox",
    value: function _indeterminateCheckbox() {
      if (this.element.getAttribute('aria-checked') === 'mixed') {
        this.element.indeterminate = true;
      }

      if (this.element.indeterminate === true) {
        this.element.setAttribute('aria-checked', 'mixed');
      }

      if (this.element.parentElement.classList.contains(this.options.classLabel) && this.element.indeterminate === true) {
        this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'mixed');
      }
    }
  }, {
    key: "_initCheckbox",
    value: function _initCheckbox() {
      if (this.element.checked === true) {
        this.element.setAttribute('aria-checked', 'true');
      }

      if (this.element.parentElement.classList.contains(this.options.classLabel) && this.element.checked) {
        this.element.parentElement.setAttribute(this.options.attribContainedCheckboxState, 'true');
      }

      if (this.element.parentElement.classList.contains(this.options.classLabel)) {
        this.element.parentElement.setAttribute(this.options.attribContainedCheckboxDisabled, 'false');
      }

      if (this.element.parentElement.classList.contains(this.options.classLabel) && this.element.disabled) {
        this.element.parentElement.setAttribute(this.options.attribContainedCheckboxDisabled, 'true');
      }
    }
    /**
     * The map associating DOM element and copy button UI instance.
     * @member Checkbox.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Checkbox.create .create()}, or {@linkcode Checkbox.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Checkbox.init .init()} works.
     * @member Checkbox.options
     * @type {object}
     * @property {string} selectorInit The data attribute to find copy button UIs.
     * @property {string} selectorContainedCheckboxState The CSS selector to find a container of checkbox preserving checked state.
     * @property {string} selectorContainedCheckboxDisabled
     *   The CSS selector to find a container of checkbox preserving disabled state.
     * @property {string} classLabel The CSS class for the label.
     * @property {string} classLabelFocused The CSS class for the focused label.
     * @property {string} attribContainedCheckboxState The attribute name for the checked state of contained checkbox.
     * @property {string} attribContainedCheckboxDisabled The attribute name for the disabled state of contained checkbox.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: ".".concat(prefix, "--checkbox"),
        selectorContainedCheckboxState: '[data-contained-checkbox-state]',
        selectorContainedCheckboxDisabled: '[data-contained-checkbox-disabled]',
        classLabel: "".concat(prefix, "--checkbox-label"),
        classLabelFocused: "".concat(prefix, "--checkbox-label__focus"),
        attribContainedCheckboxState: 'data-contained-checkbox-state',
        attribContainedCheckboxDisabled: 'data-contained-checkbox-disabled'
      };
    }
  }]);

  Checkbox.components = new WeakMap();
  Checkbox.stateChangeTypes = stateChangeTypes;
  return Checkbox;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Checkbox);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/code-snippet/code-snippet.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/code-snippet/code-snippet.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */








var CodeSnippet = /*#__PURE__*/function (_mixin) {
  _inherits(CodeSnippet, _mixin);

  var _super = _createSuper(CodeSnippet);
  /**
   * CodeSnippet UI.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a CodeSnippet UI.
   */


  function CodeSnippet(element, options) {
    var _this;

    _classCallCheck(this, CodeSnippet);

    _this = _super.call(this, element, options);

    _this._initCodeSnippet();

    _this.element.querySelector(_this.options.classExpandBtn).addEventListener('click', function (evt) {
      return _this._handleClick(evt);
    });

    return _this;
  }

  _createClass(CodeSnippet, [{
    key: "_handleClick",
    value: function _handleClick() {
      var expandBtn = this.element.querySelector(this.options.classExpandText);
      this.element.classList.toggle(this.options.classExpanded);

      if (this.element.classList.contains(this.options.classExpanded)) {
        expandBtn.textContent = expandBtn.getAttribute(this.options.attribShowLessText);
      } else {
        expandBtn.textContent = expandBtn.getAttribute(this.options.attribShowMoreText);
      }
    }
  }, {
    key: "_initCodeSnippet",
    value: function _initCodeSnippet() {
      var expandBtn = this.element.querySelector(this.options.classExpandText);

      if (!expandBtn) {
        throw new TypeError('Cannot find the expand button.');
      }

      expandBtn.textContent = expandBtn.getAttribute(this.options.attribShowMoreText);

      if (this.element.offsetHeight < this.options.minHeight) {
        this.element.classList.add(this.options.classHideExpand);
      }
    }
    /**
     * The map associating DOM element and code snippet UI instance.
     * @member CodeSnippet.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode CodeSnippet.create .create()},
     * or {@linkcode CodeSnippet.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode CodeSnippet.init .init()} works.
     * @member CodeSnippet.options
     * @type {object}
     * @property {string} selectorInit The data attribute to find code snippet UIs.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_0__["default"].prefix;
      return {
        selectorInit: '[data-code-snippet]',
        attribShowMoreText: 'data-show-more-text',
        attribShowLessText: 'data-show-less-text',
        minHeight: 288,
        classExpanded: "".concat(prefix, "--snippet--expand"),
        classExpandBtn: ".".concat(prefix, "--snippet-btn--expand"),
        classExpandText: ".".concat(prefix, "--snippet-btn--text"),
        classHideExpand: "".concat(prefix, "--snippet-btn--expand--hide")
      };
    }
  }]);

  CodeSnippet.components = new WeakMap();
  return CodeSnippet;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_1__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_2__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_4__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CodeSnippet);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/content-switcher/content-switcher.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/content-switcher/content-switcher.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/evented-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */











var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var ContentSwitcher = /*#__PURE__*/function (_mixin) {
  _inherits(ContentSwitcher, _mixin);

  var _super = _createSuper(ContentSwitcher);
  /**
   * Set of content switcher buttons.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends EventedState
   * @extends Handles
   * @param {HTMLElement} element The element working as a set of content switcher buttons.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorButton] The CSS selector to find switcher buttons.
   * @param {string} [options.selectorButtonSelected] The CSS selector to find the selected switcher button.
   * @param {string} [options.classActive] The CSS class for switcher button's selected state.
   * @param {string} [options.eventBeforeSelected]
   *   The name of the custom event fired before a switcher button is selected.
   *   Cancellation of this event stops selection of content switcher button.
   * @param {string} [options.eventAfterSelected] The name of the custom event fired after a switcher button is selected.
   */


  function ContentSwitcher(element, options) {
    var _this;

    _classCallCheck(this, ContentSwitcher);

    _this = _super.call(this, element, options);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (event) {
      _this._handleClick(event);
    }));

    return _this;
  }
  /**
   * Handles click on content switcher button set.
   * If the click is on a content switcher button, activates it.
   * @param {Event} event The event triggering this method.
   */


  _createClass(ContentSwitcher, [{
    key: "_handleClick",
    value: function _handleClick(event) {
      var button = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, this.options.selectorButton);

      if (button) {
        this.changeState({
          group: 'selected',
          item: button,
          launchingEvent: event
        });
      }
    }
    /**
     * Internal method of {@linkcode ContentSwitcher#setActive .setActive()}, to select a content switcher button.
     * @private
     * @param {object} detail The detail of the event trigging this action.
     * @param {HTMLElement} detail.item The button to be selected.
     * @param {Function} callback Callback called when change in state completes.
     */

  }, {
    key: "_changeState",
    value: function _changeState(_ref, callback) {
      var _this2 = this;

      var item = _ref.item; // `options.selectorLink` is not defined in this class itself, code here primary is for inherited classes

      var itemLink = item.querySelector(this.options.selectorLink);

      if (itemLink) {
        toArray(this.element.querySelectorAll(this.options.selectorLink)).forEach(function (link) {
          if (link !== itemLink) {
            link.setAttribute('aria-selected', 'false');
          }
        });
        itemLink.setAttribute('aria-selected', 'true');
      }

      var selectorButtons = toArray(this.element.querySelectorAll(this.options.selectorButton));
      selectorButtons.forEach(function (button) {
        if (button !== item) {
          button.setAttribute('aria-selected', false);
          button.classList.toggle(_this2.options.classActive, false);
          toArray(button.ownerDocument.querySelectorAll(button.dataset.target)).forEach(function (element) {
            element.setAttribute('hidden', '');
            element.setAttribute('aria-hidden', 'true');
          });
        }
      });
      item.classList.toggle(this.options.classActive, true);
      item.setAttribute('aria-selected', true);
      toArray(item.ownerDocument.querySelectorAll(item.dataset.target)).forEach(function (element) {
        element.removeAttribute('hidden');
        element.setAttribute('aria-hidden', 'false');
      });

      if (callback) {
        callback();
      }
    }
    /**
     * Selects a content switcher button.
     * If the selected button has `data-target` attribute, DOM elements it points to as a CSS selector will be shown.
     * DOM elements associated with unselected buttons in the same way will be hidden.
     * @param {HTMLElement} item The button to be selected.
     * @param {ChangeState~callback} callback The callback is called once selection is finished
     * or is canceled. Will only invoke callback if it's passed in.
     */

  }, {
    key: "setActive",
    value: function setActive(item, callback) {
      this.changeState({
        group: 'selected',
        item: item
      }, function (error) {
        if (error) {
          if (callback) {
            callback(Object.assign(error, {
              item: item
            }));
          }
        } else if (callback) {
          callback(null, item);
        }
      });
    }
    /**
     * The map associating DOM element and content switcher set instance.
     * @member ContentSwitcher.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode ContentSwitcher.create .create()}, or {@linkcode ContentSwitcher.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode ContentSwitcher.init .init()} works.
     * @member ContentSwitcher.options
     * @type {object}
     * @property {string} selectorInit The CSS selector to find content switcher button set.
     * @property {string} [selectorButton] The CSS selector to find switcher buttons.
     * @property {string} [selectorButtonSelected] The CSS selector to find the selected switcher button.
     * @property {string} [classActive] The CSS class for switcher button's selected state.
     * @property {string} [eventBeforeSelected]
     *   The name of the custom event fired before a switcher button is selected.
     *   Cancellation of this event stops selection of content switcher button.
     * @property {string} [eventAfterSelected] The name of the custom event fired after a switcher button is selected.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-content-switcher]',
        selectorButton: "input[type=\"radio\"], .".concat(prefix, "--content-switcher-btn"),
        classActive: "".concat(prefix, "--content-switcher--selected"),
        eventBeforeSelected: 'content-switcher-beingselected',
        eventAfterSelected: 'content-switcher-selected'
      };
    }
  }]);

  ContentSwitcher.components = new WeakMap();
  return ContentSwitcher;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ContentSwitcher);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/copy-button/copy-button.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/copy-button/copy-button.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var CopyButton = /*#__PURE__*/function (_mixin) {
  _inherits(CopyButton, _mixin);

  var _super = _createSuper(CopyButton);
  /**
   * CopyBtn UI.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a copy button UI.
   */


  function CopyButton(element, options) {
    var _this;

    _classCallCheck(this, CopyButton);

    _this = _super.call(this, element, options);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function () {
      return _this.handleClick();
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'animationend', function (event) {
      return _this.handleAnimationEnd(event);
    }));

    return _this;
  }
  /**
   * Cleanup animation classes
   */


  _createClass(CopyButton, [{
    key: "handleAnimationEnd",
    value: function handleAnimationEnd(event) {
      if (event.animationName === 'hide-feedback') {
        this.element.classList.remove(this.options.classAnimating);
        this.element.classList.remove(this.options.classFadeOut);
      }
    }
    /**
     * Show the feedback tooltip on click. Hide the feedback tooltip after specified timeout value.
     */

  }, {
    key: "handleClick",
    value: function handleClick() {
      var _this2 = this;

      var feedback = this.element.querySelector(this.options.feedbackTooltip);

      if (feedback) {
        feedback.classList.add(this.options.classShowFeedback);
        setTimeout(function () {
          feedback.classList.remove(_this2.options.classShowFeedback);
        }, this.options.timeoutValue);
      } else {
        this.element.classList.add(this.options.classAnimating);
        this.element.classList.add(this.options.classFadeIn);
        setTimeout(function () {
          _this2.element.classList.remove(_this2.options.classFadeIn);

          _this2.element.classList.add(_this2.options.classFadeOut);
        }, this.options.timeoutValue);
      }
    }
    /**
     * The map associating DOM element and copy button UI instance.
     * @member CopyBtn.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode CopyBtn.create .create()}, or {@linkcode CopyBtn.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode CopyBtn.init .init()} works.
     * @member CopyBtn.options
     * @type {object}
     * @property {string} selectorInit The data attribute to find copy button UIs.
     * @property {string} feedbackTooltip The data attribute to find feedback tooltip.
     * @property {string} classShowFeedback The CSS selector for showing the feedback tooltip.
     * @property {number} timeoutValue The specified timeout value before the feedback tooltip is hidden.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-copy-btn]',
        feedbackTooltip: '[data-feedback]',
        classShowFeedback: "".concat(prefix, "--btn--copy__feedback--displayed"),
        classAnimating: "".concat(prefix, "--copy-btn--animating"),
        classFadeIn: "".concat(prefix, "--copy-btn--fade-in"),
        classFadeOut: "".concat(prefix, "--copy-btn--fade-out"),
        timeoutValue: 2000
      };
    }
  }]);

  CopyButton.components = new WeakMap();
  return CopyButton;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CopyButton);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/data-table-v2/data-table-v2.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/data-table-v2/data-table-v2.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _data_table_data_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data-table/data-table */ "../../node_modules/carbon-components/es/components/data-table/data-table.js");
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_data_table_data_table__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/data-table/data-table.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/data-table/data-table.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/evented-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */











var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var DataTable = /*#__PURE__*/function (_mixin) {
  _inherits(DataTable, _mixin);

  var _super = _createSuper(DataTable);
  /**
   * Data Table
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends   EventedState
   * @param {HTMLElement} element The root element of tables
   * @param {object} [options] the... options
   * @param {string} [options.selectorInit] selector initialization
   * @param {string} [options.selectorExpandCells] css selector for expand
   * @param {string} [options.expandableRow] css selector for expand
   * @param {string} [options.selectorParentRows] css selector for rows housing expansion
   * @param {string} [options.selectorTableBody] root css for table body
   * @param {string} [options.eventTrigger] selector for event bubble capture points
   * @param {string} [options.eventParentContainer] used find the bubble container
   */


  function DataTable(_element, options) {
    var _this;

    _classCallCheck(this, DataTable);

    _this = _super.call(this, _element, options);

    _this._sortToggle = function (detail) {
      var element = detail.element,
          previousValue = detail.previousValue;
      toArray(_this.tableHeaders).forEach(function (header) {
        var sortEl = header.querySelector(_this.options.selectorTableSort);

        if (sortEl !== null && sortEl !== element) {
          sortEl.classList.remove(_this.options.classTableSortActive);
          sortEl.classList.remove(_this.options.classTableSortAscending);
        }
      });

      if (!previousValue) {
        element.dataset.previousValue = 'ascending';
        element.classList.add(_this.options.classTableSortActive);
        element.classList.add(_this.options.classTableSortAscending);
      } else if (previousValue === 'ascending') {
        element.dataset.previousValue = 'descending';
        element.classList.add(_this.options.classTableSortActive);
        element.classList.remove(_this.options.classTableSortAscending);
      } else if (previousValue === 'descending') {
        element.removeAttribute('data-previous-value');
        element.classList.remove(_this.options.classTableSortActive);
        element.classList.remove(_this.options.classTableSortAscending);
      }
    };

    _this._selectToggle = function (detail) {
      var element = detail.element;
      var checked = element.checked; // increment the  count

      _this.state.checkboxCount += checked ? 1 : -1;
      _this.countEl.textContent = _this.state.checkboxCount;
      var row = element.parentNode.parentNode;
      row.classList.toggle(_this.options.classTableSelected); // toggle on/off batch action bar

      _this._actionBarToggle(_this.state.checkboxCount > 0);
    };

    _this._selectAllToggle = function (_ref) {
      var element = _ref.element;
      var checked = element.checked;
      var inputs = toArray(_this.element.querySelectorAll(_this.options.selectorCheckbox));
      _this.state.checkboxCount = checked ? inputs.length - 1 : 0;
      inputs.forEach(function (item) {
        item.checked = checked;
        var row = item.parentNode.parentNode;

        if (checked && row) {
          row.classList.add(_this.options.classTableSelected);
        } else {
          row.classList.remove(_this.options.classTableSelected);
        }
      });

      _this._actionBarToggle(_this.state.checkboxCount > 0);

      if (_this.batchActionEl) {
        _this.countEl.textContent = _this.state.checkboxCount;
      }
    };

    _this._actionBarCancel = function () {
      var inputs = toArray(_this.element.querySelectorAll(_this.options.selectorCheckbox));
      var row = toArray(_this.element.querySelectorAll(_this.options.selectorTableSelected));
      row.forEach(function (item) {
        item.classList.remove(_this.options.classTableSelected);
      });
      inputs.forEach(function (item) {
        item.checked = false;
      });
      _this.state.checkboxCount = 0;

      _this._actionBarToggle(false);

      if (_this.batchActionEl) {
        _this.countEl.textContent = _this.state.checkboxCount;
      }
    };

    _this._actionBarToggle = function (toggleOn) {
      var handleTransitionEnd;

      var transition = function transition(evt) {
        if (handleTransitionEnd) {
          handleTransitionEnd = _this.unmanage(handleTransitionEnd).release();
        }

        if (evt.target.matches(_this.options.selectorActions)) {
          if (_this.batchActionEl.dataset.active === 'false') {
            _this.batchActionEl.setAttribute('tabIndex', -1);
          } else {
            _this.batchActionEl.setAttribute('tabIndex', 0);
          }
        }
      };

      if (toggleOn) {
        _this.batchActionEl.dataset.active = true;

        _this.batchActionEl.classList.add(_this.options.classActionBarActive);
      } else if (_this.batchActionEl) {
        _this.batchActionEl.dataset.active = false;

        _this.batchActionEl.classList.remove(_this.options.classActionBarActive);
      }

      if (_this.batchActionEl) {
        handleTransitionEnd = _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.batchActionEl, 'transitionend', transition));
      }
    };

    _this._rowExpandToggle = function (_ref2) {
      var element = _ref2.element,
          forceExpand = _ref2.forceExpand;
      var parent = element.closest(_this.options.eventParentContainer); // NOTE: `data-previous-value` keeps UI state before this method makes change in style
      // eslint-disable-next-line eqeqeq

      var shouldExpand = forceExpand != null ? forceExpand : element.dataset.previousValue === undefined || element.dataset.previousValue === 'expanded';

      if (shouldExpand) {
        element.dataset.previousValue = 'collapsed';
        parent.classList.add(_this.options.classExpandableRow);
      } else {
        parent.classList.remove(_this.options.classExpandableRow);
        element.dataset.previousValue = 'expanded';

        var expandHeader = _this.element.querySelector(_this.options.selectorExpandHeader);

        if (expandHeader) {
          expandHeader.dataset.previousValue = 'expanded';
        }
      }
    };

    _this._rowExpandToggleAll = function (_ref3) {
      var element = _ref3.element; // NOTE: `data-previous-value` keeps UI state before this method makes change in style

      var shouldExpand = element.dataset.previousValue === undefined || element.dataset.previousValue === 'expanded';
      element.dataset.previousValue = shouldExpand ? 'collapsed' : 'expanded';

      var expandCells = _this.element.querySelectorAll(_this.options.selectorExpandCells);

      Array.prototype.forEach.call(expandCells, function (cell) {
        _this._rowExpandToggle({
          element: cell,
          forceExpand: shouldExpand
        });
      });
    };

    _this._expandableHoverToggle = function (evt) {
      var element = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorChildRow);

      if (element) {
        element.previousElementSibling.classList.toggle(_this.options.classExpandableRowHover, evt.type === 'mouseover');
      }
    };

    _this._toggleState = function (element, evt) {
      var data = element.dataset;
      var label = data.label ? data.label : '';
      var previousValue = data.previousValue ? data.previousValue : '';
      var initialEvt = evt;

      _this.changeState({
        group: data.event,
        element: element,
        label: label,
        previousValue: previousValue,
        initialEvt: initialEvt
      });
    };

    _this._keydownHandler = function (evt) {
      var searchContainer = _this.element.querySelector(_this.options.selectorToolbarSearchContainer);

      var searchEvent = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorSearchMagnifier);
      var activeSearch = searchContainer.classList.contains(_this.options.classToolbarSearchActive);

      if (evt.which === 27) {
        _this._actionBarCancel();
      }

      if (searchContainer && searchEvent && evt.which === 13) {
        _this.activateSearch(searchContainer);
      }

      if (activeSearch && evt.which === 27) {
        _this.deactivateSearch(searchContainer, evt);
      }
    };

    _this.refreshRows = function () {
      var newExpandCells = toArray(_this.element.querySelectorAll(_this.options.selectorExpandCells));
      var newExpandableRows = toArray(_this.element.querySelectorAll(_this.options.selectorExpandableRows));
      var newParentRows = toArray(_this.element.querySelectorAll(_this.options.selectorParentRows)); // check if this is a refresh or the first time

      if (_this.parentRows.length > 0) {
        var diffParentRows = newParentRows.filter(function (newRow) {
          return !_this.parentRows.some(function (oldRow) {
            return oldRow === newRow;
          });
        }); // check if there are expandable rows

        if (newExpandableRows.length > 0) {
          var diffExpandableRows = diffParentRows.map(function (newRow) {
            return newRow.nextElementSibling;
          });
          var mergedExpandableRows = [].concat(_toConsumableArray(toArray(_this.expandableRows)), _toConsumableArray(toArray(diffExpandableRows)));
          _this.expandableRows = mergedExpandableRows;
        }
      } else if (newExpandableRows.length > 0) {
        _this.expandableRows = newExpandableRows;
      }

      _this.expandCells = newExpandCells;
      _this.parentRows = newParentRows;
    };

    _this.container = _element.parentNode;
    _this.toolbarEl = _this.element.querySelector(_this.options.selectorToolbar);
    _this.batchActionEl = _this.element.querySelector(_this.options.selectorActions);
    _this.countEl = _this.element.querySelector(_this.options.selectorCount);
    _this.cancelEl = _this.element.querySelector(_this.options.selectorActionCancel);
    _this.tableHeaders = _this.element.querySelectorAll('th');
    _this.tableBody = _this.element.querySelector(_this.options.selectorTableBody);
    _this.expandCells = [];
    _this.expandableRows = [];
    _this.parentRows = [];

    _this.refreshRows();

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'mouseover', _this._expandableHoverToggle));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'mouseout', _this._expandableHoverToggle));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (evt) {
      var eventElement = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.eventTrigger);

      var searchContainer = _this.element.querySelector(_this.options.selectorToolbarSearchContainer);

      if (eventElement) {
        _this._toggleState(eventElement, evt);
      }

      if (searchContainer) {
        _this._handleDocumentClick(evt);
      }
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'keydown', _this._keydownHandler));

    _this.state = {
      checkboxCount: 0
    };
    return _this;
  }

  _createClass(DataTable, [{
    key: "_handleDocumentClick",
    value: function _handleDocumentClick(evt) {
      var searchContainer = this.element.querySelector(this.options.selectorToolbarSearchContainer);
      var searchEvent = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, this.options.selectorSearchMagnifier);
      var activeSearch = searchContainer.classList.contains(this.options.classToolbarSearchActive);

      if (searchContainer && searchEvent) {
        this.activateSearch(searchContainer);
      }

      if (activeSearch) {
        this.deactivateSearch(searchContainer, evt);
      }
    }
  }, {
    key: "activateSearch",
    value: function activateSearch(container) {
      var input = container.querySelector(this.options.selectorSearchInput);
      container.classList.add(this.options.classToolbarSearchActive);
      input.focus();
    }
  }, {
    key: "deactivateSearch",
    value: function deactivateSearch(container, evt) {
      var trigger = container.querySelector(this.options.selectorSearchMagnifier);
      var input = container.querySelector(this.options.selectorSearchInput);
      var svg = trigger.querySelector('svg');

      if (input.value.length === 0 && evt.target !== input && evt.target !== trigger && evt.target !== svg) {
        container.classList.remove(this.options.classToolbarSearchActive);
        trigger.focus();
      }

      if (evt.which === 27 && evt.target === input) {
        container.classList.remove(this.options.classToolbarSearchActive);
        trigger.focus();
      }
    }
  }, {
    key: "_changeState",
    value: function _changeState(detail, callback) {
      this[this.constructor.eventHandlers[detail.group]](detail);
      callback();
    }
  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: "[data-table]",
        selectorToolbar: ".".concat(prefix, "--table--toolbar"),
        selectorActions: ".".concat(prefix, "--batch-actions"),
        selectorCount: '[data-items-selected]',
        selectorActionCancel: ".".concat(prefix, "--batch-summary__cancel"),
        selectorCheckbox: ".".concat(prefix, "--checkbox"),
        selectorExpandHeader: "th.".concat(prefix, "--table-expand"),
        selectorExpandCells: "td.".concat(prefix, "--table-expand"),
        selectorExpandableRows: ".".concat(prefix, "--expandable-row"),
        selectorParentRows: ".".concat(prefix, "--parent-row"),
        selectorChildRow: '[data-child-row]',
        selectorTableBody: 'tbody',
        selectorTableSort: ".".concat(prefix, "--table-sort"),
        selectorTableSelected: ".".concat(prefix, "--data-table--selected"),
        selectorToolbarSearchContainer: ".".concat(prefix, "--toolbar-search-container-expandable"),
        selectorSearchMagnifier: ".".concat(prefix, "--search-magnifier"),
        selectorSearchInput: ".".concat(prefix, "--search-input"),
        classExpandableRow: "".concat(prefix, "--expandable-row"),
        classExpandableRowHidden: "".concat(prefix, "--expandable-row--hidden"),
        classExpandableRowHover: "".concat(prefix, "--expandable-row--hover"),
        classTableSortAscending: "".concat(prefix, "--table-sort--ascending"),
        classTableSortActive: "".concat(prefix, "--table-sort--active"),
        classToolbarSearchActive: "".concat(prefix, "--toolbar-search-container-active"),
        classActionBarActive: "".concat(prefix, "--batch-actions--active"),
        classTableSelected: "".concat(prefix, "--data-table--selected"),
        eventBeforeExpand: "data-table-beforetoggleexpand",
        eventAfterExpand: "data-table-aftertoggleexpand",
        eventBeforeExpandAll: "data-table-beforetoggleexpandall",
        eventAfterExpandAll: "data-table-aftertoggleexpandall",
        eventBeforeSort: "data-table-beforetogglesort",
        eventAfterSort: "data-table-aftertogglesort",
        eventTrigger: '[data-event]',
        eventParentContainer: '[data-parent-row]'
      };
    }
  }]);

  DataTable.components = new WeakMap();
  DataTable.eventHandlers = {
    expand: '_rowExpandToggle',
    expandAll: '_rowExpandToggleAll',
    sort: '_sortToggle',
    select: '_selectToggle',
    'select-all': '_selectAllToggle',
    'action-bar-cancel': '_actionBarCancel'
  };
  return DataTable;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTable);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/date-picker/date-picker.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/date-picker/date-picker.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var flatpickr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatpickr */ "../../node_modules/carbon-components/node_modules/flatpickr/dist/flatpickr.js");
/* harmony import */ var flatpickr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flatpickr__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









/* eslint no-underscore-dangle: [2, { "allow": ["_input", "_updateClassNames", "_updateInputFields"], "allowAfterThis": true }] */
// `this.options` create-component mix-in creates prototype chain
// so that `options` given in constructor argument wins over the one defined in static `options` property
// 'Flatpickr' wants flat structure of object instead

function flattenOptions(options) {
  var o = {}; // eslint-disable-next-line guard-for-in, no-restricted-syntax

  for (var key in options) {
    o[key] = options[key];
  }

  return o;
} // Weekdays shorthand for english locale


flatpickr__WEBPACK_IMPORTED_MODULE_0___default().l10ns.en.weekdays.shorthand.forEach(function (day, index) {
  var currentDay = (flatpickr__WEBPACK_IMPORTED_MODULE_0___default().l10ns.en.weekdays.shorthand);

  if (currentDay[index] === 'Thu' || currentDay[index] === 'Th') {
    currentDay[index] = 'Th';
  } else {
    currentDay[index] = currentDay[index].charAt(0);
  }
});

var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};
/**
 * @param {number} monthNumber The month number.
 * @param {boolean} shorthand `true` to use shorthand month.
 * @param {Locale} locale The Flatpickr locale data.
 * @returns {string} The month string.
 */


var monthToStr = function monthToStr(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? 'shorthand' : 'longhand'][monthNumber];
};
/**
 * @param {object} config Plugin configuration.
 * @param {boolean} [config.shorthand] `true` to use shorthand month.
 * @param {string} config.selectorFlatpickrMonthYearContainer The CSS selector for the container of month/year selection UI.
 * @param {string} config.selectorFlatpickrYearContainer The CSS selector for the container of year selection UI.
 * @param {string} config.selectorFlatpickrCurrentMonth The CSS selector for the text-based month selection UI.
 * @param {string} config.classFlatpickrCurrentMonth The CSS class for the text-based month selection UI.
 * @returns {Plugin} A Flatpickr plugin to use text instead of `<select>` for month picker.
 */


var carbonFlatpickrMonthSelectPlugin = function carbonFlatpickrMonthSelectPlugin(config) {
  return function (fp) {
    var setupElements = function setupElements() {
      var _fp$monthElements;

      if (!fp.monthElements) {
        return;
      }

      fp.monthElements.forEach(function (elem) {
        if (!elem.parentNode) return;
        elem.parentNode.removeChild(elem);
      });

      (_fp$monthElements = fp.monthElements).splice.apply(_fp$monthElements, [0, fp.monthElements.length].concat(_toConsumableArray(fp.monthElements.map(function () {
        // eslint-disable-next-line no-underscore-dangle
        var monthElement = fp._createElement('span', config.classFlatpickrCurrentMonth);

        monthElement.textContent = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);
        fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
        return monthElement;
      }))));
    };

    var updateCurrentMonth = function updateCurrentMonth() {
      var monthStr = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);
      fp.yearElements.forEach(function (elem) {
        var currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
        Array.prototype.forEach.call(currentMonthContainer.querySelectorAll('.cur-month'), function (monthElement) {
          monthElement.textContent = monthStr;
        });
      });
    };

    var register = function register() {
      fp.loadedPlugins.push('carbonFlatpickrMonthSelectPlugin');
    };

    return {
      onMonthChange: updateCurrentMonth,
      onValueUpdate: updateCurrentMonth,
      onOpen: updateCurrentMonth,
      onReady: [setupElements, updateCurrentMonth, register]
    };
  };
};

var DatePicker = /*#__PURE__*/function (_mixin) {
  _inherits(DatePicker, _mixin);

  var _super = _createSuper(DatePicker);
  /**
   * DatePicker.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as an date picker.
   */


  function DatePicker(element, options) {
    var _this;

    _classCallCheck(this, DatePicker);

    _this = _super.call(this, element, options);

    _this._handleFocus = function () {
      if (_this.calendar) {
        _this.calendar.open();
      }
    };

    _this._handleBlur = function (event) {
      if (_this.calendar) {
        var focusTo = event.relatedTarget;

        if (!focusTo || !_this.element.contains(focusTo) && (!_this.calendar.calendarContainer || !_this.calendar.calendarContainer.contains(focusTo))) {
          _this.calendar.close();
        }
      }
    };

    _this._initDatePicker = function (type) {
      if (type === 'range') {
        // Given FlatPickr assumes one `<input>` even in range mode,
        // use a hidden `<input>` for such purpose, separate from our from/to `<input>`s
        var doc = _this.element.ownerDocument;
        var rangeInput = doc.createElement('input');
        rangeInput.className = _this.options.classVisuallyHidden;
        rangeInput.setAttribute('aria-hidden', 'true');

        _this.element.appendChild(rangeInput);

        _this._rangeInput = rangeInput; // An attempt to open the date picker dropdown when this component gets focus,
        // and close the date picker dropdown when this component loses focus

        var w = doc.defaultView;
        var hasFocusin = ('onfocusin' in w);
        var hasFocusout = ('onfocusout' in w);
        var focusinEventName = hasFocusin ? 'focusin' : 'focus';
        var focusoutEventName = hasFocusout ? 'focusout' : 'blur';

        _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, focusinEventName, _this._handleFocus, !hasFocusin));

        _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, focusoutEventName, _this._handleBlur, !hasFocusout));

        _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.querySelector(_this.options.selectorDatePickerIcon), focusoutEventName, _this._handleBlur, !hasFocusout));
      }

      var self = _assertThisInitialized(_this);

      var date = type === 'range' ? _this._rangeInput : _this.element.querySelector(_this.options.selectorDatePickerInput);
      var _this$options = _this.options,
          _onClose = _this$options.onClose,
          _onChange = _this$options.onChange,
          _onMonthChange = _this$options.onMonthChange,
          _onYearChange = _this$options.onYearChange,
          _onOpen = _this$options.onOpen,
          _onValueUpdate = _this$options.onValueUpdate;
      var calendar = new (flatpickr__WEBPACK_IMPORTED_MODULE_0___default())(date, Object.assign(flattenOptions(_this.options), {
        allowInput: true,
        mode: type,
        disableMobile: true,
        positionElement: type === 'range' && _this.element.querySelector(_this.options.selectorDatePickerInputFrom),
        onClose: function onClose(selectedDates) {
          // An attempt to disable Flatpickr's focus tracking system,
          // which has adverse effect with our old set up with two `<input>`s or our latest setup with a hidden `<input>`
          if (self.shouldForceOpen) {
            if (self.calendar.calendarContainer) {
              self.calendar.calendarContainer.classList.add('open');
            }

            self.calendar.isOpen = true;
          }

          for (var _len = arguments.length, remainder = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            remainder[_key - 1] = arguments[_key];
          }

          if (!_onClose || _onClose.call.apply(_onClose, [this, selectedDates].concat(remainder)) !== false) {
            self._updateClassNames(calendar);

            self._updateInputFields(selectedDates, type);
          }
        },
        onChange: function onChange() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          if (!_onChange || _onChange.call.apply(_onChange, [this].concat(args)) !== false) {
            self._updateClassNames(calendar);

            if (type === 'range') {
              if (calendar.selectedDates.length === 1 && calendar.isOpen) {
                self.element.querySelector(self.options.selectorDatePickerInputTo).classList.add(self.options.classFocused);
              } else {
                self.element.querySelector(self.options.selectorDatePickerInputTo).classList.remove(self.options.classFocused);
              }
            }
          }
        },
        onMonthChange: function onMonthChange() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          if (!_onMonthChange || _onMonthChange.call.apply(_onMonthChange, [this].concat(args)) !== false) {
            self._updateClassNames(calendar);
          }
        },
        onYearChange: function onYearChange() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          if (!_onYearChange || _onYearChange.call.apply(_onYearChange, [this].concat(args)) !== false) {
            self._updateClassNames(calendar);
          }
        },
        onOpen: function onOpen() {
          // An attempt to disable Flatpickr's focus tracking system,
          // which has adverse effect with our old set up with two `<input>`s or our latest setup with a hidden `<input>`
          self.shouldForceOpen = true;
          setTimeout(function () {
            self.shouldForceOpen = false;
          }, 0);

          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }

          if (!_onOpen || _onOpen.call.apply(_onOpen, [this].concat(args)) !== false) {
            self._updateClassNames(calendar);
          }
        },
        onValueUpdate: function onValueUpdate() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }

          if ((!_onValueUpdate || _onValueUpdate.call.apply(_onValueUpdate, [this].concat(args)) !== false) && type === 'range') {
            self._updateInputFields(self.calendar.selectedDates, type);
          }
        },
        nextArrow: _this._rightArrowHTML(),
        prevArrow: _this._leftArrowHTML(),
        plugins: [].concat(_toConsumableArray(_this.options.plugins || []), [carbonFlatpickrMonthSelectPlugin(_this.options)])
      }));

      if (type === 'range') {
        _this._addInputLogic(_this.element.querySelector(_this.options.selectorDatePickerInputFrom), 0);

        _this._addInputLogic(_this.element.querySelector(_this.options.selectorDatePickerInputTo), 1);
      }

      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.querySelector(_this.options.selectorDatePickerIcon), 'click', function () {
        calendar.open();
      }));

      _this._updateClassNames(calendar);

      if (type !== 'range') {
        _this._addInputLogic(date);
      }

      return calendar;
    };

    _this._addInputLogic = function (input, index) {
      if (!isNaN(index) && (index < 0 || index > 1)) {
        throw new RangeError("The index of <input> (".concat(index, ") is out of range."));
      }

      var inputField = input;

      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(inputField, 'change', function (evt) {
        if (evt.isTrusted || evt.detail && evt.detail.isNotFromFlatpickr) {
          var inputDate = _this.calendar.parseDate(inputField.value);

          if (inputDate && !isNaN(inputDate.valueOf())) {
            if (isNaN(index)) {
              _this.calendar.setDate(inputDate);
            } else {
              var selectedDates = _this.calendar.selectedDates;
              selectedDates[index] = inputDate;

              _this.calendar.setDate(selectedDates);
            }
          }
        }

        _this._updateClassNames(_this.calendar);
      })); // An attempt to temporarily set the `<input>` being edited as the one FlatPicker manages,
      // as FlatPicker attempts to take over `keydown` event handler on `document` to run on the date picker dropdown.


      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(inputField, 'keydown', function (evt) {
        var origInput = _this.calendar._input;
        _this.calendar._input = evt.target;
        setTimeout(function () {
          _this.calendar._input = origInput;
        });
      }));
    };

    _this._updateClassNames = function (_ref) {
      var calendarContainer = _ref.calendarContainer,
          selectedDates = _ref.selectedDates;

      if (calendarContainer) {
        calendarContainer.classList.add(_this.options.classCalendarContainer);
        calendarContainer.querySelector('.flatpickr-month').classList.add(_this.options.classMonth);
        calendarContainer.querySelector('.flatpickr-weekdays').classList.add(_this.options.classWeekdays);
        calendarContainer.querySelector('.flatpickr-days').classList.add(_this.options.classDays);
        toArray(calendarContainer.querySelectorAll('.flatpickr-weekday')).forEach(function (item) {
          var currentItem = item;
          currentItem.innerHTML = currentItem.innerHTML.replace(/\s+/g, '');
          currentItem.classList.add(_this.options.classWeekday);
        });
        toArray(calendarContainer.querySelectorAll('.flatpickr-day')).forEach(function (item) {
          item.classList.add(_this.options.classDay);

          if (item.classList.contains('today') && selectedDates.length > 0) {
            item.classList.add('no-border');
          } else if (item.classList.contains('today') && selectedDates.length === 0) {
            item.classList.remove('no-border');
          }
        });
      }
    };

    _this._updateInputFields = function (selectedDates, type) {
      if (type === 'range') {
        if (selectedDates.length === 2) {
          _this.element.querySelector(_this.options.selectorDatePickerInputFrom).value = _this._formatDate(selectedDates[0]);
          _this.element.querySelector(_this.options.selectorDatePickerInputTo).value = _this._formatDate(selectedDates[1]);
        } else if (selectedDates.length === 1) {
          _this.element.querySelector(_this.options.selectorDatePickerInputFrom).value = _this._formatDate(selectedDates[0]);
        }
      } else if (selectedDates.length === 1) {
        _this.element.querySelector(_this.options.selectorDatePickerInput).value = _this._formatDate(selectedDates[0]);
      }

      _this._updateClassNames(_this.calendar);
    };

    _this._formatDate = function (date) {
      return _this.calendar.formatDate(date, _this.calendar.config.dateFormat);
    };

    var _type = _this.element.getAttribute(_this.options.attribType);

    _this.calendar = _this._initDatePicker(_type);

    if (_this.calendar.calendarContainer) {
      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'keydown', function (e) {
        if (e.which === 40) {
          e.preventDefault();

          (_this.calendar.selectedDateElem || _this.calendar.todayDateElem || _this.calendar.calendarContainer).focus();
        }
      }));

      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.calendar.calendarContainer, 'keydown', function (e) {
        if (e.which === 9 && _type === 'range') {
          _this._updateClassNames(_this.calendar);

          _this.element.querySelector(_this.options.selectorDatePickerInputFrom).focus();
        }
      }));
    }

    return _this;
  }
  /**
   * Opens the date picker dropdown when this component gets focus.
   * Used only for range mode for now.
   * @private
   */


  _createClass(DatePicker, [{
    key: "_rightArrowHTML",
    value: function _rightArrowHTML() {
      return "\n      <svg\n        focusable=\"false\"\n        preserveAspectRatio=\"xMidYMid meet\"\n        style=\"will-change: transform;\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"16\"\n        height=\"16\"\n        viewBox=\"0 0 16 16\"\n        aria-hidden=\"true\">\n          <path d=\"M11 8l-5 5-.7-.7L9.6 8 5.3 3.7 6 3z\"></path>\n      </svg>";
    }
  }, {
    key: "_leftArrowHTML",
    value: function _leftArrowHTML() {
      return "\n      <svg\n        focusable=\"false\"\n        preserveAspectRatio=\"xMidYMid meet\"\n        style=\"will-change: transform;\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"16\"\n        height=\"16\"\n        viewBox=\"0 0 16 16\"\n        aria-hidden=\"true\"\n      >\n        <path d=\"M5 8l5-5 .7.7L6.4 8l4.3 4.3-.7.7z\"></path>\n      </svg>";
    }
  }, {
    key: "release",
    value: function release() {
      if (this._rangeInput && this._rangeInput.parentNode) {
        this._rangeInput.parentNode.removeChild(this._rangeInput);
      }

      if (this.calendar) {
        try {
          this.calendar.destroy();
        } catch (err) {} // eslint-disable-line no-empty


        this.calendar = null;
      }

      return _get(_getPrototypeOf(DatePicker.prototype), "release", this).call(this);
    }
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode DatePicker.create .create()}, or {@linkcode DatePicker.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode DatePicker.init .init()} works.
     * @property {string} selectorInit The CSS selector to find date picker UIs.
     */

  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-date-picker]',
        selectorDatePickerInput: '[data-date-picker-input]',
        selectorDatePickerInputFrom: '[data-date-picker-input-from]',
        selectorDatePickerInputTo: '[data-date-picker-input-to]',
        selectorDatePickerIcon: '[data-date-picker-icon]',
        selectorFlatpickrMonthYearContainer: '.flatpickr-current-month',
        selectorFlatpickrYearContainer: '.numInputWrapper',
        selectorFlatpickrCurrentMonth: '.cur-month',
        classCalendarContainer: "".concat(prefix, "--date-picker__calendar"),
        classMonth: "".concat(prefix, "--date-picker__month"),
        classWeekdays: "".concat(prefix, "--date-picker__weekdays"),
        classDays: "".concat(prefix, "--date-picker__days"),
        classWeekday: "".concat(prefix, "--date-picker__weekday"),
        classDay: "".concat(prefix, "--date-picker__day"),
        classFocused: "".concat(prefix, "--focused"),
        classVisuallyHidden: "".concat(prefix, "--visually-hidden"),
        classFlatpickrCurrentMonth: 'cur-month',
        attribType: 'data-date-picker-type',
        dateFormat: 'm/d/Y'
      };
    }
    /**
     * The map associating DOM element and date picker UI instance.
     * @type {WeakMap}
     */

  }]);

  DatePicker.components = new WeakMap();
  return DatePicker;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DatePicker);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/dropdown/dropdown.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/dropdown/dropdown.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_track_blur__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/track-blur */ "../../node_modules/carbon-components/es/globals/js/mixins/track-blur.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */










var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var Dropdown = /*#__PURE__*/function (_mixin) {
  _inherits(Dropdown, _mixin);

  var _super = _createSuper(Dropdown);
  /**
   * A selector with drop downs.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends TrackBlur
   * @param {HTMLElement} element The element working as a selector.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorItem] The CSS selector to find clickable areas in dropdown items.
   * @param {string} [options.selectorItemSelected] The CSS selector to find the clickable area in the selected dropdown item.
   * @param {string} [options.classSelected] The CSS class for the selected dropdown item.
   * @param {string} [options.classOpen] The CSS class for the open state.
   * @param {string} [options.classDisabled] The CSS class for the disabled state.
   * @param {string} [options.eventBeforeSelected]
   *   The name of the custom event fired before a drop down item is selected.
   *   Cancellation of this event stops selection of drop down item.
   * @param {string} [options.eventAfterSelected] The name of the custom event fired after a drop down item is selected.
   */


  function Dropdown(element, options) {
    var _this;

    _classCallCheck(this, Dropdown);

    _this = _super.call(this, element, options);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, 'click', function (event) {
      _this._toggle(event);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'keydown', function (event) {
      _this._handleKeyDown(event);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (event) {
      var item = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, _this.options.selectorItem);

      if (item) {
        _this.select(item);
      }
    })); // When using the active descendant approach we use a class to give focus styles during keyboard (up/down arrows)
    // navigation instead of relying on the :focus selector. This leaves the potential to have multiple items when
    // switching interactions between keyboard and mouse users. To more closely align with Carbon React implementation,
    // we want the focus class to move as the user hovers over items. This also updates the location of focus based on
    // the last hovered item if the user switches back to using the keyboard.


    if ( // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
    _this.element.querySelector(_this.options.selectorTrigger) && _this.element.querySelector(_this.options.selectorMenu)) {
      // Using the latest HTML structure that supports the aria-activedescendant attribute
      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'mouseover', function (event) {
        var item = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, _this.options.selectorItem);

        if (item) {
          _this._updateFocus(item);
        }
      }));
    }

    return _this;
  }
  /**
   * Handles keydown event.
   * @param {Event} event The event triggering this method.
   */


  _createClass(Dropdown, [{
    key: "_handleKeyDown",
    value: function _handleKeyDown(event) {
      var isOpen = this.element.classList.contains(this.options.classOpen);
      var direction = {
        38: this.constructor.NAVIGATE.BACKWARD,
        40: this.constructor.NAVIGATE.FORWARD
      }[event.which];

      if (isOpen && direction !== undefined) {
        this.navigate(direction);
        event.preventDefault(); // Prevents up/down keys from scrolling container
      } else {
        // get selected item
        // in v10.0, the anchor elements fire click events on Enter keypress when a dropdown item is selected
        // in v10.5 (#3586), focus is no longer placed on the dropdown items and is instead kept fixed on the ul menu
        // so we need to manually call getCurrentNavigation and select the item
        var item = this.getCurrentNavigation();

        if (item && isOpen && (event.which === 13 || event.which === 32) && !this.element.ownerDocument.activeElement.matches(this.options.selectorItem)) {
          event.preventDefault();
          this.select(item);
        }

        this._toggle(event);
      }
    }
    /**
     * When using aria-activedescendant we want to make sure attributes and classes
     * are properly cleaned up when the dropdown is closed
     * @private
     */

  }, {
    key: "_focusCleanup",
    value: function _focusCleanup() {
      // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
      var triggerNode = this.element.querySelector(this.options.selectorTrigger); // only want to grab the listNode IF it's using the latest a11y HTML structure

      var listNode = triggerNode ? this.element.querySelector(this.options.selectorMenu) : null;

      if (listNode) {
        listNode.removeAttribute('aria-activedescendant');
        var focusedItem = this.element.querySelector(this.options.selectorItemFocused);

        if (focusedItem) {
          focusedItem.classList.remove(this.options.classFocused);
        }
      }
    }
    /**
     * Update focus using aria-activedescendant HTML structure
     * @param {HTMLElement} itemToFocus The element to be focused.
     */

  }, {
    key: "_updateFocus",
    value: function _updateFocus(itemToFocus) {
      // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
      var triggerNode = this.element.querySelector(this.options.selectorTrigger); // only want to grab the listNode IF it's using the latest a11y HTML structure

      var listNode = triggerNode ? this.element.querySelector(this.options.selectorMenu) : null;
      var previouslyFocused = listNode.querySelector(this.options.selectorItemFocused);
      itemToFocus.classList.add(this.options.classFocused);
      listNode.setAttribute('aria-activedescendant', itemToFocus.id);

      if (previouslyFocused) {
        previouslyFocused.classList.remove(this.options.classFocused);
      }
    }
    /**
     * Opens and closes the dropdown menu.
     * @param {Event} [event] The event triggering this method.
     *
     * @todo https://github.com/carbon-design-system/carbon/issues/3641
     */

  }, {
    key: "_toggle",
    value: function _toggle(event) {
      var _this2 = this;

      var isDisabled = this.element.classList.contains(this.options.classDisabled);

      if (isDisabled) {
        return;
      } // NOTE: `selectorTrigger` does NOT match the trigger button in older markup


      var triggerNode = this.element.querySelector(this.options.selectorTrigger);

      if ( // User presses down arrow
      event.which === 40 && !event.target.matches(this.options.selectorItem) || // User presses space or enter and the trigger is not a button OR event is not fired by trigger
      (!triggerNode || !triggerNode.contains(event.target)) && [13, 32].indexOf(event.which) >= 0 && !event.target.matches(this.options.selectorItem) || // User presses esc
      event.which === 27 || // User clicks
      event.type === 'click') {
        var isOpen = this.element.classList.contains(this.options.classOpen);
        var isOfSelf = this.element.contains(event.target); // Determine if the open className should be added, removed, or toggled

        var actions = {
          add: isOfSelf && event.which === 40 && !isOpen,
          remove: (!isOfSelf || event.which === 27) && isOpen,
          toggle: isOfSelf && event.which !== 27 && event.which !== 40
        };
        var changedState = false;
        Object.keys(actions).forEach(function (action) {
          if (actions[action]) {
            changedState = true;

            _this2.element.classList[action](_this2.options.classOpen);
          }
        });
        var listItems = toArray(this.element.querySelectorAll(this.options.selectorItem)); // only want to grab the listNode IF it's using the latest a11y HTML structure

        var listNode = triggerNode ? this.element.querySelector(this.options.selectorMenu) : null; // @todo remove conditionals for elements existing once legacy structure is depreciated

        if (changedState && this.element.classList.contains(this.options.classOpen)) {
          // toggled open
          if (triggerNode) {
            triggerNode.setAttribute('aria-expanded', 'true');
          }

          (listNode || this.element).focus();

          if (listNode) {
            var selectedNode = listNode.querySelector(this.options.selectorLinkSelected);
            listNode.setAttribute('aria-activedescendant', (selectedNode || listItems[0]).id);
            (selectedNode || listItems[0]).classList.add(this.options.classFocused);
          }
        } else if (changedState && (isOfSelf || actions.remove)) {
          // toggled close
          // timer is used to call focus AFTER the click event on
          // trigger button (which is caused by keypress e.g. during keyboard navigation)
          setTimeout(function () {
            return (triggerNode || _this2.element).focus();
          }, 0);

          if (triggerNode) {
            triggerNode.setAttribute('aria-expanded', 'false');
          }

          this._focusCleanup();
        } // @todo remove once legacy structure is depreciated


        if (!triggerNode) {
          listItems.forEach(function (item) {
            if (_this2.element.classList.contains(_this2.options.classOpen)) {
              item.tabIndex = 0;
            } else {
              item.tabIndex = -1;
            }
          });
        }

        var menuListNode = this.element.querySelector(this.options.selectorMenu);

        if (menuListNode) {
          menuListNode.tabIndex = this.element.classList.contains(this.options.classOpen) ? '0' : '-1';
        }
      }
    }
    /**
     * @returns {Element} Currently highlighted element.
     */

  }, {
    key: "getCurrentNavigation",
    value: function getCurrentNavigation() {
      var focusedNode; // Using the latest semantic markup structure where trigger is a button
      // @todo remove conditional once legacy structure is depreciated
      // NOTE: `selectorTrigger` does NOT match the trigger button in older markup

      if (this.element.querySelector(this.options.selectorTrigger)) {
        var listNode = this.element.querySelector(this.options.selectorMenu);
        var focusedId = listNode.getAttribute('aria-activedescendant');
        focusedNode = focusedId ? listNode.querySelector("#".concat(focusedId)) : null;
      } else {
        var focused = this.element.ownerDocument.activeElement;
        focusedNode = focused.nodeType === Node.ELEMENT_NODE && focused.matches(this.options.selectorItem) ? focused : null;
      }

      return focusedNode;
    }
    /**
     * Moves up/down the focus.
     * @param {number} direction The direction of navigating.
     */
    // @todo create issue it's a better UX to move the focus when the user hovers so they stay in sync

  }, {
    key: "navigate",
    value: function navigate(direction) {
      var items = toArray(this.element.querySelectorAll(this.options.selectorItem));
      var start = this.getCurrentNavigation() || this.element.querySelector(this.options.selectorLinkSelected);

      var getNextItem = function getNextItem(old) {
        var handleUnderflow = function handleUnderflow(i, l) {
          return i + (i >= 0 ? 0 : l);
        };

        var handleOverflow = function handleOverflow(i, l) {
          return i - (i < l ? 0 : l);
        }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


        var index = Math.max(items.indexOf(old) + direction, -1);
        return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
      };

      var isShowSelected = this.element.classList.contains(this.options.classShowSelected);

      for (var current = getNextItem(start); current && current !== start; current = getNextItem(current)) {
        if (!current.matches(this.options.selectorItemHidden) && !current.parentNode.matches(this.options.selectorItemHidden) && (isShowSelected || !isShowSelected && !current.parentElement.matches(this.options.selectorItemSelected))) {
          // Using the latest semantic markup structure where trigger is a button
          // @todo remove conditional once legacy structure is depreciated
          // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
          if (this.element.querySelector(this.options.selectorTrigger)) {
            this._updateFocus(current);
          } else {
            current.focus();
          }

          break;
        }
      }
    }
    /**
     * Handles clicking on the dropdown options, doing the following:
     * * Change Dropdown text to selected option.
     * * Remove selected option from options when selected.
     * * Emit custom events.
     * @param {HTMLElement} itemToSelect The element to be activated.
     */

  }, {
    key: "select",
    value: function select(itemToSelect) {
      var _this3 = this;

      var eventStart = new CustomEvent(this.options.eventBeforeSelected, {
        bubbles: true,
        cancelable: true,
        detail: {
          item: itemToSelect
        }
      });

      if (this.element.dispatchEvent(eventStart)) {
        if (this.element.dataset.dropdownType !== 'navigation') {
          // NOTE: `selectorTrigger` does NOT match the trigger button in older markup
          var selectorText = !this.element.querySelector(this.options.selectorTrigger) && this.element.dataset.dropdownType !== 'inline' ? this.options.selectorText : this.options.selectorTextInner;
          var text = this.element.querySelector(selectorText);

          if (text) {
            text.innerHTML = itemToSelect.innerHTML;
          }

          itemToSelect.parentElement.classList.add(this.options.classSelected);
        }

        this.element.dataset.value = itemToSelect.parentElement.dataset.value;
        toArray(this.element.querySelectorAll(this.options.selectorLinkSelected)).forEach(function (item) {
          if (itemToSelect !== item) {
            item.parentElement.classList.remove(_this3.options.classSelected);
          }
        });
        this.element.dispatchEvent(new CustomEvent(this.options.eventAfterSelected, {
          bubbles: true,
          cancelable: true,
          detail: {
            item: itemToSelect
          }
        }));
      }
    }
    /**
     * Closes the dropdown menu if this component loses focus.
     */

  }, {
    key: "handleBlur",
    value: function handleBlur() {
      this.element.classList.remove(this.options.classOpen);

      this._focusCleanup();
    }
    /**
     * The map associating DOM element and selector instance.
     * @member Dropdown.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Dropdown.create .create()}, or {@linkcode Dropdown.init .init()},
     * properties in this object are overridden for the instance being create and how {@linkcode Dropdown.init .init()} works.
     * @member Dropdown.options
     * @type {object}
     * @property {string} selectorInit The CSS selector to find selectors.
     * @property {string} [selectorTrigger]
     *   The CSS selector to find the trigger button when using a11y compliant markup.
     *   NOTE: Does NOT match the trigger button in older markup.
     * @property {string} [selectorMenu] The CSS selector to find menu list when using a11y compliant markup.
     * @property {string} [selectorText] The CSS selector to find the element showing the selected item.
     * @property {string} [selectorTextInner] The CSS selector to find the element showing the selected item, used for inline mode.
     * @property {string} [selectorItem] The CSS selector to find clickable areas in dropdown items.
     * @property {string} [selectorItemHidden]
     *   The CSS selector to find hidden dropdown items.
     *   Used to skip dropdown items for keyboard navigation.
     * @property {string} [selectorItemSelected] The CSS selector to find the clickable area in the selected dropdown item.
     * @property {string} [selectorItemFocused] The CSS selector to find the clickable area in the focused dropdown item.
     * @property {string} [selectorLinkSelected] The CSS selector to target the link node of the selected dropdown item.
     * @property {string} [classShowSelected] The CSS class for the show selected modifier of the dropdown.
     * @property {string} [classSelected] The CSS class for the selected dropdown item.
     * @property {string} [classFocused] The CSS class for the focused dropdown item.
     * @property {string} [classOpen] The CSS class for the open state.
     * @property {string} [classDisabled] The CSS class for the disabled state.
     * @property {string} [eventBeforeSelected]
     *   The name of the custom event fired before a drop down item is selected.
     *   Cancellation of this event stops selection of drop down item.
     * @property {string} [eventAfterSelected] The name of the custom event fired after a drop down item is selected.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-dropdown]',
        selectorTrigger: "button.".concat(prefix, "--dropdown-text"),
        // NOTE: Does NOT match the trigger button in older markup.
        selectorMenu: ".".concat(prefix, "--dropdown-list"),
        selectorText: ".".concat(prefix, "--dropdown-text"),
        selectorTextInner: ".".concat(prefix, "--dropdown-text__inner"),
        selectorItem: ".".concat(prefix, "--dropdown-link"),
        selectorItemSelected: ".".concat(prefix, "--dropdown--selected"),
        selectorItemFocused: ".".concat(prefix, "--dropdown--focused"),
        selectorItemHidden: "[hidden],[aria-hidden=\"true\"]",
        selectorLinkSelected: ".".concat(prefix, "--dropdown--selected .").concat(prefix, "--dropdown-link"),
        classShowSelected: "".concat(prefix, "--dropdown--show-selected"),
        classSelected: "".concat(prefix, "--dropdown--selected"),
        classFocused: "".concat(prefix, "--dropdown--focused"),
        classOpen: "".concat(prefix, "--dropdown--open"),
        classDisabled: "".concat(prefix, "--dropdown--disabled"),
        eventBeforeSelected: 'dropdown-beingselected',
        eventAfterSelected: 'dropdown-selected'
      };
    }
    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member Dropdown.NAVIGATE
     * @type {object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  Dropdown.components = new WeakMap();
  Dropdown.NAVIGATE = {
    BACKWARD: -1,
    FORWARD: 1
  };
  return Dropdown;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_track_blur__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dropdown);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/file-uploader/file-uploader.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/file-uploader/file-uploader.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/evented-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */











var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var FileUploader = /*#__PURE__*/function (_mixin) {
  _inherits(FileUploader, _mixin);

  var _super = _createSuper(FileUploader);
  /**
   * File uploader.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends eventedState
   * @extends Handles
   * @param {HTMLElement} element The element working as a file uploader.
   * @param {object} [options] The component options. See static options.
   */


  function FileUploader(element) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, FileUploader);

    _this = _super.call(this, element, options);

    _this._changeState = function (state, detail, callback) {
      if (state === 'delete-filename-fileuploader') {
        _this.container.removeChild(detail.filenameElement);
      }

      if (typeof callback === 'function') {
        callback();
      }
    };

    _this._handleDeleteButton = function (evt) {
      var target = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(evt, _this.options.selectorCloseButton);

      if (target) {
        _this.changeState('delete-filename-fileuploader', {
          initialEvt: evt,
          filenameElement: target.closest(_this.options.selectorSelectedFile)
        });
      }
    };

    _this._handleDragDrop = function (evt) {
      var isOfSelf = _this.element.contains(evt.target); // In IE11 `evt.dataTransfer.types` is a `DOMStringList` instead of an array


      if (Array.prototype.indexOf.call(evt.dataTransfer.types, 'Files') >= 0 && !(0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(evt, _this.options.selectorOtherDropContainers)) {
        var inArea = isOfSelf && (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(evt, _this.options.selectorDropContainer);

        if (evt.type === 'dragover') {
          evt.preventDefault();
          var dropEffect = inArea ? 'copy' : 'none';

          if (Array.isArray(evt.dataTransfer.types)) {
            // IE11 throws a "permission denied" error accessing `.effectAllowed`
            evt.dataTransfer.effectAllowed = dropEffect;
          }

          evt.dataTransfer.dropEffect = dropEffect;

          _this.dropContainer.classList.toggle(_this.options.classDragOver, Boolean(inArea));
        }

        if (evt.type === 'dragleave') {
          _this.dropContainer.classList.toggle(_this.options.classDragOver, false);
        }

        if (inArea && evt.type === 'drop') {
          evt.preventDefault();

          _this._displayFilenames(evt.dataTransfer.files);

          _this.dropContainer.classList.remove(_this.options.classDragOver);
        }
      }
    };

    _this.input = _this.element.querySelector(_this.options.selectorInput);
    _this.container = _this.element.querySelector(_this.options.selectorContainer);
    _this.dropContainer = _this.element.querySelector(_this.options.selectorDropContainer);

    if (!_this.input) {
      throw new TypeError('Cannot find the file input box.');
    }

    if (!_this.container) {
      throw new TypeError('Cannot find the file names container.');
    }

    _this.inputId = _this.input.getAttribute('id');

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.input, 'change', function () {
      return _this._displayFilenames();
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.container, 'click', _this._handleDeleteButton));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.ownerDocument, 'dragleave', _this._handleDragDrop));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.dropContainer, 'dragover', _this._handleDragDrop));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.dropContainer, 'drop', _this._handleDragDrop));

    return _this;
  }

  _createClass(FileUploader, [{
    key: "_filenamesHTML",
    value: function _filenamesHTML(name, id) {
      return "<span class=\"".concat(this.options.classSelectedFile, "\">\n      <p class=\"").concat(this.options.classFileName, "\">").concat(name, "</p>\n      <span data-for=\"").concat(id, "\" class=\"").concat(this.options.classStateContainer, "\"></span>\n    </span>");
    }
  }, {
    key: "_uploadHTML",
    value: function _uploadHTML() {
      return "\n      <div class=\"".concat(this.options.classLoadingAnimation, "\">\n        <div data-inline-loading-spinner class=\"").concat(this.options.classLoading, "\">\n          <svg class=\"").concat(this.options.classLoadingSvg, "\" viewBox=\"-75 -75 150 150\">\n            <circle class=\"").concat(this.options.classLoadingBackground, "\" cx=\"0\" cy=\"0\" r=\"37.5\" />\n            <circle class=\"").concat(this.options.classLoadingStroke, "\" cx=\"0\" cy=\"0\" r=\"37.5\" />\n          </svg>\n        </div>\n      </div>");
    }
  }, {
    key: "_closeButtonHTML",
    value: function _closeButtonHTML() {
      return "\n      <button class=\"".concat(this.options.classFileClose, "\" type=\"button\" aria-label=\"close\">\n      <svg aria-hidden=\"true\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\">\n      <path fill=\"#231F20\" d=\"M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z\"/>\n      </svg>\n      </button>");
    }
  }, {
    key: "_checkmarkHTML",
    value: function _checkmarkHTML() {
      return "\n      <svg focusable=\"false\"\n        preserveAspectRatio=\"xMidYMid meet\"\n        style=\"will-change: transform;\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        class=\"".concat(this.options.classFileComplete, "\"\n        width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"\n        aria-hidden=\"true\">\n        <path d=\"M8 1C4.1 1 1 4.1 1 8s3.1 7 7 7 7-3.1 7-7-3.1-7-7-7zM7 11L4.3 8.3l.9-.8L7 9.3l4-3.9.9.8L7 11z\"></path>\n        <path d=\"M7 11L4.3 8.3l.9-.8L7 9.3l4-3.9.9.8L7 11z\" data-icon-path=\"inner-path\" opacity=\"0\"></path>\n      </svg>\n    ");
    }
  }, {
    key: "_getStateContainers",
    value: function _getStateContainers() {
      var stateContainers = toArray(this.element.querySelectorAll("[data-for=".concat(this.inputId, "]")));

      if (stateContainers.length === 0) {
        throw new TypeError('State container elements not found; invoke _displayFilenames() first');
      }

      if (stateContainers[0].dataset.for !== this.inputId) {
        throw new TypeError('File input id must equal [data-for] attribute');
      }

      return stateContainers;
    }
    /**
     * Inject selected files into DOM. Invoked on change event.
     * @param {File[]} files The files to upload.
     */

  }, {
    key: "_displayFilenames",
    value: function _displayFilenames() {
      var _this2 = this;

      var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.input.files;
      var container = this.element.querySelector(this.options.selectorContainer);
      var HTMLString = toArray(files).map(function (file) {
        return _this2._filenamesHTML(file.name, _this2.inputId);
      }).join('');
      container.insertAdjacentHTML('afterbegin', HTMLString);
    }
  }, {
    key: "_removeState",
    value: function _removeState(element) {
      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        throw new TypeError('DOM element should be given to initialize this widget.');
      }

      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
  }, {
    key: "_handleStateChange",
    value: function _handleStateChange(elements, selectIndex, html) {
      var _this3 = this;

      if (selectIndex === undefined) {
        elements.forEach(function (el) {
          _this3._removeState(el);

          el.insertAdjacentHTML('beforeend', html);
        });
      } else {
        elements.forEach(function (el, index) {
          if (index === selectIndex) {
            _this3._removeState(el);

            el.insertAdjacentHTML('beforeend', html);
          }
        });
      }
    }
    /**
     * Handles delete button.
     * @param {Event} evt The event triggering this action.
     * @private
     */

  }, {
    key: "setState",
    value: function setState(state, selectIndex) {
      var stateContainers = this._getStateContainers();

      if (state === 'edit') {
        this._handleStateChange(stateContainers, selectIndex, this._closeButtonHTML());
      }

      if (state === 'upload') {
        this._handleStateChange(stateContainers, selectIndex, this._uploadHTML());
      }

      if (state === 'complete') {
        this._handleStateChange(stateContainers, selectIndex, this._checkmarkHTML());
      }
    }
    /**
     * The map associating DOM element and file uploader instance.
     * @member FileUploader.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-file]',
        selectorInput: "input[type=\"file\"].".concat(prefix, "--file-input"),
        selectorContainer: '[data-file-container]',
        selectorCloseButton: ".".concat(prefix, "--file-close"),
        selectorSelectedFile: ".".concat(prefix, "--file__selected-file"),
        selectorDropContainer: "[data-file-drop-container]",
        selectorOtherDropContainers: '[data-drop-container]',
        classLoading: "".concat(prefix, "--loading ").concat(prefix, "--loading--small"),
        classLoadingAnimation: "".concat(prefix, "--inline-loading__animation"),
        classLoadingSvg: "".concat(prefix, "--loading__svg"),
        classLoadingBackground: "".concat(prefix, "--loading__background"),
        classLoadingStroke: "".concat(prefix, "--loading__stroke"),
        classFileName: "".concat(prefix, "--file-filename"),
        classFileClose: "".concat(prefix, "--file-close"),
        classFileComplete: "".concat(prefix, "--file-complete"),
        classSelectedFile: "".concat(prefix, "--file__selected-file"),
        classStateContainer: "".concat(prefix, "--file__state-container"),
        classDragOver: "".concat(prefix, "--file__drop-container--drag-over"),
        eventBeforeDeleteFilenameFileuploader: 'fileuploader-before-delete-filename',
        eventAfterDeleteFilenameFileuploader: 'fileuploader-after-delete-filename'
      };
    }
  }]);

  FileUploader.components = new WeakMap();
  return FileUploader;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileUploader);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/floating-menu/floating-menu.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/floating-menu/floating-menu.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DIRECTION_BOTTOM": () => (/* binding */ DIRECTION_BOTTOM),
/* harmony export */   "DIRECTION_LEFT": () => (/* binding */ DIRECTION_LEFT),
/* harmony export */   "DIRECTION_RIGHT": () => (/* binding */ DIRECTION_RIGHT),
/* harmony export */   "DIRECTION_TOP": () => (/* binding */ DIRECTION_TOP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getFloatingPosition": () => (/* binding */ getFloatingPosition)
/* harmony export */ });
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/evented-show-hide-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-show-hide-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_mixins_track_blur__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../globals/js/mixins/track-blur */ "../../node_modules/carbon-components/es/globals/js/mixins/track-blur.js");
/* harmony import */ var _globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/get-launching-details */ "../../node_modules/carbon-components/es/globals/js/misc/get-launching-details.js");
/* harmony import */ var _globals_js_misc_resize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/resize */ "../../node_modules/carbon-components/es/globals/js/misc/resize.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */












/**
 * The structure for the position of floating menu.
 * @typedef {object} FloatingMenu~position
 * @property {number} left The left position.
 * @property {number} top The top position.
 * @property {number} right The right position.
 * @property {number} bottom The bottom position.
 */

/**
 * The structure for the size of floating menu.
 * @typedef {object} FloatingMenu~size
 * @property {number} width The width.
 * @property {number} height The height.
 */

/**
 * The structure for the position offset of floating menu.
 * @typedef {object} FloatingMenu~offset
 * @property {number} top The top position.
 * @property {number} left The left position.
 */

var DIRECTION_LEFT = 'left';
var DIRECTION_TOP = 'top';
var DIRECTION_RIGHT = 'right';
var DIRECTION_BOTTOM = 'bottom';
/**
 * @param {object} params The parameters.
 * @param {FloatingMenu~size} params.menuSize The size of the menu.
 * @param {FloatingMenu~position} params.refPosition The position of the triggering element.
 * @param {FloatingMenu~offset} [params.offset={ left: 0, top: 0 }] The position offset of the menu.
 * @param {string} [params.direction=bottom] The menu direction.
 * @param {number} [params.scrollX=0] The scroll position of the viewport.
 * @param {number} [params.scrollY=0] The scroll position of the viewport.
 * @returns {FloatingMenu~offset} The position of the menu, relative to the top-left corner of the viewport.
 * @private
 */

var getFloatingPosition = function getFloatingPosition(_ref) {
  var _DIRECTION_LEFT$DIREC;

  var menuSize = _ref.menuSize,
      refPosition = _ref.refPosition,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? {} : _ref$offset,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? DIRECTION_BOTTOM : _ref$direction,
      _ref$scrollX = _ref.scrollX,
      scrollX = _ref$scrollX === void 0 ? 0 : _ref$scrollX,
      _ref$scrollY = _ref.scrollY,
      scrollY = _ref$scrollY === void 0 ? 0 : _ref$scrollY;
  var _refPosition$left = refPosition.left,
      refLeft = _refPosition$left === void 0 ? 0 : _refPosition$left,
      _refPosition$top = refPosition.top,
      refTop = _refPosition$top === void 0 ? 0 : _refPosition$top,
      _refPosition$right = refPosition.right,
      refRight = _refPosition$right === void 0 ? 0 : _refPosition$right,
      _refPosition$bottom = refPosition.bottom,
      refBottom = _refPosition$bottom === void 0 ? 0 : _refPosition$bottom;
  var width = menuSize.width,
      height = menuSize.height;
  var _offset$top = offset.top,
      top = _offset$top === void 0 ? 0 : _offset$top,
      _offset$left = offset.left,
      left = _offset$left === void 0 ? 0 : _offset$left;
  var refCenterHorizontal = (refLeft + refRight) / 2;
  var refCenterVertical = (refTop + refBottom) / 2;
  return (_DIRECTION_LEFT$DIREC = {}, _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT, {
    left: refLeft - width + scrollX - left,
    top: refCenterVertical - height / 2 + scrollY + top
  }), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_TOP, {
    left: refCenterHorizontal - width / 2 + scrollX + left,
    top: refTop - height + scrollY - top
  }), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT, {
    left: refRight + scrollX + left,
    top: refCenterVertical - height / 2 + scrollY + top
  }), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM, {
    left: refCenterHorizontal - width / 2 + scrollX + left,
    top: refBottom + scrollY + top
  }), _DIRECTION_LEFT$DIREC)[direction];
};

var FloatingMenu = /*#__PURE__*/function (_mixin) {
  _inherits(FloatingMenu, _mixin);

  var _super = _createSuper(FloatingMenu);
  /**
   * Floating menu.
   * @extends CreateComponent
   * @extends EventedShowHideState
   * @param {HTMLElement} element The element working as a modal dialog.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorContainer] The CSS selector to find the container to put this menu in.
   * @param {string} [options.attribDirection] The attribute name to specify menu placement direction (top/right/bottom/left).
   * @param {string} [options.classShown] The CSS class for shown state, for the menu.
   * @param {string} [options.classRefShown] The CSS class for shown state, for the trigger button.
   * @param {string} [options.eventBeforeShown]
   *   The name of the custom event fired before this menu is shown.
   *   Cancellation of this event stops hiding the menu.
   * @param {string} [options.eventAfterShown]
   *   The name of the custom event telling that menu is sure shown
   *   without being canceled by the event handler named by `eventBeforeShown` option (`floating-menu-beingshown`).
   * @param {string} [options.eventBeforeHidden]
   *   The name of the custom event fired before this menu is hidden.
   *   Cancellation of this event stops hiding the menu.
   * @param {string} [options.eventAfterHidden]
   *   The name of the custom event telling that menu is sure hidden
   *   without being canceled by the event handler named by `eventBeforeHidden` option (`floating-menu-beinghidden`).
   * @param {Element} [options.refNode] The launching element of the menu. Used for calculating the geometry of the menu.
   * @param {object} [options.offset] The offset to adjust the geometry of the menu. Should have `top`/`left` properties.
   */


  function FloatingMenu(element, options) {
    var _this;

    _classCallCheck(this, FloatingMenu);

    _this = _super.call(this, element, options);

    var attribDirectionValue = _this.element.getAttribute(_this.options.attribDirection);

    if (!_this.options.direction) {
      _this.options.direction = attribDirectionValue || 'bottom';
    }

    if (!attribDirectionValue) {
      // Update attribute for styling
      _this.element.setAttribute(_this.options.attribDirection, _this.options.direction);
    }

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.ownerDocument, 'keydown', function (event) {
      _this._handleKeydown(event);
    }));

    return _this;
  }
  /**
   * Handles key press on document.
   * @param {Event} event The triggering event.
   * @private
   */


  _createClass(FloatingMenu, [{
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      var key = event.which;
      var _this$options = this.options,
          triggerNode = _this$options.triggerNode,
          refNode = _this$options.refNode;
      var isOfMenu = this.element.contains(event.target);

      switch (key) {
        // Esc
        case 27:
          this.changeState('hidden', (0,_globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_2__["default"])(event), function () {
            if (isOfMenu) {
              (triggerNode || refNode).focus();
            }
          });
          break;

        default:
          break;
      }
    }
    /**
     * Focuses back on the trigger button if this component loses focus.
     */

  }, {
    key: "handleBlur",
    value: function handleBlur(event) {
      if (this.element.classList.contains(this.options.classShown)) {
        this.changeState('hidden', (0,_globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_2__["default"])(event));
        var _this$options2 = this.options,
            refNode = _this$options2.refNode,
            triggerNode = _this$options2.triggerNode;

        if ((event.relatedTarget === null || this.element.contains(event.relatedTarget)) && refNode && event.target !== refNode) {
          HTMLElement.prototype.focus.call(triggerNode || refNode); // SVGElement in IE11 does not have `.focus()` method
        }
      }
    }
    /**
     * @private
     * @returns {Element} The element that this menu should be placed to.
     */

  }, {
    key: "_getContainer",
    value: function _getContainer() {
      return this.element.closest(this.options.selectorContainer) || this.element.ownerDocument.body;
    }
    /**
     * @private
     * @returns {object} The menu position, with `top` and `left` properties.
     */

  }, {
    key: "_getPos",
    value: function _getPos() {
      var element = this.element;
      var _this$options3 = this.options,
          refNode = _this$options3.refNode,
          offset = _this$options3.offset,
          direction = _this$options3.direction;

      if (!refNode) {
        throw new Error('Cannot find the reference node for positioning floating menu.');
      }

      return getFloatingPosition({
        menuSize: element.getBoundingClientRect(),
        refPosition: refNode.getBoundingClientRect(),
        offset: typeof offset !== 'function' ? offset : offset(element, direction, refNode),
        direction: direction,
        scrollX: refNode.ownerDocument.defaultView.pageXOffset,
        scrollY: refNode.ownerDocument.defaultView.pageYOffset
      });
    }
    /**
     * Sees if the computed style is what this floating menu expects.
     * @private
     */

  }, {
    key: "_testStyles",
    value: function _testStyles() {
      if (!this.options.debugStyle) {
        return;
      }

      var element = this.element;
      var computedStyle = element.ownerDocument.defaultView.getComputedStyle(element);
      var styles = {
        position: 'absolute',
        right: 'auto',
        margin: 0
      };
      Object.keys(styles).forEach(function (key) {
        var expected = typeof styles[key] === 'number' ? parseFloat(styles[key]) : styles[key];
        var actual = computedStyle.getPropertyValue(key);

        if (expected !== actual) {
          // eslint-disable-next-line no-console
          console.warn("Floating menu component expects ".concat(key, ": ").concat(styles[key], " style."));
        }
      });
    }
    /**
     * Places the menu.
     * @private
     */

  }, {
    key: "_place",
    value: function _place() {
      var element = this.element;

      var _this$_getPos = this._getPos(),
          left = _this$_getPos.left,
          top = _this$_getPos.top;

      element.style.left = "".concat(left, "px");
      element.style.top = "".concat(top, "px");

      this._testStyles();
    }
    /**
     * @param {string} state The new state.
     * @returns {boolean} `true` of the current state is different from the given new state.
     */

  }, {
    key: "shouldStateBeChanged",
    value: function shouldStateBeChanged(state) {
      return (state === 'shown' || state === 'hidden') && state !== (this.element.classList.contains(this.options.classShown) ? 'shown' : 'hidden');
    }
    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {object} detail The detail of the event trigging this action.
     * @param {Function} callback Callback called when change in state completes.
     */

  }, {
    key: "_changeState",
    value: function _changeState(state, detail, callback) {
      var _this2 = this;

      var shown = state === 'shown';
      var _this$options4 = this.options,
          refNode = _this$options4.refNode,
          classShown = _this$options4.classShown,
          classRefShown = _this$options4.classRefShown,
          triggerNode = _this$options4.triggerNode;

      if (!refNode) {
        throw new TypeError('Cannot find the reference node for changing the style.');
      }

      if (state === 'shown') {
        if (!this.hResize) {
          this.hResize = _globals_js_misc_resize__WEBPACK_IMPORTED_MODULE_3__["default"].add(function () {
            _this2._place();
          });
        }

        this._getContainer().appendChild(this.element);
      }

      this.element.setAttribute('aria-hidden', (!shown).toString());
      (triggerNode || refNode).setAttribute('aria-expanded', shown.toString());
      this.element.classList.toggle(classShown, shown);

      if (classRefShown) {
        refNode.classList.toggle(classRefShown, shown);
      }

      if (state === 'shown') {
        this._place(); // IE11 puts focus on elements with `.focus()`, even ones without `tabindex` attribute


        if (!this.element.hasAttribute(this.options.attribAvoidFocusOnOpen)) {
          var primaryFocusNode = this.element.querySelector(this.options.selectorPrimaryFocus);
          var contentNode = this.options.contentNode || this.element;
          var tabbableNode = contentNode.querySelector(_globals_js_settings__WEBPACK_IMPORTED_MODULE_4__["default"].selectorTabbable); // The programmatically focusable element may be (and typically will be) the content node itself;

          var focusableNode = contentNode.matches(_globals_js_settings__WEBPACK_IMPORTED_MODULE_4__["default"].selectorFocusable) ? contentNode : contentNode.querySelector(_globals_js_settings__WEBPACK_IMPORTED_MODULE_4__["default"].selectorFocusable);

          if (primaryFocusNode) {
            // User defined focusable node
            primaryFocusNode.focus();
          } else if (tabbableNode) {
            // First sequentially focusable node
            tabbableNode.focus();
          } else if (focusableNode) {
            // First programmatic focusable node
            focusableNode.focus();
          } else {
            this.element.focus();

            if (true) {
               true ? warning__WEBPACK_IMPORTED_MODULE_0___default()(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. ' + 'This can be accomplished by adding tabindex="-1" to the content element.') : 0;
            }
          }
        }
      }

      if (state === 'hidden' && this.hResize) {
        this.hResize.release();
        this.hResize = null;
      }

      callback();
    }
  }, {
    key: "release",
    value: function release() {
      if (this.hResize) {
        this.hResize.release();
        this.hResize = null;
      }

      _get(_getPrototypeOf(FloatingMenu.prototype), "release", this).call(this);
    }
  }]);

  FloatingMenu.options = {
    selectorContainer: '[data-floating-menu-container]',
    selectorPrimaryFocus: '[data-floating-menu-primary-focus]',
    attribDirection: 'data-floating-menu-direction',
    attribAvoidFocusOnOpen: 'data-avoid-focus-on-open',
    classShown: '',
    // Should be provided from options arg in constructor
    classRefShown: '',
    // Should be provided from options arg in constructor
    eventBeforeShown: 'floating-menu-beingshown',
    eventAfterShown: 'floating-menu-shown',
    eventBeforeHidden: 'floating-menu-beinghidden',
    eventAfterHidden: 'floating-menu-hidden',
    refNode: null,
    // Should be provided from options arg in constructor
    offset: {
      left: 0,
      top: 0
    }
  };
  FloatingMenu.components = new WeakMap();
  return FloatingMenu;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_5__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_7__["default"], _globals_js_mixins_track_blur__WEBPACK_IMPORTED_MODULE_8__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_9__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FloatingMenu);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/inline-loading/inline-loading.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/inline-loading/inline-loading.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/toggle-attribute */ "../../node_modules/carbon-components/es/globals/js/misc/toggle-attribute.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var InlineLoading = /*#__PURE__*/function (_mixin) {
  _inherits(InlineLoading, _mixin);

  var _super = _createSuper(InlineLoading);
  /**
   * Spinner indicating loading state.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a spinner.
   * @param {object} [options] The component options.
   * @param {string} [options.initialState] The initial state, should be `inactive`, `active` or `finished`.
   */


  function InlineLoading(element, options) {
    var _this;

    _classCallCheck(this, InlineLoading);

    _this = _super.call(this, element, options); // Sets the initial state

    var initialState = _this.options.initialState;

    if (initialState) {
      _this.setState(initialState);
    }

    return _this;
  }
  /**
   * Sets active/inactive state.
   * @param {string} state The new state, should be `inactive`, `active` or `finished`.
   */


  _createClass(InlineLoading, [{
    key: "setState",
    value: function setState(state) {
      var states = this.constructor.states;
      var values = Object.keys(states).map(function (key) {
        return states[key];
      });

      if (values.indexOf(state) < 0) {
        throw new Error("One of the following value should be given as the state: ".concat(values.join(', ')));
      }

      var elem = this.element;
      var _this$options = this.options,
          selectorSpinner = _this$options.selectorSpinner,
          selectorFinished = _this$options.selectorFinished,
          selectorError = _this$options.selectorError,
          selectorTextActive = _this$options.selectorTextActive,
          selectorTextFinished = _this$options.selectorTextFinished,
          selectorTextError = _this$options.selectorTextError;
      var spinner = elem.querySelector(selectorSpinner);
      var finished = elem.querySelector(selectorFinished);
      var error = elem.querySelector(selectorError);
      var textActive = elem.querySelector(selectorTextActive);
      var textFinished = elem.querySelector(selectorTextFinished);
      var textError = elem.querySelector(selectorTextError);

      if (spinner) {
        spinner.classList.toggle(this.options.classLoadingStop, state !== states.ACTIVE);
        (0,_globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__["default"])(spinner, 'hidden', state !== states.INACTIVE && state !== states.ACTIVE);
      }

      if (finished) {
        (0,_globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__["default"])(finished, 'hidden', state !== states.FINISHED);
      }

      if (error) {
        (0,_globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__["default"])(error, 'hidden', state !== states.ERROR);
      }

      if (textActive) {
        (0,_globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__["default"])(textActive, 'hidden', state !== states.ACTIVE);
      }

      if (textFinished) {
        (0,_globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__["default"])(textFinished, 'hidden', state !== states.FINISHED);
      }

      if (textError) {
        (0,_globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__["default"])(textError, 'hidden', state !== states.ERROR);
      }

      return this;
    }
    /**
     * The list of states.
     * @type {object<string, string>}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode InlineLoading.create .create()},
     * or {@linkcode InlineLoading.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode InlineLoading.init .init()} works.
     * @member InlineLoading.options
     * @type {object}
     * @property {string} selectorInit The CSS selector to find inline loading components.
     * @property {string} selectorSpinner The CSS selector to find the spinner.
     * @property {string} selectorFinished The CSS selector to find the "finished" icon.
     * @property {string} selectorError The CSS selector to find the "error" icon.
     * @property {string} selectorTextActive The CSS selector to find the text describing the active state.
     * @property {string} selectorTextFinished The CSS selector to find the text describing the finished state.
     * @property {string} selectorTextError The CSS selector to find the text describing the error state.
     * @property {string} classLoadingStop The CSS class for spinner's stopped state.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-inline-loading]',
        selectorSpinner: '[data-inline-loading-spinner]',
        selectorFinished: '[data-inline-loading-finished]',
        selectorError: '[data-inline-loading-error]',
        selectorTextActive: '[data-inline-loading-text-active]',
        selectorTextFinished: '[data-inline-loading-text-finished]',
        selectorTextError: '[data-inline-loading-text-error]',
        classLoadingStop: "".concat(prefix, "--loading--stop")
      };
    }
  }]);

  InlineLoading.states = {
    INACTIVE: 'inactive',
    ACTIVE: 'active',
    FINISHED: 'finished',
    ERROR: 'error'
  };
  InlineLoading.components = new WeakMap();
  return InlineLoading;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InlineLoading);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/loading/loading.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/loading/loading.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var Loading = /*#__PURE__*/function (_mixin) {
  _inherits(Loading, _mixin);

  var _super = _createSuper(Loading);
  /**
   * Spinner indicating loading state.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a spinner.
   * @param {object} [options] The component options.
   * @param {boolean} [options.active] `true` if this spinner should roll.
   */


  function Loading(element, options) {
    var _this;

    _classCallCheck(this, Loading);

    _this = _super.call(this, element, options);
    _this.active = _this.options.active; // Initialize spinner

    _this.set(_this.active);

    return _this;
  }
  /**
   * Sets active/inactive state.
   * @param {boolean} active `true` if this spinner should roll.
   */


  _createClass(Loading, [{
    key: "set",
    value: function set(active) {
      if (typeof active !== 'boolean') {
        throw new TypeError('set expects a boolean.');
      }

      this.active = active;
      this.element.classList.toggle(this.options.classLoadingStop, !this.active);
      /**
       * If overlay is the parentNode then toggle it too.
       */

      var parentNode = this.element.parentNode;

      if (parentNode && parentNode.classList.contains(this.options.classLoadingOverlay)) {
        parentNode.classList.toggle(this.options.classLoadingOverlayStop, !this.active);
      }

      return this;
    }
    /**
     * Toggles active/inactive state.
     */

  }, {
    key: "toggle",
    value: function toggle() {
      return this.set(!this.active);
    }
    /**
     * @returns {boolean} `true` if this spinner is rolling.
     */

  }, {
    key: "isActive",
    value: function isActive() {
      return this.active;
    }
    /**
     * Sets state to inactive and deletes the loading element.
     */

  }, {
    key: "end",
    value: function end() {
      var _this2 = this;

      this.set(false);
      var handleAnimationEnd = this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(this.element, 'animationend', function (evt) {
        if (handleAnimationEnd) {
          handleAnimationEnd = _this2.unmanage(handleAnimationEnd).release();
        }

        if (evt.animationName === 'rotate-end-p2') {
          _this2._deleteElement();
        }
      }));
    }
    /**
     * Delete component from the DOM.
     */

  }, {
    key: "_deleteElement",
    value: function _deleteElement() {
      var parentNode = this.element.parentNode;
      parentNode.removeChild(this.element);

      if (parentNode.classList.contains(this.options.selectorLoadingOverlay)) {
        parentNode.remove();
      }
    }
    /**
     * The map associating DOM element and spinner instance.
     * @member Loading.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Loading.create .create()}, or {@linkcode Loading.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Loading.init .init()} works.
     * @member Loading.options
     * @type {object}
     * @property {string} selectorInit The CSS selector to find spinners.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-loading]',
        selectorLoadingOverlay: ".".concat(prefix, "--loading-overlay"),
        classLoadingOverlay: "".concat(prefix, "--loading-overlay"),
        classLoadingStop: "".concat(prefix, "--loading--stop"),
        classLoadingOverlayStop: "".concat(prefix, "--loading-overlay--stop"),
        active: true
      };
    }
  }]);

  Loading.components = new WeakMap();
  return Loading;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Loading);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/modal/modal.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/modal/modal.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_launcher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-launcher */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-launcher.js");
/* harmony import */ var _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/evented-show-hide-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-show-hide-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */












var Modal = /*#__PURE__*/function (_mixin) {
  _inherits(Modal, _mixin);

  var _super = _createSuper(Modal);
  /**
   * Modal dialog.
   * @extends CreateComponent
   * @extends InitComponentByLauncher
   * @extends EventedShowHideState
   * @extends Handles
   * @param {HTMLElement} element The element working as a modal dialog.
   * @param {object} [options] The component options.
   * @param {string} [options.classVisible] The CSS class for the visible state.
   * @param {string} [options.classBody] The CSS class for `<body>` with open modal.
   * @param {string} [options.eventBeforeShown]
   *   The name of the custom event fired before this modal is shown.
   *   Cancellation of this event stops showing the modal.
   * @param {string} [options.eventAfterShown]
   *   The name of the custom event telling that modal is sure shown
   *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
   * @param {string} [options.eventBeforeHidden]
   *   The name of the custom event fired before this modal is hidden.
   *   Cancellation of this event stops hiding the modal.
   * @param {string} [options.eventAfterHidden]
   *   The name of the custom event telling that modal is sure hidden
   *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
   */


  function Modal(element, options) {
    var _this;

    _classCallCheck(this, Modal);

    _this = _super.call(this, element, options);
    _this._handleFocusinListener = void 0;
    _this._handleKeydownListener = void 0;

    _this._handleFocusin = function (evt) {
      var focusWrapNode = _this.element.querySelector(_this.options.selectorModalContainer) || _this.element;

      if (_this.element.classList.contains(_this.options.classVisible) && !focusWrapNode.contains(evt.target) && _this.options.selectorsFloatingMenus.every(function (selector) {
        return !(0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, selector);
      })) {
        _this.element.querySelector(_globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].selectorTabbable).focus();
      }
    };

    _this._hookCloseActions();

    return _this;
  }
  /**
   * The handle for `focusin` event listener.
   * Used for "focus-wrap" feature.
   * @type {Handle}
   * @private
   */


  _createClass(Modal, [{
    key: "createdByLauncher",
    value:
    /**
     * A method that runs when `.init()` is called from `initComponentByLauncher`.
     * @param {Event} evt The event fired on the launcher button.
     */
    function createdByLauncher(evt) {
      this.show(evt);
    }
    /**
     * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
     * @param {string} state The new state.
     * @returns {boolean} `true` if the given `state` is different from current state.
     */

  }, {
    key: "shouldStateBeChanged",
    value: function shouldStateBeChanged(state) {
      if (state === 'shown') {
        return !this.element.classList.contains(this.options.classVisible);
      }

      return this.element.classList.contains(this.options.classVisible);
    }
    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {object} detail The detail data to be included in the event that will be fired.
     * @param {Function} callback Callback called when change in state completes.
     */

  }, {
    key: "_changeState",
    value: function _changeState(state, detail, callback) {
      var _this2 = this;

      var handleTransitionEnd;

      var transitionEnd = function transitionEnd() {
        if (handleTransitionEnd) {
          handleTransitionEnd = _this2.unmanage(handleTransitionEnd).release();
        }

        if (state === 'shown' && _this2.element.offsetWidth > 0 && _this2.element.offsetHeight > 0) {
          _this2.previouslyFocusedNode = _this2.element.ownerDocument.activeElement;

          var focusableItem = _this2.element.querySelector(_this2.options.selectorPrimaryFocus) || _this2.element.querySelector(_globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].selectorTabbable);

          focusableItem.focus();

          if (true) {
             true ? warning__WEBPACK_IMPORTED_MODULE_0___default()(focusableItem, "Modals need to contain a focusable element by either using " + "`".concat(_this2.options.selectorPrimaryFocus, "` or settings.selectorTabbable.")) : 0;
          }
        }

        callback();
      };

      if (this._handleFocusinListener) {
        this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release();
      }

      if (state === 'shown') {
        var hasFocusin = ('onfocusin' in this.element.ownerDocument.defaultView);
        var focusinEventName = hasFocusin ? 'focusin' : 'focus';
        this._handleFocusinListener = this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_3__["default"])(this.element.ownerDocument, focusinEventName, this._handleFocusin, !hasFocusin));
      }

      if (state === 'hidden') {
        this.element.classList.toggle(this.options.classVisible, false);
        this.element.ownerDocument.body.classList.toggle(this.options.classBody, false);

        if (this.options.selectorFocusOnClose || this.previouslyFocusedNode) {
          (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus();
        }
      } else if (state === 'shown') {
        this.element.classList.toggle(this.options.classVisible, true);
        this.element.ownerDocument.body.classList.toggle(this.options.classBody, true);
      }

      handleTransitionEnd = this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_3__["default"])(this.element, 'transitionend', transitionEnd));
    }
  }, {
    key: "_hookCloseActions",
    value: function _hookCloseActions() {
      var _this3 = this;

      this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_3__["default"])(this.element, 'click', function (evt) {
        var closeButton = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this3.options.selectorModalClose);

        if (closeButton) {
          evt.delegateTarget = closeButton; // eslint-disable-line no-param-reassign
        }

        if (closeButton || evt.target === _this3.element) {
          _this3.hide(evt);
        }
      }));

      if (this._handleKeydownListener) {
        this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release();
      }

      this._handleKeydownListener = this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_3__["default"])(this.element.ownerDocument.body, 'keydown', function (evt) {
        // Avoid running `evt.stopPropagation()` only when modal is shown
        if (evt.which === 27 && _this3.shouldStateBeChanged('hidden')) {
          evt.stopPropagation();

          _this3.hide(evt);
        }
      }));
    }
    /**
     * Handles `focusin` (or `focus` depending on browser support of `focusin`) event to do wrap-focus behavior.
     * @param {Event} evt The event.
     * @private
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Modal.init .init()} works.
     * @member Modal.options
     * @type {object}
     * @property {string} selectorInit The CSS class to find modal dialogs.
     * @property {string} [selectorModalClose] The selector to find elements that close the modal.
     * @property {string} [selectorPrimaryFocus] The CSS selector to determine the element to put focus when modal gets open.
     * @property {string} [selectorFocusOnClose] The CSS selector to determine the element to put focus when modal closes.
     *   If undefined, focus returns to the previously focused element prior to the modal opening.
     * @property {string} [selectorModalContainer] The CSS selector for the content container of the modal for focus wrap feature.
     * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
     * @property {string[]} [selectorsFloatingMenu]
     *   The CSS selectors of floating menus.
     *   Used for detecting if focus-wrap behavior should be disabled temporarily.
     * @property {string} [classVisible] The CSS class for the visible state.
     * @property {string} [classBody] The CSS class for `<body>` with open modal.
     * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
     * @property {string} [eventBeforeShown]
     *   The name of the custom event fired before this modal is shown.
     *   Cancellation of this event stops showing the modal.
     * @property {string} [eventAfterShown]
     *   The name of the custom event telling that modal is sure shown
     *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
     * @property {string} [eventBeforeHidden]
     *   The name of the custom event fired before this modal is hidden.
     *   Cancellation of this event stops hiding the modal.
     * @property {string} [eventAfterHidden]
     *   The name of the custom event telling that modal is sure hidden
     *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-modal]',
        selectorModalClose: '[data-modal-close]',
        selectorPrimaryFocus: '[data-modal-primary-focus]',
        selectorsFloatingMenus: [".".concat(prefix, "--overflow-menu-options"), ".".concat(prefix, "--tooltip"), '.flatpickr-calendar'],
        selectorModalContainer: ".".concat(prefix, "--modal-container"),
        classVisible: 'is-visible',
        classBody: "".concat(prefix, "--body--with-modal-open"),
        attribInitTarget: 'data-modal-target',
        initEventNames: ['click'],
        eventBeforeShown: 'modal-beingshown',
        eventAfterShown: 'modal-shown',
        eventBeforeHidden: 'modal-beinghidden',
        eventAfterHidden: 'modal-hidden'
      };
    }
  }]);

  Modal.components = new WeakMap();
  return Modal;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_init_component_by_launcher__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_7__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_8__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Modal);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/notification/notification.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/notification/notification.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/evented-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var Notification = /*#__PURE__*/function (_mixin) {
  _inherits(Notification, _mixin);

  var _super = _createSuper(Notification);
  /**
   * InlineNotification.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a InlineNotification.
   */


  function Notification(element, options) {
    var _this;

    _classCallCheck(this, Notification);

    _this = _super.call(this, element, options);

    _this._changeState = function (state, callback) {
      if (state === 'delete-notification') {
        _this.element.parentNode.removeChild(_this.element);

        _this.release();
      }

      callback();
    };

    _this.button = element.querySelector(_this.options.selectorButton);

    if (_this.button) {
      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.button, 'click', function (evt) {
        if (evt.currentTarget === _this.button) {
          _this.remove();
        }
      }));
    }

    return _this;
  }

  _createClass(Notification, [{
    key: "remove",
    value: function remove() {
      this.changeState('delete-notification');
    }
    /**
     * The map associating DOM element and accordion UI instance.
     * @type {WeakMap}
     */

  }]);

  Notification.components = new WeakMap();
  Notification.options = {
    selectorInit: '[data-notification]',
    selectorButton: '[data-notification-btn]',
    eventBeforeDeleteNotification: 'notification-before-delete',
    eventAfterDeleteNotification: 'notification-after-delete'
  };
  return Notification;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_1__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_2__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Notification);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/number-input/number-input.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/number-input/number-input.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var NumberInput = /*#__PURE__*/function (_mixin) {
  _inherits(NumberInput, _mixin);

  var _super = _createSuper(NumberInput);
  /**
   * Number input UI.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a number input UI.
   */


  function NumberInput(element, options) {
    var _this;

    _classCallCheck(this, NumberInput);

    _this = _super.call(this, element, options); // Broken DOM tree is seen with up/down arrows <svg> in IE, which breaks event delegation.
    // <svg> does not have `Element.classList` in IE11

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.querySelector('.up-icon'), 'click', function (event) {
      _this._handleClick(event);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.querySelector('.down-icon'), 'click', function (event) {
      _this._handleClick(event);
    }));

    return _this;
  }
  /**
   * Increase/decrease number by clicking on up/down icons.
   * @param {Event} event The event triggering this method.
   */


  _createClass(NumberInput, [{
    key: "_handleClick",
    value: function _handleClick(event) {
      var numberInput = this.element.querySelector(this.options.selectorInput);
      var target = event.currentTarget.getAttribute('class').split(' ');
      var min = Number(numberInput.min);
      var max = Number(numberInput.max);
      var step = Number(numberInput.step) || 1;

      if (target.indexOf('up-icon') >= 0) {
        var nextValue = Number(numberInput.value) + step;

        if (numberInput.max === '') {
          numberInput.value = nextValue;
        } else if (numberInput.value < max) {
          if (nextValue > max) {
            numberInput.value = max;
          } else if (nextValue < min) {
            numberInput.value = min;
          } else {
            numberInput.value = nextValue;
          }
        }
      } else if (target.indexOf('down-icon') >= 0) {
        var _nextValue = Number(numberInput.value) - step;

        if (numberInput.min === '') {
          numberInput.value = _nextValue;
        } else if (numberInput.value > min) {
          if (_nextValue < min) {
            numberInput.value = min;
          } else if (_nextValue > max) {
            numberInput.value = max;
          } else {
            numberInput.value = _nextValue;
          }
        }
      } // Programmatic change in value (including `stepUp()`/`stepDown()`) won't fire change event


      numberInput.dispatchEvent(new CustomEvent('change', {
        bubbles: true,
        cancelable: false
      }));
    }
    /**
     * The map associating DOM element and number input UI instance.
     * @member NumberInput.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode NumberInput.create .create()}, or {@linkcode NumberInput.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode NumberInput.init .init()} works.
     * @member NumberInput.options
     * @type {object}
     * @property {string} selectorInit The CSS selector to find number input UIs.
     * @property {string} [selectorInput] The CSS selector to find the `<input>` element.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-numberinput]',
        selectorInput: ".".concat(prefix, "--number input")
      };
    }
  }]);

  NumberInput.components = new WeakMap();
  return NumberInput;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NumberInput);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/overflow-menu/overflow-menu.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/overflow-menu/overflow-menu.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getMenuOffset": () => (/* binding */ getMenuOffset)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../globals/js/mixins/evented-show-hide-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-show-hide-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../floating-menu/floating-menu */ "../../node_modules/carbon-components/es/components/floating-menu/floating-menu.js");
/* harmony import */ var _globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/get-launching-details */ "../../node_modules/carbon-components/es/globals/js/misc/get-launching-details.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */












/**
 * The CSS property names of the arrow keyed by the floating menu direction.
 * @type {object<string, string>}
 */

var triggerButtonPositionProps = /* #__PURE__ */function () {
  var _ref;

  return _ref = {}, _defineProperty(_ref, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_TOP, 'bottom'), _defineProperty(_ref, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_BOTTOM, 'top'), _defineProperty(_ref, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_LEFT, 'left'), _defineProperty(_ref, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_RIGHT, 'right'), _ref;
}();
/**
 * Determines how the position of arrow should affect the floating menu position.
 * @type {object<string, number>}
 */


var triggerButtonPositionFactors = /* #__PURE__ */function () {
  var _ref2;

  return _ref2 = {}, _defineProperty(_ref2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_TOP, -2), _defineProperty(_ref2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_BOTTOM, -1), _defineProperty(_ref2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_LEFT, -2), _defineProperty(_ref2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_RIGHT, -1), _ref2;
}();
/**
 * @param {Element} menuBody The menu body with the menu arrow.
 * @param {string} direction The floating menu direction.
 * @param {Element} trigger The trigger button.
 * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
 * @private
 */


var getMenuOffset = function getMenuOffset(menuBody, direction, trigger) {
  var triggerButtonPositionProp = triggerButtonPositionProps[direction];
  var triggerButtonPositionFactor = triggerButtonPositionFactors[direction];

  if (!triggerButtonPositionProp || !triggerButtonPositionFactor) {
    console.warn('Wrong floating menu direction:', direction); // eslint-disable-line no-console
  }

  var menuWidth = menuBody.offsetWidth;
  var menuHeight = menuBody.offsetHeight; // eslint-disable-next-line no-use-before-define

  var menu = OverflowMenu.components.get(trigger);

  if (!menu) {
    throw new TypeError('Overflow menu instance cannot be found.');
  }

  var flip = menuBody.classList.contains(menu.options.classMenuFlip);

  if (triggerButtonPositionProp === 'top' || triggerButtonPositionProp === 'bottom') {
    var triggerWidth = trigger.offsetWidth;
    return {
      left: (!flip ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
      top: 0
    };
  }

  if (triggerButtonPositionProp === 'left' || triggerButtonPositionProp === 'right') {
    var triggerHeight = trigger.offsetHeight;
    return {
      left: 0,
      top: (!flip ? 1 : -1) * (menuHeight / 2 - triggerHeight / 2)
    };
  }

  return undefined;
};

var OverflowMenu = /*#__PURE__*/function (_mixin) {
  _inherits(OverflowMenu, _mixin);

  var _super = _createSuper(OverflowMenu);
  /**
   * Overflow menu.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a modal dialog.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorOptionMenu] The CSS selector to find the menu.
   * @param {string} [options.selectorTrigger] The CSS selector to find the trigger button.
   * @param {string} [options.classShown] The CSS class for the shown state, for the trigger UI.
   * @param {string} [options.classMenuShown] The CSS class for the shown state, for the menu.
   * @param {string} [options.classMenuFlip] The CSS class for the flipped state of the menu.
   * @param {object} [options.objMenuOffset] The offset locating the menu for the non-flipped state.
   * @param {object} [options.objMenuOffsetFlip] The offset locating the menu for the flipped state.
   */


  function OverflowMenu(element, options) {
    var _this;

    _classCallCheck(this, OverflowMenu);

    _this = _super.call(this, element, options);

    _this.getCurrentNavigation = function () {
      var focused = _this.element.ownerDocument.activeElement;
      return focused.nodeType === Node.ELEMENT_NODE && focused.matches(_this.options.selectorItem) ? focused : null;
    };

    _this.navigate = function (direction) {
      var items = _toConsumableArray(_this.element.ownerDocument.querySelectorAll(_this.options.selectorItem));

      var start = _this.getCurrentNavigation() || _this.element.querySelector(_this.options.selectorItemSelected);

      var getNextItem = function getNextItem(old) {
        var handleUnderflow = function handleUnderflow(index, length) {
          return index + (index >= 0 ? 0 : length);
        };

        var handleOverflow = function handleOverflow(index, length) {
          return index - (index < length ? 0 : length);
        }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


        var index = Math.max(items.indexOf(old) + direction, -1);
        return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
      };

      for (var current = getNextItem(start); current && current !== start; current = getNextItem(current)) {
        if (!current.matches(_this.options.selectorItemHidden) && !current.parentNode.matches(_this.options.selectorItemHidden) && !current.matches(_this.options.selectorItemSelected)) {
          current.focus();
          break;
        }
      }
    };

    if (_this.element.getAttribute('role') !== 'button') {
      // Would prefer to use the aria-controls with a specific ID but we
      // don't have the menuOptions list at this point to pull the ID from
      _this.triggerNode = _this.element.querySelector(_this.options.selectorTrigger);
    }

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.ownerDocument, 'click', function (event) {
      _this._handleDocumentClick(event);

      _this.wasOpenBeforeClick = undefined;
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.ownerDocument, 'keydown', function (event) {
      _this._handleKeyPress(event);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'mousedown', function () {
      _this.wasOpenBeforeClick = element.classList.contains(_this.options.classShown);
    }));

    return _this;
  }
  /**
   * Changes the shown/hidden state.
   * @param {string} state The new state.
   * @param {object} detail The detail of the event trigging this action.
   * @param {Function} callback Callback called when change in state completes.
   */


  _createClass(OverflowMenu, [{
    key: "changeState",
    value: function changeState(state, detail, callback) {
      if (!this.optionMenu) {
        var optionMenu = this.element.querySelector(this.options.selectorOptionMenu);

        if (!optionMenu) {
          throw new Error('Cannot find the target menu.');
        } // Lazily create a component instance for menu


        this.optionMenu = _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__["default"].create(optionMenu, {
          refNode: this.element,
          classShown: this.options.classMenuShown,
          classRefShown: this.options.classShown,
          offset: this.options.objMenuOffset,
          triggerNode: this.triggerNode,
          contentNode: this.element.querySelector(this.options.selectorContent)
        });
        this.children.push(this.optionMenu);
      }

      if (this.optionMenu.element.classList.contains(this.options.classMenuFlip)) {
        this.optionMenu.options.offset = this.options.objMenuOffsetFlip;
      } // Delegates the action of changing state to the menu.
      // (And thus the before/after shown/hidden events are fired from the menu)


      this.optionMenu.changeState(state, Object.assign(detail, {
        delegatorNode: this.element
      }), callback);
    }
    /**
     * Handles click on document.
     * @param {Event} event The triggering event.
     * @private
     */

  }, {
    key: "_handleDocumentClick",
    value: function _handleDocumentClick(event) {
      var _this2 = this;

      var element = this.element,
          optionMenu = this.optionMenu,
          wasOpenBeforeClick = this.wasOpenBeforeClick,
          triggerNode = this.triggerNode;
      var isOfSelf = element.contains(event.target);
      var isOfMenu = optionMenu && optionMenu.element.contains(event.target);
      var shouldBeOpen = isOfSelf && !wasOpenBeforeClick;
      var state = shouldBeOpen ? 'shown' : 'hidden';

      if (isOfSelf) {
        if (element.tagName === 'A') {
          event.preventDefault();
        }

        event.delegateTarget = element; // eslint-disable-line no-param-reassign
      }

      if (!isOfMenu || (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_2__["default"])(event, this.options.selectorItem)) {
        this.changeState(state, (0,_globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_3__["default"])(event), function () {
          if (state === 'hidden' && isOfMenu) {
            // @todo Can clean up to use `this.triggerNode` once non-compliant code is deprecated
            _this2[triggerNode ? 'triggerNode' : 'element'].focus();
          }
        });
      }
    }
    /**
     * Provides the element to move focus from
     * @returns {Element} Currently highlighted element.
     */

  }, {
    key: "_handleKeyPress",
    value:
    /**
     * Handles key press on document.
     * @param {Event} event The triggering event.
     * @private
     */
    function _handleKeyPress(event) {
      var _this3 = this;

      var key = event.which;
      var element = this.element,
          optionMenu = this.optionMenu,
          options = this.options,
          triggerNode = this.triggerNode;
      var isOfMenu = optionMenu && optionMenu.element.contains(event.target);
      var isExpanded = this.element.classList.contains(this.options.classShown); // @todo Can clean up to use `this.triggerNode` once non-compliant code is deprecated

      var triggerElement = triggerNode ? 'triggerNode' : 'element';

      switch (key) {
        // Enter || Space bar
        case 13:
        case 32:
          {
            if (!isExpanded && this.element.ownerDocument.activeElement !== this.element) {
              return;
            }

            var isOfSelf = element.contains(event.target);
            var shouldBeOpen = isOfSelf && !element.classList.contains(options.classShown);
            var state = shouldBeOpen ? 'shown' : 'hidden';

            if (isOfSelf) {
              event.delegateTarget = element; // eslint-disable-line no-param-reassign

              event.preventDefault(); // prevent scrolling

              this.changeState(state, (0,_globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_3__["default"])(event), function () {
                if (state === 'hidden' && isOfMenu) {
                  _this3[triggerElement].focus();
                }
              });
            }

            break;
          }

        case 38: // up arrow

        case 40:
          // down arrow
          {
            if (!isExpanded) {
              return;
            }

            event.preventDefault(); // prevent scrolling

            var direction = {
              38: -1,
              40: 1
            }[event.which];
            this.navigate(direction);
          }
          break;

        default:
          break;
      }
    }
  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_4__["default"].prefix;
      return {
        selectorInit: '[data-overflow-menu]',
        selectorOptionMenu: ".".concat(prefix, "--overflow-menu-options"),
        selectorTrigger: 'button[aria-haspopup]',
        selectorContent: ".".concat(prefix, "--overflow-menu-options__content"),
        selectorItem: "\n        .".concat(prefix, "--overflow-menu-options--open\n        .").concat(prefix, "--overflow-menu-options__option:not(.").concat(prefix, "--overflow-menu-options__option--disabled) >\n        .").concat(prefix, "--overflow-menu-options__btn\n      "),
        classShown: "".concat(prefix, "--overflow-menu--open"),
        classMenuShown: "".concat(prefix, "--overflow-menu-options--open"),
        classMenuFlip: "".concat(prefix, "--overflow-menu--flip"),
        objMenuOffset: getMenuOffset,
        objMenuOffsetFlip: getMenuOffset
      };
    }
  }]);

  OverflowMenu.components = new WeakMap();
  return OverflowMenu;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_5__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_7__["default"], _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_8__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_9__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OverflowMenu);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/pagination-nav/pagination-nav.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/pagination-nav/pagination-nav.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var PaginationNav = /*#__PURE__*/function (_mixin) {
  _inherits(PaginationNav, _mixin);

  var _super = _createSuper(PaginationNav);
  /**
   * Pagination Nav component
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a pagination nav.
   */


  function PaginationNav(element, options) {
    var _this;

    _classCallCheck(this, PaginationNav);

    _this = _super.call(this, element, options);

    _this.getActivePageNumber = function () {
      var pageNum;

      var activePageElement = _this.element.querySelector(_this.options.selectorPageActive);

      if (activePageElement) {
        pageNum = Number(activePageElement.getAttribute(_this.options.attribPage));
      }

      return pageNum;
    };

    _this.clearActivePage = function (evt) {
      var pageButtonNodeList = _this.element.querySelectorAll(_this.options.selectorPageButton);

      var pageSelectElement = _this.element.querySelector(_this.options.selectorPageSelect);

      Array.prototype.forEach.call(pageButtonNodeList, function (el) {
        el.classList.remove(_this.options.classActive, _this.options.classDisabled);
        el.removeAttribute(_this.options.attribActive);
        el.removeAttribute('aria-disabled');
        el.removeAttribute('aria-current');
      });

      if (pageSelectElement) {
        pageSelectElement.removeAttribute('aria-current');
        var pageSelectElementOptions = pageSelectElement.options;
        Array.prototype.forEach.call(pageSelectElementOptions, function (el) {
          el.removeAttribute(_this.options.attribActive);
        });

        if (!evt.target.matches(_this.options.selectorPageSelect)) {
          pageSelectElement.classList.remove(_this.options.classActive);
          pageSelectElement.value = '';
        }
      }
    };

    _this.handleClick = function (evt) {
      if (!evt.target.getAttribute('aria-disabled') === true) {
        var nextActivePageNumber = _this.getActivePageNumber();

        var pageElementNodeList = _this.element.querySelectorAll(_this.options.selectorPageElement);

        var pageSelectElement = _this.element.querySelector(_this.options.selectorPageSelect);

        _this.clearActivePage(evt);

        if (evt.target.matches(_this.options.selectorPageButton)) {
          nextActivePageNumber = Number(evt.target.getAttribute(_this.options.attribPage));
        }

        if (evt.target.matches(_this.options.selectorPagePrevious)) {
          nextActivePageNumber -= 1;
        }

        if (evt.target.matches(_this.options.selectorPageNext)) {
          nextActivePageNumber += 1;
        }

        var pageTargetElement = pageElementNodeList[nextActivePageNumber - 1];
        pageTargetElement.setAttribute(_this.options.attribActive, true);

        if (pageTargetElement.tagName === 'OPTION') {
          pageSelectElement.value = _this.getActivePageNumber();
          pageSelectElement.classList.add(_this.options.classActive);
          pageSelectElement.setAttribute('aria-current', 'page');
        } else {
          pageTargetElement.classList.add(_this.options.classActive, _this.options.classDisabled);
          pageTargetElement.setAttribute('aria-disabled', true);
          pageTargetElement.setAttribute('aria-current', 'page');
        }

        _this.setPrevNextStates();
      }
    };

    _this.handleSelectChange = function (evt) {
      _this.clearActivePage(evt);

      var pageSelectElement = _this.element.querySelector(_this.options.selectorPageSelect);

      var pageSelectElementOptions = pageSelectElement.options;
      pageSelectElementOptions[pageSelectElementOptions.selectedIndex].setAttribute(_this.options.attribActive, true);
      evt.target.setAttribute('aria-current', 'page');
      evt.target.classList.add(_this.options.classActive);

      _this.setPrevNextStates();
    };

    _this.setPrevNextStates = function () {
      var pageElementNodeList = _this.element.querySelectorAll(_this.options.selectorPageElement);

      var totalPages = pageElementNodeList.length;

      var pageDirectionElementPrevious = _this.element.querySelector(_this.options.selectorPagePrevious);

      var pageDirectionElementNext = _this.element.querySelector(_this.options.selectorPageNext);

      if (pageDirectionElementPrevious) {
        if (_this.getActivePageNumber() <= 1) {
          pageDirectionElementPrevious.setAttribute('aria-disabled', true);
          pageDirectionElementPrevious.classList.add(_this.options.classDisabled);
        } else {
          pageDirectionElementPrevious.removeAttribute('aria-disabled');
          pageDirectionElementPrevious.classList.remove(_this.options.classDisabled);
        }
      }

      if (pageDirectionElementNext) {
        if (_this.getActivePageNumber() >= totalPages) {
          pageDirectionElementNext.setAttribute('aria-disabled', true);
          pageDirectionElementNext.classList.add(_this.options.classDisabled);
        } else {
          pageDirectionElementNext.removeAttribute('aria-disabled');
          pageDirectionElementNext.classList.remove(_this.options.classDisabled);
        }
      }
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (evt) {
      return _this.handleClick(evt);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'change', function (evt) {
      if (evt.target.matches(_this.options.selectorPageSelect)) {
        _this.handleSelectChange(evt);
      }
    }));

    return _this;
  }
  /**
   * Get active page number
   */


  _createClass(PaginationNav, null, [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode PaginationNav.create .create()},
     * or {@linkcode PaginationNav.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode PaginationNav.init .init()} works.
     * @member PaginationNav.options
     * @type {object}
     * @property {string} selectorInit The data attribute to find pagination nav.
     * @property {string} selectorPageElement The data attribute to find page element.
     * @property {string} selectorPageButton The data attribute to find page interactive element.
     * @property {string} selectorPageDirection The data attribute to find page change element.
     * @property {string} selectorPageSelect The data attribute to find page select element.
     * @property {string} selectorPageActive The data attribute to find active page element.
     * @property {string} [classActive] The CSS class for page's selected state.
     * @property {string} [classDisabled] The CSS class for page's disabled state.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-pagination-nav]',
        selectorPageElement: '[data-page]',
        selectorPageButton: '[data-page-button]',
        selectorPagePrevious: '[data-page-previous]',
        selectorPageNext: '[data-page-next]',
        selectorPageSelect: '[data-page-select]',
        selectorPageActive: '[data-page-active="true"]',
        attribPage: 'data-page',
        attribActive: 'data-page-active',
        classActive: "".concat(prefix, "--pagination-nav__page--active"),
        classDisabled: "".concat(prefix, "--pagination-nav__page--disabled")
      };
    }
  }]);

  PaginationNav.components = new WeakMap();
  return PaginationNav;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PaginationNav);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/pagination/pagination.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/pagination/pagination.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var Pagination = /*#__PURE__*/function (_mixin) {
  _inherits(Pagination, _mixin);

  var _super = _createSuper(Pagination);
  /**
   * Pagination component.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a pagination component.
   * @param {object} [options] The component options.
   * @property {string} [selectorInit] The CSS selector to find pagination components.
   * @property {string} [selectorItemsPerPageInput]
   *   The CSS selector to find the input that determines the number of items per page.
   * @property {string} [selectorPageNumberInput] The CSS selector to find the input that changes the page displayed.
   * @property {string} [selectorPageBackward] The CSS selector to find the button that goes back a page.
   * @property {string} [selectorPageForward] The CSS selector to find the button that goes forward a page.
   * @property {string} [eventItemsPerPage]
   *   The name of the custom event fired when a user changes the number of items per page.
   *   event.detail.value contains the number of items a user wishes to see.
   * @property {string} [eventPageNumber]
   *   The name of the custom event fired when a user inputs a specific page number.
   *   event.detail.value contains the value that the user input.
   * @property {string} [eventPageChange]
   *   The name of the custom event fired when a user goes forward or backward a page.
   *   event.detail.direction contains the direction a user wishes to go.
   */


  function Pagination(element, options) {
    var _this;

    _classCallCheck(this, Pagination);

    _this = _super.call(this, element, options);

    _this._emitEvent = function (evtName, detail) {
      var event = new CustomEvent("".concat(evtName), {
        bubbles: true,
        cancelable: true,
        detail: detail
      });

      _this.element.dispatchEvent(event);
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (evt) {
      if ((0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorPageBackward)) {
        var detail = {
          initialEvt: evt,
          element: evt.target,
          direction: 'backward'
        };

        _this._emitEvent(_this.options.eventPageChange, detail);
      } else if ((0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorPageForward)) {
        var _detail = {
          initialEvt: evt,
          element: evt.target,
          direction: 'forward'
        };

        _this._emitEvent(_this.options.eventPageChange, _detail);
      }
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'input', function (evt) {
      if ((0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorItemsPerPageInput)) {
        var detail = {
          initialEvt: evt,
          element: evt.target,
          value: evt.target.value
        };

        _this._emitEvent(_this.options.eventItemsPerPage, detail);
      } else if ((0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorPageNumberInput)) {
        var _detail2 = {
          initialEvt: evt,
          element: evt.target,
          value: evt.target.value
        };

        _this._emitEvent(_this.options.eventPageNumber, _detail2);
      }
    }));

    return _this;
  }
  /**
   * Dispatches a custom event
   * @param {string} evtName name of the event to be dispatched.
   * @param {object} detail contains the original event and any other necessary details.
   */


  Pagination.components = new WeakMap();
  Pagination.options = {
    selectorInit: '[data-pagination]',
    selectorItemsPerPageInput: '[data-items-per-page]',
    selectorPageNumberInput: '[data-page-number-input]',
    selectorPageBackward: '[data-page-backward]',
    selectorPageForward: '[data-page-forward]',
    eventItemsPerPage: 'itemsPerPage',
    eventPageNumber: 'pageNumber',
    eventPageChange: 'pageChange'
  };
  return Pagination;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pagination);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/progress-indicator/progress-indicator.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/progress-indicator/progress-indicator.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */







var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var ProgressIndicator = /*#__PURE__*/function (_mixin) {
  _inherits(ProgressIndicator, _mixin);

  var _super = _createSuper(ProgressIndicator);
  /**
   * ProgressIndicator.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element representing the ProgressIndicator.
   * @param {object} [options] The component options.
   * @property {string} [options.selectorStepElement] The CSS selector to find step elements.
   * @property {string} [options.selectorCurrent] The CSS selector to find the current step element.
   * @property {string} [options.selectorIncomplete] The CSS class to find incomplete step elements.
   * @property {string} [options.selectorComplete] The CSS selector to find completed step elements.
   * @property {string} [options.classStep] The className for a step element.
   * @property {string} [options.classComplete] The className for a completed step element.
   * @property {string} [options.classCurrent] The className for the current step element.
   * @property {string} [options.classIncomplete] The className for a incomplete step element.
   */


  function ProgressIndicator(element, options) {
    var _this;

    _classCallCheck(this, ProgressIndicator);

    _this = _super.call(this, element, options);
    /**
     * The component state.
     * @type {object}
     */

    _this.state = {
      /**
       * The current step index.
       * @type {number}
       */
      currentIndex: _this.getCurrent().index,

      /**
       * Total number of steps.
       * @type {number}
       */
      totalSteps: _this.getSteps().length
    };

    _this.addOverflowTooltip();

    return _this;
  }
  /**
   * Returns all steps with details about element and index.
   */


  _createClass(ProgressIndicator, [{
    key: "getSteps",
    value: function getSteps() {
      return toArray(this.element.querySelectorAll(this.options.selectorStepElement)).map(function (element, index) {
        return {
          element: element,
          index: index
        };
      });
    }
    /**
     * Returns current step; gives detail about element and index.
     */

  }, {
    key: "getCurrent",
    value: function getCurrent() {
      var currentEl = this.element.querySelector(this.options.selectorCurrent);
      return this.getSteps().filter(function (step) {
        return step.element === currentEl;
      })[0];
    }
    /**
     * Sets the current step.
     * * @param {Number} new step index or use default in `this.state.currentIndex`.
     */

  }, {
    key: "setCurrent",
    value: function setCurrent() {
      var _this2 = this;

      var newCurrentStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentIndex;
      var changed = false;

      if (newCurrentStep !== this.state.currentIndex) {
        this.state.currentIndex = newCurrentStep;
        changed = true;
      }

      if (changed) {
        this.getSteps().forEach(function (step) {
          if (step.index < newCurrentStep) {
            _this2._updateStep({
              element: step.element,
              className: _this2.options.classComplete,
              html: _this2._getSVGComplete()
            });
          }

          if (step.index === newCurrentStep) {
            _this2._updateStep({
              element: step.element,
              className: _this2.options.classCurrent,
              html: _this2._getCurrentSVG()
            });
          }

          if (step.index > newCurrentStep) {
            _this2._updateStep({
              element: step.element,
              className: _this2.options.classIncomplete,
              html: _this2._getIncompleteSVG()
            });
          }
        });
      }
    }
    /**
     * Update step with correct inline SVG and className
     * @param {object} args
     * @param {object} [args.element] target element
     * @param {object} [args.className] new className
     * @param {object} [args.html] new inline SVG to insert
     */

  }, {
    key: "_updateStep",
    value: function _updateStep(args) {
      var element = args.element,
          className = args.className,
          html = args.html;

      if (element.firstElementChild) {
        element.removeChild(element.firstElementChild);
      }

      if (!element.classList.contains(className)) {
        element.setAttribute('class', this.options.classStep);
        element.classList.add(className);
      }

      element.insertAdjacentHTML('afterbegin', html);
    }
    /**
     * Returns HTML string for an SVG used to represent a compelted step (checkmark)
     */

  }, {
    key: "_getSVGComplete",
    value: function _getSVGComplete() {
      return "<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n        <circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n        <polygon points=\"10.3 13.6 7.7 11 6.3 12.4 10.3 16.4 17.8 9 16.4 7.6\"></polygon>\n      </svg>";
    }
    /**
     * Returns HTML string for an SVG used to represent current step (circles, like a radio button, but not.)
     */

  }, {
    key: "_getCurrentSVG",
    value: function _getCurrentSVG() {
      return "<svg>\n        <circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n        <circle cx=\"12\" cy=\"12\" r=\"6\"></circle>\n      </svg>";
    }
    /**
     * Returns HTML string for an SVG used to represent incomple step (grey empty circle)
     */

  }, {
    key: "_getIncompleteSVG",
    value: function _getIncompleteSVG() {
      return "<svg>\n        <circle cx=\"12\" cy=\"12\" r=\"12\"></circle>\n      </svg>";
    }
  }, {
    key: "addOverflowTooltip",
    value: function addOverflowTooltip() {
      var _this3 = this;

      var stepLabels = toArray(this.element.querySelectorAll(this.options.selectorLabel));
      var tooltips = toArray(this.element.querySelectorAll(this.options.selectorTooltip));
      stepLabels.forEach(function (step) {
        if (step.scrollWidth > _this3.options.maxWidth) {
          step.classList.add(_this3.options.classOverflowLabel);
        }
      });
      tooltips.forEach(function (tooltip) {
        var childText = tooltip.querySelector(_this3.options.selectorTooltipText);

        if (childText.scrollHeight > _this3.options.tooltipMaxHeight) {
          tooltip.classList.add(_this3.options.classTooltipMulti);
        }
      });
    }
  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode ProgressIndicator.create .create()}, or {@linkcode ProgressIndicator.init .init()},
     * properties in this object are overriden for the instance being created.
     * @member ProgressIndicator.options
     * @type {object}
     * @property {string} selectorInit The CSS selector to find content switcher button set.
     * @property {string} [selectorStepElement] The CSS selector to find step elements.
     * @property {string} [selectorCurrent] The CSS selector to find the current step element.
     * @property {string} [selectorIncomplete] The CSS class to find incomplete step elements.
     * @property {string} [selectorComplete] The CSS selector to find completed step elements.
     * @property {string} [classStep] The className for a step element.
     * @property {string} [classComplete] The className for a completed step element.
     * @property {string} [classCurrent] The className for the current step element.
     * @property {string} [classIncomplete] The className for a incomplete step element.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_0__["default"].prefix;
      return {
        selectorInit: '[data-progress]',
        selectorStepElement: ".".concat(prefix, "--progress-step"),
        selectorCurrent: ".".concat(prefix, "--progress-step--current"),
        selectorIncomplete: ".".concat(prefix, "--progress-step--incomplete"),
        selectorComplete: ".".concat(prefix, "--progress-step--complete"),
        selectorLabel: ".".concat(prefix, "--progress-label"),
        selectorTooltip: ".".concat(prefix, "--tooltip"),
        selectorTooltipText: ".".concat(prefix, "--tooltip__text"),
        classStep: "".concat(prefix, "--progress-step"),
        classComplete: "".concat(prefix, "--progress-step--complete"),
        classCurrent: "".concat(prefix, "--progress-step--current"),
        classIncomplete: "".concat(prefix, "--progress-step--incomplete"),
        classOverflowLabel: "".concat(prefix, "--progress-label-overflow"),
        classTooltipMulti: "".concat(prefix, "--tooltip_multi"),
        maxWidth: 87,
        tooltipMaxHeight: 21
      };
    }
  }]);

  ProgressIndicator.components = new WeakMap();
  return ProgressIndicator;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_1__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_2__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProgressIndicator);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/search/search.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/search/search.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
/* harmony import */ var _globals_js_misc_svg_toggle_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/svg-toggle-class */ "../../node_modules/carbon-components/es/globals/js/misc/svg-toggle-class.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */











var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var Search = /*#__PURE__*/function (_mixin) {
  _inherits(Search, _mixin);

  var _super = _createSuper(Search);
  /**
   * Search with Options.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as the search component.
   * @param {object} [options] The component options
   * @property {string} [options.selectorInit]
   *   The selector to find search UIs with options.
   * @property {string} [options.selectorSearchView]
   *   The selector to find the search view icon containers.
   * @property {string} [options.selectorSearchInput]
   *   The selector to find the search input.
   * @property {string} [options.selectorClearIcon]
   *   The selector for the clear icon that clears the search box.
   * @property {string} [options.selectorIconContainer] The data attribute selector for the icon layout container.
   * @property {string} [options.classClearHidden] The class used to hide the clear icon.
   * @property {string} [options.classLayoutHidden] The class used to hide nonselected layout view.
   */


  function Search(element, options) {
    var _this;

    _classCallCheck(this, Search);

    _this = _super.call(this, element, options);

    var closeIcon = _this.element.querySelector(_this.options.selectorClearIcon);

    var input = _this.element.querySelector(_this.options.selectorSearchInput);

    if (!input) {
      throw new Error('Cannot find the search input.');
    }

    if (closeIcon) {
      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(closeIcon, 'click', function () {
        (0,_globals_js_misc_svg_toggle_class__WEBPACK_IMPORTED_MODULE_1__["default"])(closeIcon, _this.options.classClearHidden, true);
        input.value = '';
        input.focus();
      }));
    }

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (evt) {
      var toggleItem = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_2__["default"])(evt, _this.options.selectorIconContainer);
      if (toggleItem) _this.toggleLayout(toggleItem);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(input, 'input', function (evt) {
      if (closeIcon) _this.showClear(evt.target.value, closeIcon);
    }));

    return _this;
  }
  /**
   * Toggles between the grid and list layout.
   * @param {HTMLElement} element The element contining the layout toggle.
   */


  _createClass(Search, [{
    key: "toggleLayout",
    value: function toggleLayout(element) {
      var _this2 = this;

      toArray(element.querySelectorAll(this.options.selectorSearchView)).forEach(function (item) {
        item.classList.toggle(_this2.options.classLayoutHidden);
      });
    }
    /**
     * Toggles the clear icon visibility
     * @param {HTMLElement} value The element serving as the search input.
     * @param {HTMLElement} icon The element serving as close icon.
     */

  }, {
    key: "showClear",
    value: function showClear(value, icon) {
      (0,_globals_js_misc_svg_toggle_class__WEBPACK_IMPORTED_MODULE_1__["default"])(icon, this.options.classClearHidden, value.length === 0);
    }
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode Search.create .create()}, or {@linkcode Search.init .init()},
     * properties in this object are overriden for the instance being created
     * and how {@linkcode Search.init .init()} works.
     * @member Search.options
     * @type {object}
     * @property {string} [options.selectorInit]
     *   The selector to find search UIs with options.
     * @property {string} [options.selectorSearchView]
     *   The selector to find the search view icon containers.
     * @property {string} [options.selectorSearchInput]
     *   The selector to find the search input.
     * @property {string} [options.selectorClearIcon]
     *   The selector for the clear icon that clears the search box.
     * @property {string} [options.selectorIconContainer] The data attribute selector for the icon layout container.
     * @property {string} [options.classClearHidden] The class used to hide the clear icon.
     * @property {string} [options.classLayoutHidden] The class used to hide nonselected layout view.
     */

  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_3__["default"].prefix;
      return {
        selectorInit: '[data-search]',
        selectorSearchView: '[data-search-view]',
        selectorSearchInput: ".".concat(prefix, "--search-input"),
        selectorClearIcon: ".".concat(prefix, "--search-close"),
        selectorIconContainer: ".".concat(prefix, "--search-button[data-search-toggle]"),
        classClearHidden: "".concat(prefix, "--search-close--hidden"),
        classLayoutHidden: "".concat(prefix, "--search-view--hidden")
      };
    }
    /**
     * The map associating DOM element and search instance.
     * @member Search.components
     * @type {WeakMap}
     */

  }]);

  Search.components = new WeakMap();
  return Search;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Search);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/slider/slider.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/slider/slider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/evented-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */










var Slider = /*#__PURE__*/function (_mixin) {
  _inherits(Slider, _mixin);

  var _super = _createSuper(Slider);
  /**
   * Slider.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as an slider.
   */


  function Slider(element, options) {
    var _this;

    _classCallCheck(this, Slider);

    _this = _super.call(this, element, options);

    _this._changeState = function (state, detail, callback) {
      callback();
    };

    _this.sliderActive = false;
    _this.dragging = false;
    _this.track = _this.element.querySelector(_this.options.selectorTrack);
    _this.filledTrack = _this.element.querySelector(_this.options.selectorFilledTrack);
    _this.thumb = _this.element.querySelector(_this.options.selectorThumb);
    _this.input = _this.element.querySelector(_this.options.selectorInput);

    if (_this.element.dataset.sliderInputBox) {
      _this.boundInput = _this.element.ownerDocument.querySelector(_this.element.dataset.sliderInputBox);

      _this._updateInput();

      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.boundInput, 'change', function (evt) {
        _this.setValue(evt.target.value);
      }));

      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.boundInput, 'focus', function (evt) {
        evt.target.select();
      })); // workaround for safari


      _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.boundInput, 'mouseup', function (evt) {
        evt.preventDefault();
      }));
    }

    _this._updatePosition();

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.thumb, 'mousedown', function () {
      _this.sliderActive = true;
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, 'mouseup', function () {
      _this.sliderActive = false;
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, 'mousemove', function (evt) {
      var disabled = _this.element.classList.contains(_this.options.classDisabled);

      if (_this.sliderActive === true && !disabled) {
        _this._updatePosition(evt);
      }
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.thumb, 'keydown', function (evt) {
      var disabled = _this.element.classList.contains(_this.options.classDisabled);

      if (!disabled) {
        _this._updatePosition(evt);
      }
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.track, 'click', function (evt) {
      var disabled = _this.element.classList.contains(_this.options.classDisabled);

      if (!disabled) {
        _this._updatePosition(evt);
      }
    }));

    return _this;
  }

  _createClass(Slider, [{
    key: "_updatePosition",
    value: function _updatePosition(evt) {
      var _this2 = this;

      var _this$_calcValue = this._calcValue(evt),
          left = _this$_calcValue.left,
          newValue = _this$_calcValue.newValue;

      if (this.dragging) {
        return;
      }

      this.dragging = true;
      requestAnimationFrame(function () {
        _this2.dragging = false;
        _this2.thumb.style.left = "".concat(left, "%");
        _this2.filledTrack.style.transform = "translate(0%, -50%) scaleX(".concat(left / 100, ")");
        _this2.input.value = newValue;

        _this2._updateInput();

        _this2.changeState('slider-value-change', {
          value: newValue
        });
      });
    }
  }, {
    key: "_calcValue",
    value: function _calcValue(evt) {
      var _this$getInputProps = this.getInputProps(),
          value = _this$getInputProps.value,
          min = _this$getInputProps.min,
          max = _this$getInputProps.max,
          step = _this$getInputProps.step;

      var range = max - min;
      var valuePercentage = (value - min) / range * 100;
      var left;
      var newValue;
      left = valuePercentage;
      newValue = value;

      if (evt) {
        var type = evt.type;

        if (type === 'keydown') {
          var direction = {
            40: -1,
            // decreasing
            37: -1,
            // decreasing
            38: 1,
            // increasing
            39: 1 // increasing

          }[evt.which];

          if (direction !== undefined) {
            var multiplier = evt.shiftKey === true ? range / step / this.options.stepMultiplier : 1;
            var stepMultiplied = step * multiplier;
            var stepSize = stepMultiplied / range * 100;
            left = valuePercentage + stepSize * direction;
            newValue = Number(value) + stepMultiplied * direction;
          }
        }

        if (type === 'mousemove' || type === 'click') {
          if (type === 'click') {
            this.element.querySelector(this.options.selectorThumb).classList.add(this.options.classThumbClicked);
          } else {
            this.element.querySelector(this.options.selectorThumb).classList.remove(this.options.classThumbClicked);
          }

          var track = this.track.getBoundingClientRect();
          var unrounded = (evt.clientX - track.left) / track.width;
          var rounded = Math.round(range * unrounded / step) * step;
          left = rounded / range * 100;
          newValue = rounded + min;
        }
      }

      if (newValue <= Number(min)) {
        left = 0;
        newValue = min;
      }

      if (newValue >= Number(max)) {
        left = 100;
        newValue = max;
      }

      return {
        left: left,
        newValue: newValue
      };
    }
  }, {
    key: "_updateInput",
    value: function _updateInput() {
      if (this.boundInput) {
        this.boundInput.value = this.input.value;
      }
    }
  }, {
    key: "getInputProps",
    value: function getInputProps() {
      var values = {
        value: Number(this.input.value),
        min: Number(this.input.min),
        max: Number(this.input.max),
        step: this.input.step ? Number(this.input.step) : 1
      };
      return values;
    }
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.input.value = value;

      this._updatePosition();
    }
  }, {
    key: "stepUp",
    value: function stepUp() {
      this.input.stepUp();

      this._updatePosition();
    }
  }, {
    key: "stepDown",
    value: function stepDown() {
      this.input.stepDown();

      this._updatePosition();
    }
    /**
     * The map associating DOM element and Slider UI instance.
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * properties in this object are overriden for the instance being created.
     * @property {string} selectorInit The CSS selector to find slider instances.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-slider]',
        selectorTrack: ".".concat(prefix, "--slider__track"),
        selectorFilledTrack: ".".concat(prefix, "--slider__filled-track"),
        selectorThumb: ".".concat(prefix, "--slider__thumb"),
        selectorInput: ".".concat(prefix, "--slider__input"),
        classDisabled: "".concat(prefix, "--slider--disabled"),
        classThumbClicked: "".concat(prefix, "--slider__thumb--clicked"),
        eventBeforeSliderValueChange: 'slider-before-value-change',
        eventAfterSliderValueChange: 'slider-after-value-change',
        stepMultiplier: 4
      };
    }
  }]);

  Slider.components = new WeakMap();
  return Slider;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Slider);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/structured-list/structured-list.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/structured-list/structured-list.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */










var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var StructuredList = /*#__PURE__*/function (_mixin) {
  _inherits(StructuredList, _mixin);

  var _super = _createSuper(StructuredList);
  /**
   * StructuredList
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The root element of tables
   * @param {object} [options] the... options
   * @param {string} [options.selectorInit] selector initialization
   * @param {string} [options.selectorRow] css selector for selected row
   */


  function StructuredList(element, options) {
    var _this;

    _classCallCheck(this, StructuredList);

    _this = _super.call(this, element, options);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'keydown', function (evt) {
      if (evt.which === 37 || evt.which === 38 || evt.which === 39 || evt.which === 40) {
        _this._handleKeydownArrow(evt);
      }

      if (evt.which === 13 || evt.which === 32) {
        _this._handleKeydownChecked(evt);
      }
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (evt) {
      _this._handleClick(evt);
    }));

    return _this;
  }

  _createClass(StructuredList, [{
    key: "_direction",
    value: function _direction(evt) {
      return {
        37: -1,
        // backward
        38: -1,
        // backward
        39: 1,
        // forward
        40: 1 // forward

      }[evt.which];
    }
  }, {
    key: "_nextIndex",
    value: function _nextIndex(array, arrayItem, direction) {
      return array.indexOf(arrayItem) + direction; // returns -1, 0, 1, 2, 3, 4...
    }
  }, {
    key: "_getInput",
    value: function _getInput(index) {
      var rows = toArray(this.element.querySelectorAll(this.options.selectorRow));
      return this.element.ownerDocument.querySelector(this.options.selectorListInput(rows[index].getAttribute('for')));
    }
  }, {
    key: "_handleInputChecked",
    value: function _handleInputChecked(index) {
      var rows = this.element.querySelectorAll(this.options.selectorRow);
      var input = this.getInput(index) || rows[index].querySelector('input');
      input.checked = true;
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(evt) {
      var _this2 = this;

      var selectedRow = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, this.options.selectorRow);
      toArray(this.element.querySelectorAll(this.options.selectorRow)).forEach(function (row) {
        return row.classList.remove(_this2.options.classActive);
      });

      if (selectedRow) {
        selectedRow.classList.add(this.options.classActive);
      }
    } // Handle Enter or Space keydown events for selecting <label> rows

  }, {
    key: "_handleKeydownChecked",
    value: function _handleKeydownChecked(evt) {
      var _this3 = this;

      evt.preventDefault(); // prevent spacebar from scrolling page

      var selectedRow = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, this.options.selectorRow);
      toArray(this.element.querySelectorAll(this.options.selectorRow)).forEach(function (row) {
        return row.classList.remove(_this3.options.classActive);
      });

      if (selectedRow) {
        selectedRow.classList.add(this.options.classActive);
        var input = selectedRow.querySelector(this.options.selectorListInput(selectedRow.getAttribute('for'))) || selectedRow.querySelector('input');
        input.checked = true;
      }
    } // Handle up and down keydown events for selecting <label> rows

  }, {
    key: "_handleKeydownArrow",
    value: function _handleKeydownArrow(evt) {
      var _this4 = this;

      evt.preventDefault(); // prevent arrow keys from scrolling

      var selectedRow = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, this.options.selectorRow);

      var direction = this._direction(evt);

      if (direction && selectedRow !== undefined) {
        var rows = toArray(this.element.querySelectorAll(this.options.selectorRow));
        rows.forEach(function (row) {
          return row.classList.remove(_this4.options.classActive);
        });
        var firstIndex = 0;

        var nextIndex = this._nextIndex(rows, selectedRow, direction);

        var lastIndex = rows.length - 1;

        var getSelectedIndex = function getSelectedIndex() {
          switch (nextIndex) {
            case -1:
              return lastIndex;

            case rows.length:
              return firstIndex;

            default:
              return nextIndex;
          }
        };

        var selectedIndex = getSelectedIndex();
        rows[selectedIndex].classList.add(this.options.classActive);
        rows[selectedIndex].focus();

        this._handleInputChecked(selectedIndex);
      }
    }
  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-structured-list]',
        selectorRow: "[data-structured-list] .".concat(prefix, "--structured-list-tbody > label.").concat(prefix, "--structured-list-row"),
        selectorListInput: function selectorListInput(id) {
          return "#".concat(id, ".").concat(prefix, "--structured-list-input");
        },
        classActive: "".concat(prefix, "--structured-list-row--selected")
      };
    }
  }]);

  StructuredList.components = new WeakMap();
  return StructuredList;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StructuredList);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/tabs/tabs.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/tabs/tabs.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _content_switcher_content_switcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../content-switcher/content-switcher */ "../../node_modules/carbon-components/es/components/content-switcher/content-switcher.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */







var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var Tab = /*#__PURE__*/function (_ContentSwitcher) {
  _inherits(Tab, _ContentSwitcher);

  var _super = _createSuper(Tab);
  /**
   * Container of tabs.
   * @extends ContentSwitcher
   * @param {HTMLElement} element The element working as a container of tabs.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorMenu] The CSS selector to find the drop down menu used in narrow mode.
   * @param {string} [options.selectorTrigger] The CSS selector to find the button to open the drop down menu used in narrow mode.
   * @param {string} [options.selectorTriggerText]
   *   The CSS selector to find the element used in narrow mode showing the selected tab item.
   * @param {string} [options.selectorButton] The CSS selector to find tab containers.
   * @param {string} [options.selectorButtonSelected] The CSS selector to find the selected tab.
   * @param {string} [options.selectorLink] The CSS selector to find the links in tabs.
   * @param {string} [options.classActive] The CSS class for tab's selected state.
   * @param {string} [options.classHidden] The CSS class for the drop down menu's hidden state used in narrow mode.
   * @param {string} [options.eventBeforeSelected]
   *   The name of the custom event fired before a tab is selected.
   *   Cancellation of this event stops selection of tab.
   * @param {string} [options.eventAfterSelected] The name of the custom event fired after a tab is selected.
   */


  function Tab(element, options) {
    var _this;

    _classCallCheck(this, Tab);

    _this = _super.call(this, element, options);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'keydown', function (event) {
      _this._handleKeyDown(event);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, 'click', function (event) {
      _this._handleDocumentClick(event);
    }));

    var selected = _this.element.querySelector(_this.options.selectorButtonSelected);

    if (selected) {
      _this._updateTriggerText(selected);
    }

    return _this;
  }
  /**
   * Internal method of {@linkcode Tab#setActive .setActive()}, to select a tab item.
   * @private
   * @param {object} detail The detail of the event trigging this action.
   * @param {HTMLElement} detail.item The tab item to be selected.
   * @param {Function} callback Callback called when change in state completes.
   */


  _createClass(Tab, [{
    key: "_changeState",
    value: function _changeState(detail, callback) {
      var _this2 = this;

      _get(_getPrototypeOf(Tab.prototype), "_changeState", this).call(this, detail, function (error) {
        if (!error) {
          _this2._updateTriggerText(detail.item);
        }

        for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          data[_key - 1] = arguments[_key];
        }

        callback.apply(void 0, [error].concat(data));
      });
    }
    /**
     * Handles click on tab container.
     * * If the click is on a tab, activates it.
     * * If the click is on the button to open the drop down menu, does so.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      var button = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, this.options.selectorButton);
      var trigger = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, this.options.selectorTrigger);

      if (button && !button.classList.contains(this.options.classButtonDisabled)) {
        _get(_getPrototypeOf(Tab.prototype), "_handleClick", this).call(this, event);

        this._updateMenuState(false);
      }

      if (trigger) {
        this._updateMenuState();
      }
    }
    /**
     * Handles click on document.
     * @param {Event} event The triggering event.
     * @private
     */

  }, {
    key: "_handleDocumentClick",
    value: function _handleDocumentClick(event) {
      var element = this.element;
      var isOfSelf = element.contains(event.target);

      if (isOfSelf) {
        return;
      }

      this._updateMenuState(false);
    }
    /**
     * Handles arrow keys on tab container.
     * * Left keys are used to go to previous tab.
     * * Right keys are used to go to next tab.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: "_handleKeyDown",
    value: function _handleKeyDown(event) {
      var _this3 = this;

      var triggerNode = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, this.options.selectorTrigger);

      if (triggerNode) {
        if (event.which === 13) {
          this._updateMenuState();
        }

        return;
      }

      var direction = {
        37: this.constructor.NAVIGATE.BACKWARD,
        39: this.constructor.NAVIGATE.FORWARD
      }[event.which];

      if (direction) {
        var buttons = toArray(this.element.querySelectorAll(this.options.selectorButtonEnabled));
        var button = this.element.querySelector(this.options.selectorButtonSelected);
        var nextIndex = Math.max(buttons.indexOf(button) + direction, -1
        /* For `button` not found in `buttons` */
        );
        var nextIndexLooped = nextIndex >= 0 && nextIndex < buttons.length ? nextIndex : nextIndex - Math.sign(nextIndex) * buttons.length;
        this.setActive(buttons[nextIndexLooped], function (error, item) {
          if (item) {
            var link = item.querySelector(_this3.options.selectorLink);

            if (link) {
              link.focus();
            }
          }
        });
        event.preventDefault();
      }
    }
    /**
     * Shows/hides the drop down menu used in narrow mode.
     * @param {boolean} [force] `true` to show the menu, `false` to hide the menu, otherwise toggles the menu.
     */

  }, {
    key: "_updateMenuState",
    value: function _updateMenuState(force) {
      var menu = this.element.querySelector(this.options.selectorMenu);
      var trigger = this.element.querySelector(this.options.selectorTrigger);

      if (menu) {
        menu.classList.toggle(this.options.classHidden, typeof force === 'undefined' ? force : !force);

        if (menu.classList.contains(this.options.classHidden)) {
          trigger.classList.remove(this.options.classOpen);
        } else {
          trigger.classList.add(this.options.classOpen);
        }
      }
    }
    /**
     * Updates the text indicating the currently selected tab item.
     * @param {HTMLElement} target The newly selected tab item.
     */

  }, {
    key: "_updateTriggerText",
    value: function _updateTriggerText(target) {
      var triggerText = this.element.querySelector(this.options.selectorTriggerText);

      if (triggerText) {
        triggerText.textContent = target.textContent;
      }
    }
    /**
     * The map associating DOM element and tab container instance.
     * @member Tab.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode ContentSwitcher.create .create()}, or {@linkcode Tab.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Tab.init .init()} works.
     * @member Tab.options
     * @type {object}
     * @property {string} selectorInit The CSS selector to find tab containers.
     * @property {string} [selectorMenu] The CSS selector to find the drop down menu used in narrow mode.
     * @property {string} [selectorTrigger] The CSS selector to find the button to open the drop down menu used in narrow mode.
     * @property {string} [selectorTriggerText]
     *   The CSS selector to find the element used in narrow mode showing the selected tab item.
     * @property {string} [selectorButton] The CSS selector to find tab containers.
     * @property {string} [selectorButtonSelected] The CSS selector to find the selected tab.
     * @property {string} [selectorLink] The CSS selector to find the links in tabs.
     * @property {string} [classActive] The CSS class for tab's selected state.
     * @property {string} [classHidden] The CSS class for the drop down menu's hidden state used in narrow mode.
     * @property {string} [eventBeforeSelected]
     *   The name of the custom event fired before a tab is selected.
     *   Cancellation of this event stops selection of tab.
     * @property {string} [eventAfterSelected] The name of the custom event fired after a tab is selected.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return Object.assign(Object.create(_content_switcher_content_switcher__WEBPACK_IMPORTED_MODULE_3__["default"].options), {
        selectorInit: '[data-tabs]',
        selectorMenu: ".".concat(prefix, "--tabs__nav"),
        selectorTrigger: ".".concat(prefix, "--tabs-trigger"),
        selectorTriggerText: ".".concat(prefix, "--tabs-trigger-text"),
        selectorButton: ".".concat(prefix, "--tabs__nav-item"),
        selectorButtonEnabled: ".".concat(prefix, "--tabs__nav-item:not(.").concat(prefix, "--tabs__nav-item--disabled)"),
        selectorButtonSelected: ".".concat(prefix, "--tabs__nav-item--selected"),
        selectorLink: ".".concat(prefix, "--tabs__nav-link"),
        classActive: "".concat(prefix, "--tabs__nav-item--selected"),
        classHidden: "".concat(prefix, "--tabs__nav--hidden"),
        classOpen: "".concat(prefix, "--tabs-trigger--open"),
        classButtonDisabled: "".concat(prefix, "--tabs__nav-item--disabled"),
        eventBeforeSelected: 'tab-beingselected',
        eventAfterSelected: 'tab-selected'
      });
    }
    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member Tab.NAVIGATE
     * @type {object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  Tab.components = new WeakMap();
  Tab.NAVIGATE = {
    BACKWARD: -1,
    FORWARD: 1
  };
  return Tab;
}(_content_switcher_content_switcher__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tab);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/text-input/text-input.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/text-input/text-input.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextInput)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */










var TextInput = /*#__PURE__*/function (_mixin) {
  _inherits(TextInput, _mixin);

  var _super = _createSuper(TextInput);
  /**
   * Text Input.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element - The element functioning as a text field.
   */


  function TextInput(_element, options) {
    var _this;

    _classCallCheck(this, TextInput);

    _this = _super.call(this, _element, options);

    _this._setIconVisibility = function (_ref) {
      var iconVisibilityOn = _ref.iconVisibilityOn,
          iconVisibilityOff = _ref.iconVisibilityOff,
          passwordIsVisible = _ref.passwordIsVisible,
          selectorPasswordVisibilityTooltip = _ref.selectorPasswordVisibilityTooltip;

      if (passwordIsVisible) {
        iconVisibilityOn.setAttribute('hidden', true);
        iconVisibilityOff.removeAttribute('hidden');
        selectorPasswordVisibilityTooltip.textContent = 'Hide password';
        return;
      }

      iconVisibilityOn.removeAttribute('hidden');
      iconVisibilityOff.setAttribute('hidden', true);
      selectorPasswordVisibilityTooltip.textContent = 'Show password';
    };

    _this._toggle = function (_ref2) {
      var element = _ref2.element,
          button = _ref2.button; // toggle action must come before querying the classList

      element.classList.toggle(_this.options.passwordIsVisible);
      var passwordIsVisible = element.classList.contains(_this.options.passwordIsVisible);
      var iconVisibilityOn = button.querySelector(_this.options.svgIconVisibilityOn);
      var iconVisibilityOff = button.querySelector(_this.options.svgIconVisibilityOff);
      var input = element.querySelector(_this.options.selectorPasswordField);
      var selectorPasswordVisibilityTooltip = element.querySelector(_this.options.selectorPasswordVisibilityTooltip);

      _this._setIconVisibility({
        iconVisibilityOn: iconVisibilityOn,
        iconVisibilityOff: iconVisibilityOff,
        passwordIsVisible: passwordIsVisible,
        selectorPasswordVisibilityTooltip: selectorPasswordVisibilityTooltip
      });

      input.type = passwordIsVisible ? 'text' : 'password';
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'click', function (event) {
      var toggleVisibilityButton = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, _this.options.selectorPasswordVisibilityButton);

      if (toggleVisibilityButton) {
        _this._toggle({
          element: _element,
          button: toggleVisibilityButton
        });
      }
    }));

    return _this;
  }
  /**
   *
   * @param {object} obj - Object containing selectors and visibility status
   * @param {HTMLElement} obj.iconVisibilityOn - The element functioning as
   * the SVG icon for visibility on
   * @param {HTMLElement} obj.iconVisibilityOff - The element functioning as
   * the SVG icon for visibility off
   * @param {boolean} obj.passwordIsVisible - The visibility of the password in the
   * input field
   */


  _createClass(TextInput, null, [{
    key: "options",
    get:
    /**
     * The component options.
     *
     * If `options` is specified in the constructor,
     * {@linkcode TextInput.create .create()},
     * or {@linkcode TextInput.init .init()},
     * properties in this object are overriden for the instance being
     * created and how {@linkcode TextInput.init .init()} works.
     * @property {string} selectorInit The CSS selector to find text input UIs.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-text-input]',
        selectorPasswordField: ".".concat(prefix, "--text-input[data-toggle-password-visibility]"),
        selectorPasswordVisibilityButton: ".".concat(prefix, "--text-input--password__visibility__toggle"),
        selectorPasswordVisibilityTooltip: ".".concat(prefix, "--text-input--password__visibility__toggle > .").concat(prefix, "--assistive-text"),
        passwordIsVisible: "".concat(prefix, "--text-input--password-visible"),
        svgIconVisibilityOn: "svg.".concat(prefix, "--icon--visibility-on"),
        svgIconVisibilityOff: "svg.".concat(prefix, "--icon--visibility-off")
      };
    }
    /**
     * The map associating DOM element and text input UI instance.
     * @type {WeakMap}
     */

  }]);

  TextInput.components = new WeakMap();
  return TextInput;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));



/***/ }),

/***/ "../../node_modules/carbon-components/es/components/tile/tile.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/tile/tile.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */








var Tile = /*#__PURE__*/function (_mixin) {
  _inherits(Tile, _mixin);

  var _super = _createSuper(Tile);
  /**
   * Tile.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as an Tile.
   */


  function Tile(element, options) {
    var _this;

    _classCallCheck(this, Tile);

    _this = _super.call(this, element, options);

    _this._getClass = function (type) {
      var typeObj = {
        expandable: _this.options.classExpandedTile,
        clickable: _this.options.classClickableTile,
        selectable: _this.options.classSelectableTile
      };
      return typeObj[type];
    };

    _this._hookActions = function (tileClass) {
      var isExpandable = _this.tileType === 'expandable';

      if (isExpandable) {
        var aboveTheFold = _this.element.querySelector(_this.options.selectorAboveTheFold);

        var getStyle = _this.element.ownerDocument.defaultView.getComputedStyle(_this.element, null);

        var tilePaddingTop = parseInt(getStyle.getPropertyValue('padding-top'), 10);
        var tilePaddingBottom = parseInt(getStyle.getPropertyValue('padding-bottom'), 10);
        var tilePadding = tilePaddingTop + tilePaddingBottom;

        if (aboveTheFold) {
          _this.tileHeight = _this.element.getBoundingClientRect().height;
          _this.atfHeight = aboveTheFold.getBoundingClientRect().height + tilePadding;
          _this.element.style.maxHeight = "".concat(_this.atfHeight, "px");
        }

        if (_this.element.classList.contains(_this.options.classExpandedTile)) {
          _this._setTileHeight();
        }
      }

      _this.element.addEventListener('click', function (evt) {
        var input = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(evt, _this.options.selectorTileInput);

        if (!input) {
          _this.element.classList.toggle(tileClass);
        }

        if (isExpandable) {
          _this._setTileHeight();
        }
      });

      _this.element.addEventListener('keydown', function (evt) {
        var input = _this.element.querySelector(_this.options.selectorTileInput);

        if (input) {
          if (evt.which === 13 || evt.which === 32) {
            if (!isExpandable) {
              _this.element.classList.toggle(tileClass);

              input.checked = !input.checked;
            }
          }
        }
      });
    };

    _this._setTileHeight = function () {
      var isExpanded = _this.element.classList.contains(_this.options.classExpandedTile);

      _this.element.style.maxHeight = isExpanded ? "".concat(_this.tileHeight, "px") : "".concat(_this.atfHeight, "px");
    };

    _this.tileType = _this.element.dataset.tile;
    _this.tileHeight = 0; // Tracks expandable tile height

    _this.atfHeight = 0; // Tracks above the fold height

    _this._hookActions(_this._getClass(_this.tileType));

    return _this;
  }

  _createClass(Tile, [{
    key: "release",
    value: function release() {
      _get(_getPrototypeOf(Tile.prototype), "release", this).call(this);
    }
    /**
     * The map associating DOM element and Tile UI instance.
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * properties in this object are overriden for the instance being created.
     * @property {string} selectorInit The CSS selector to find Tile instances.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-tile]',
        selectorAboveTheFold: '[data-tile-atf]',
        selectorTileInput: '[data-tile-input]',
        classExpandedTile: "".concat(prefix, "--tile--is-expanded"),
        classClickableTile: "".concat(prefix, "--tile--is-clicked"),
        classSelectableTile: "".concat(prefix, "--tile--is-selected")
      };
    }
  }]);

  Tile.components = new WeakMap();
  return Tile;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tile);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/toolbar/toolbar.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/toolbar/toolbar.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */










var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var Toolbar = /*#__PURE__*/function (_mixin) {
  _inherits(Toolbar, _mixin);

  var _super = _createSuper(Toolbar);
  /**
   * Toolbar.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as an toolbar.
   */


  function Toolbar(element, options) {
    var _this;

    _classCallCheck(this, Toolbar);

    _this = _super.call(this, element, options);

    if (!_this.element.dataset.tableTarget) {
      console.warn('There is no table bound to this toolbar!'); // eslint-disable-line no-console
    } else {
      var boundTable = _this.element.ownerDocument.querySelector(_this.element.dataset.tableTarget);

      var rowHeightBtns = _this.element.querySelector(_this.options.selectorRowHeight);

      if (rowHeightBtns) {
        _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(rowHeightBtns, 'click', function (event) {
          _this._handleRowHeightChange(event, boundTable);
        })); // toArray(this.element.querySelectorAll(this.options.selectorRowHeight)).forEach((item) => {
        //   item.addEventListener('click', (event) => { this._handleRowHeightChange(event, boundTable); });
        // });

      }
    }

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, 'keydown', function (evt) {
      _this._handleKeyDown(evt);
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, 'click', function (evt) {
      _this._handleDocumentClick(evt);
    }));

    return _this;
  }
  /**
   * Handles toggling of active state of the toolbar search input
   * @param {Event} event The event triggering this method.
   */


  _createClass(Toolbar, [{
    key: "_handleDocumentClick",
    value: function _handleDocumentClick(event) {
      var _this2 = this;

      var searchInput = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, this.options.selectorSearch);
      var isOfSelfSearchInput = searchInput && this.element.contains(searchInput);

      if (isOfSelfSearchInput) {
        var shouldBeOpen = isOfSelfSearchInput && !this.element.classList.contains(this.options.classSearchActive);
        searchInput.classList.toggle(this.options.classSearchActive, shouldBeOpen);

        if (shouldBeOpen) {
          searchInput.querySelector('input').focus();
        }
      }

      var targetComponentElement = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, this.options.selectorInit);
      toArray(this.element.ownerDocument.querySelectorAll(this.options.selectorSearch)).forEach(function (item) {
        if (!targetComponentElement || !targetComponentElement.contains(item)) {
          item.classList.remove(_this2.options.classSearchActive);
        }
      });
    }
    /**
     * Handles toggling of active state of the toolbar search input via the keyboard
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: "_handleKeyDown",
    value: function _handleKeyDown(event) {
      var searchInput = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, this.options.selectorSearch);

      if (searchInput && event.which === 27) {
        searchInput.classList.remove(this.options.classSearchActive);
      }
    }
    /**
     * Handles toggling of the row height of the associated table
     * @param {Event} event The event triggering this method.
     * @param {HTMLElement} boundTable The table associated with the toolbar.
     */

  }, {
    key: "_handleRowHeightChange",
    value: function _handleRowHeightChange(event, boundTable) {
      var _event$currentTarget$ = event.currentTarget.querySelector('input:checked'),
          value = _event$currentTarget$.value;

      if (value === 'tall') {
        boundTable.classList.add(this.options.classTallRows);
      } else {
        boundTable.classList.remove(this.options.classTallRows);
      }
    }
    /**
     * The map associating DOM element and Toolbar UI instance.
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * properties in this object are overriden for the instance being created.
     * @property {string} selectorInit The CSS selector to find toolbar instances.
     * @property {string} selectorSearch The CSS selector to find search inputs in a toolbar.
     * @property {string} selectorRowHeight The CSS selector to find the row height inputs in a toolbar.
     * @property {string} classTallRows The CSS class for making table rows into tall rows.
     * @property {string} classSearchActive The CSS class the active state of the search input.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-toolbar]',
        selectorSearch: '[data-toolbar-search]',
        selectorRowHeight: '[data-row-height]',
        classTallRows: "".concat(prefix, "--responsive-table--tall"),
        classSearchActive: "".concat(prefix, "--toolbar-search--active")
      };
    }
  }]);

  Toolbar.components = new WeakMap();
  return Toolbar;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toolbar);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/tooltip/tooltip--simple.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/tooltip/tooltip--simple.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TooltipSimple)
/* harmony export */ });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.debounce */ "../../node_modules/lodash.debounce/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */











var TooltipSimple = /*#__PURE__*/function (_mixin) {
  _inherits(TooltipSimple, _mixin);

  var _super = _createSuper(TooltipSimple);
  /**
   * Simple Tooltip.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element - The element functioning as a text field.
   */


  function TooltipSimple(element, options) {
    var _this;

    _classCallCheck(this, TooltipSimple);

    _this = _super.call(this, element, options);
    _this.tooltipFadeOut = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(function () {
      var tooltipTriggerButton = _this.getTooltipTriggerButton();

      if (tooltipTriggerButton) {
        tooltipTriggerButton.classList.remove(_this.options.classTooltipVisible);
      }
    }, 100);

    _this.getTooltipTriggerButton = function () {
      return _this.element.matches(_this.options.selectorTriggerButton) ? _this.element : _this.element.querySelector(_this.options.selectorTriggerButton);
    };

    _this.allowTooltipVisibility = function (_ref) {
      var visible = _ref.visible;

      var tooltipTriggerButton = _this.getTooltipTriggerButton();

      if (!tooltipTriggerButton) {
        return;
      }

      if (visible) {
        tooltipTriggerButton.classList.remove(_this.options.classTooltipHidden);
      } else {
        tooltipTriggerButton.classList.add(_this.options.classTooltipHidden);
      }
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.ownerDocument, 'keydown', function (event) {
      // ESC
      if (event.which === 27) {
        _this.allowTooltipVisibility({
          visible: false
        });

        var tooltipTriggerButton = _this.getTooltipTriggerButton();

        if (tooltipTriggerButton) {
          tooltipTriggerButton.classList.remove(_this.options.classTooltipVisible);
        }
      }
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'mouseenter', function () {
      _this.tooltipFadeOut.cancel();

      _this.allowTooltipVisibility({
        visible: true
      });

      var tooltipTriggerButton = _this.getTooltipTriggerButton();

      if (tooltipTriggerButton) {
        tooltipTriggerButton.classList.add(_this.options.classTooltipVisible);
      }
    }));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'mouseleave', _this.tooltipFadeOut));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'focusin', function (event) {
      if ((0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_2__["default"])(event, _this.options.selectorTriggerButton)) {
        _this.allowTooltipVisibility({
          visible: true
        });
      }
    }));

    return _this;
  }

  _createClass(TooltipSimple, null, [{
    key: "options",
    get:
    /**
     * The component options.
     *
     * If `options` is specified in the constructor,
     * {@linkcode TooltipSimple.create .create()},
     * or {@linkcode TooltipSimple.init .init()},
     * properties in this object are overriden for the instance being
     * created and how {@linkcode TooltipSimple.init .init()} works.
     * @property {string} selectorInit The CSS selector to find simple tooltip UIs.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_3__["default"].prefix;
      return {
        selectorInit: '[data-tooltip-definition],[data-tooltip-icon]',
        selectorTriggerButton: ".".concat(prefix, "--tooltip__trigger.").concat(prefix, "--tooltip--a11y"),
        classTooltipHidden: "".concat(prefix, "--tooltip--hidden"),
        classTooltipVisible: "".concat(prefix, "--tooltip--visible")
      };
    }
    /**
     * The map associating DOM element and simple tooltip UI instance.
     * @type {WeakMap}
     */

  }]);

  TooltipSimple.components = new WeakMap();
  return TooltipSimple;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_7__["default"]));



/***/ }),

/***/ "../../node_modules/carbon-components/es/components/tooltip/tooltip.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/tooltip/tooltip.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-event */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-event.js");
/* harmony import */ var _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/evented-show-hide-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-show-hide-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../floating-menu/floating-menu */ "../../node_modules/carbon-components/es/components/floating-menu/floating-menu.js");
/* harmony import */ var _globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/get-launching-details */ "../../node_modules/carbon-components/es/globals/js/misc/get-launching-details.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */











/**
 * @param {Element} menuBody The menu body with the menu arrow.
 * @param {string} menuDirection Where the floating menu menu should be placed relative to the trigger button.
 * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
 * @private
 */

var getMenuOffset = function getMenuOffset(menuBody, menuDirection) {
  var _DIRECTION_LEFT$DIREC, _DIRECTION_LEFT$DIREC2;

  var arrowStyle = menuBody.ownerDocument.defaultView.getComputedStyle(menuBody, ':before');
  var arrowPositionProp = (_DIRECTION_LEFT$DIREC = {}, _defineProperty(_DIRECTION_LEFT$DIREC, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_LEFT, 'right'), _defineProperty(_DIRECTION_LEFT$DIREC, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_TOP, 'bottom'), _defineProperty(_DIRECTION_LEFT$DIREC, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_RIGHT, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC)[menuDirection];
  var menuPositionAdjustmentProp = (_DIRECTION_LEFT$DIREC2 = {}, _defineProperty(_DIRECTION_LEFT$DIREC2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_LEFT, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_TOP, 'top'), _defineProperty(_DIRECTION_LEFT$DIREC2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_RIGHT, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC2, _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC2)[menuDirection];
  var values = [arrowPositionProp, 'border-bottom-width'].reduce(function (o, name) {
    return _objectSpread(_objectSpread({}, o), {}, _defineProperty({}, name, Number((/^([\d-.]+)px$/.exec(arrowStyle.getPropertyValue(name)) || [])[1])));
  }, {});
  var margin = 0;

  if (menuDirection !== _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_BOTTOM) {
    var style = menuBody.ownerDocument.defaultView.getComputedStyle(menuBody);
    margin = Number((/^([\d-.]+)px$/.exec(style.getPropertyValue('margin-top')) || [])[1]);
  }

  values[arrowPositionProp] = values[arrowPositionProp] || -6; // IE, etc.

  if (Object.keys(values).every(function (name) {
    return !isNaN(values[name]);
  })) {
    var arrowPosition = values[arrowPositionProp],
        borderBottomWidth = values['border-bottom-width'];
    return _defineProperty({
      left: 0,
      top: 0
    }, menuPositionAdjustmentProp, Math.sqrt(Math.pow(borderBottomWidth, 2) * 2) - arrowPosition + margin * (menuDirection === _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__.DIRECTION_TOP ? 2 : 1));
  }

  return undefined;
};
/**
 * Key codes for allowed keys that will trigger opening a tooltip
 * @type {Integer[]}
 * @private
 */


var allowedOpenKeys = [32, 13];

var Tooltip = /*#__PURE__*/function (_mixin) {
  _inherits(Tooltip, _mixin);

  var _super = _createSuper(Tooltip);
  /**
   * Tooltip.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   */


  function Tooltip(element, options) {
    var _this;

    _classCallCheck(this, Tooltip);

    _this = _super.call(this, element, options);
    _this._hasContextMenu = false;

    _this._hookOn(element);

    return _this;
  }
  /**
   * A flag to detect if `oncontextmenu` event is fired right before `focus`/`blur` events.
   * @type {boolean}
   */


  _createClass(Tooltip, [{
    key: "createdByEvent",
    value:
    /**
     * A method called when this widget is created upon events.
     * @param {Event} event The event triggering the creation.
     */
    function createdByEvent(event) {
      var relatedTarget = event.relatedTarget,
          type = event.type,
          which = event.which;

      if (type === 'click' || allowedOpenKeys.includes(which)) {
        this._handleClick({
          relatedTarget: relatedTarget,
          type: type,
          details: (0,_globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_1__["default"])(event)
        });
      }
    }
    /**
     * Changes the shown/hidden state.
     * @param {string} state The new state.
     * @param {object} detail The detail of the event trigging this action.
     * @param {Function} callback Callback called when change in state completes.
     */

  }, {
    key: "changeState",
    value: function changeState(state, detail, callback) {
      if (!this.tooltip) {
        var tooltip = this.element.ownerDocument.querySelector(this.element.getAttribute(this.options.attribTooltipTarget));

        if (!tooltip) {
          throw new Error('Cannot find the target tooltip.');
        } // Lazily create a component instance for tooltip


        this.tooltip = _floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_0__["default"].create(tooltip, {
          refNode: this.element,
          classShown: this.options.classShown,
          offset: this.options.objMenuOffset,
          contentNode: tooltip.querySelector(this.options.selectorContent)
        });

        this._hookOn(tooltip);

        this.children.push(this.tooltip);
      } // Delegates the action of changing state to the tooltip.
      // (And thus the before/after shown/hidden events are fired from the tooltip)


      this.tooltip.changeState(state, Object.assign(detail, {
        delegatorNode: this.element
      }), callback);
    }
    /**
     * Attaches event handlers to show the tooltip.
     * @param {Element} element The element to attach the events to.
     * @private
     */

  }, {
    key: "_hookOn",
    value: function _hookOn(element) {
      var _this2 = this;
      /**
       * Setup the _handleClick function for displaying a tooltip
       * @param {Event} evt - user initiated event
       * @param {Integer[]} [allowedKeys] - allowed key codes the user may press to open the tooltip
       * @private
       */


      var handleClickContextMenu = function handleClickContextMenu(evt, allowedKeys) {
        var relatedTarget = evt.relatedTarget,
            type = evt.type,
            which = evt.which; // Allow user to use `space` or `enter` to open tooltip

        if (typeof allowedKeys === 'undefined' || allowedKeys.includes(which)) {
          var hadContextMenu = _this2._hasContextMenu;
          _this2._hasContextMenu = type === 'contextmenu';

          _this2._handleClick({
            relatedTarget: relatedTarget,
            type: type,
            hadContextMenu: hadContextMenu,
            details: (0,_globals_js_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_1__["default"])(evt)
          });
        }
      };

      this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_2__["default"])(element, 'click', handleClickContextMenu, false));

      if (this.element.tagName !== 'BUTTON') {
        this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_2__["default"])(this.element, 'keydown', function (event) {
          handleClickContextMenu(event, allowedOpenKeys);
        }, false));
      }
    }
    /**
     * Handles click/focus events.
     * @param {object} params The parameters.
     * @param {Element} params.relatedTarget The element that focus went to. (For `blur` event)
     * @param {string} params.type The event type triggering this method.
     * @param {boolean} params.hadContextMenu
     * @param {object} params.details The event details.
     * @private
     */

  }, {
    key: "_handleClick",
    value: function _handleClick(_ref2) {
      var relatedTarget = _ref2.relatedTarget,
          type = _ref2.type,
          hadContextMenu = _ref2.hadContextMenu,
          details = _ref2.details;
      var state = {
        click: 'shown',
        keydown: 'shown',
        blur: 'hidden',
        touchleave: 'hidden',
        touchcancel: 'hidden'
      }[type];
      var shouldPreventClose;

      if (type === 'blur') {
        // Note: SVGElement in IE11 does not have `.contains()`
        var wentToSelf = relatedTarget && this.element.contains && this.element.contains(relatedTarget) || this.tooltip && this.tooltip.element.contains(relatedTarget);
        shouldPreventClose = hadContextMenu || wentToSelf;
      }

      if (!shouldPreventClose) {
        this.changeState(state, details);
      }
    }
  }], [{
    key: "options",
    get: function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_3__["default"].prefix;
      return {
        selectorInit: '[data-tooltip-trigger]',
        selectorContent: ".".concat(prefix, "--tooltip__content"),
        classShown: "".concat(prefix, "--tooltip--shown"),
        attribTooltipTarget: 'data-tooltip-target',
        objMenuOffset: getMenuOffset,
        initEventNames: ['click', 'keydown']
      };
    }
  }]);

  Tooltip.components = new WeakMap();
  return Tooltip;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_4__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_init_component_by_event__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_7__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_8__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tooltip);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/ui-shell/header-nav.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/ui-shell/header-nav.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var HeaderNav = /*#__PURE__*/function (_mixin) {
  _inherits(HeaderNav, _mixin);

  var _super = _createSuper(HeaderNav);
  /**
   * Header nav.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as an header nav.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorSubmenu] The CSS selector to find sub menus.
   * @param {string} [options.selectorSubmenuLink] The CSS selector to find the trigger buttons of sub menus.
   * @param {string} [options.selectorSubmenuItem] The CSS selector to find the sub menu items.
   */


  function HeaderNav(element, options) {
    var _this;

    _classCallCheck(this, HeaderNav);

    _this = _super.call(this, element, options);

    _this.getCurrentNavigation = function () {
      var focused = _this.element.ownerDocument.activeElement.closest(_this.options.selectorSubmenu);

      return focused && focused.nodeType === Node.ELEMENT_NODE ? focused.querySelector(_this.options.selectorSubmenuLink) : null;
    };

    _this.navigate = function (direction) {
      var items = toArray(_this.element.querySelectorAll(_this.options.selectorSubmenuLink));

      var start = _this.getCurrentNavigation();

      var getNextItem = function getNextItem(old) {
        var handleUnderflow = function handleUnderflow(index, length) {
          return index + (index >= 0 ? 0 : length);
        };

        var handleOverflow = function handleOverflow(index, length) {
          return index - (index < length ? 0 : length);
        }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


        var index = Math.max(items.indexOf(old) + direction, -1);
        return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
      };

      getNextItem(start).focus();
    };

    _this._handleKeyDown = function (event) {
      var keyCodes = {
        37: _this.constructor.NAVIGATE.BACKWARD,
        // left arrow
        39: _this.constructor.NAVIGATE.FORWARD // right arrow

      };
      var keyCodeMatches = keyCodes[event.which];

      if (keyCodeMatches) {
        _this.navigate(keyCodeMatches);
      }
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'keydown', _this._handleKeyDown));

    return _this;
  }
  /**
   * The map associating DOM element and Header instance.
   * @member HeaderNav.components
   * @type {WeakMap}
   */


  _createClass(HeaderNav, null, [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode HeaderNav.create .create()}, or
     * {@linkcode HeaderNav.init .init()},
     * properties in this object are overriden for the instance being create and
     * how {@linkcode HeaderNav.init .init()} works.
     * @member HeaderNav.options
     * @type {object}
     * @property {string} selectorInit The data attribute to find side navs.
     * @property {string} [selectorSubmenu] The CSS selector to find sub menus.
     * @property {string} [selectorSubmenuLink] The CSS selector to find the trigger buttons of sub menus.
     * @property {string} [selectorSubmenuItem] The CSS selector to find the sub menu items.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        selectorInit: '[data-header-nav]',
        selectorNavKind: '[data-header-nav-kind]',
        selectorSubmenu: ".".concat(prefix, "--header__submenu"),
        selectorSubmenuLink: ".".concat(prefix, "--header__menu-title"),
        selectorSubmenuItem: ".".concat(prefix, "--header__menu-title > .").concat(prefix, "--header__menu-item")
      };
    }
    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member Header.NAVIGATE
     * @type {object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  HeaderNav.components = new WeakMap();
  HeaderNav.NAVIGATE = {
    BACKWARD: -1,
    FORWARD: 1
  };
  return HeaderNav;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeaderNav);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/ui-shell/header-submenu.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/ui-shell/header-submenu.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */










var forEach = /* #__PURE__ */function () {
  return Array.prototype.forEach;
}();

var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
};

var HeaderSubmenu = /*#__PURE__*/function (_mixin) {
  _inherits(HeaderSubmenu, _mixin);

  var _super = _createSuper(HeaderSubmenu);
  /**
   * Sub menus in header nav.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a submenu in header nav.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorTrigger] The CSS selector to find the trigger button.
   * @param {string} [options.selectorItem] The CSS selector to find the menu items.
   * @param {string} [options.attribExpanded] The attribute that represents the expanded/collapsed state.
   */


  function HeaderSubmenu(element, options) {
    var _this;

    _classCallCheck(this, HeaderSubmenu);

    _this = _super.call(this, element, options);

    _this._getAction = function (event) {
      var isFlyoutMenu = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(event, _this.options.selectorFlyoutMenu);

      if (isFlyoutMenu) {
        return _this.constructor.actions.DELEGATE_TO_FLYOUT_MENU;
      }

      switch (event.type) {
        case 'keydown':
          return {
            32: _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS,
            // space bar
            13: _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS,
            // enter
            27: _this.constructor.actions.CLOSE_SUBMENU // esc
            // possible arrow keys

          }[event.which];

        case 'click':
          return (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(event, _this.options.selectorItem) ? _this.constructor.actions.CLOSE_SUBMENU : null;

        case 'blur':
        case 'focusout':
          {
            var isOfSelf = _this.element.contains(event.relatedTarget);

            return isOfSelf ? null : _this.constructor.actions.CLOSE_SUBMENU;
          }

        case 'mouseenter':
          return _this.constructor.actions.OPEN_SUBMENU;

        case 'mouseleave':
          return _this.constructor.actions.CLOSE_SUBMENU;

        default:
          return null;
      }
    };

    _this._getNewState = function (action) {
      var trigger = _this.element.querySelector(_this.options.selectorTrigger);

      var isExpanded = trigger.getAttribute(_this.options.attribExpanded) === 'true';

      switch (action) {
        case _this.constructor.actions.CLOSE_SUBMENU:
          return false;

        case _this.constructor.actions.OPEN_SUBMENU:
          return true;

        case _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS:
          return !isExpanded;

        default:
          return isExpanded;
      }
    };

    _this._setState = function (_ref) {
      var shouldBeExpanded = _ref.shouldBeExpanded,
          shouldFocusOnOpen = _ref.shouldFocusOnOpen;

      var trigger = _this.element.querySelector(_this.options.selectorTrigger);

      trigger.setAttribute(_this.options.attribExpanded, shouldBeExpanded);
      forEach.call(_this.element.querySelectorAll(_this.options.selectorItem), function (item) {
        item.tabIndex = shouldBeExpanded ? 0 : -1;
      }); // focus first submenu item

      if (shouldBeExpanded && shouldFocusOnOpen) {
        _this.element.querySelector(_this.options.selectorItem).focus();
      }
    };

    _this.getCurrentNavigation = function () {
      var focused = _this.element.ownerDocument.activeElement;
      return focused.nodeType === Node.ELEMENT_NODE && focused.matches(_this.options.selectorItem) ? focused : null;
    };

    _this.navigate = function (direction) {
      var items = toArray(_this.element.querySelectorAll(_this.options.selectorItem));

      var start = _this.getCurrentNavigation() || _this.element.querySelector(_this.options.selectorItemSelected);

      var getNextItem = function getNextItem(old) {
        var handleUnderflow = function handleUnderflow(index, length) {
          return index + (index >= 0 ? 0 : length);
        };

        var handleOverflow = function handleOverflow(index, length) {
          return index - (index < length ? 0 : length);
        }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


        var index = Math.max(items.indexOf(old) + direction, -1);
        return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
      };

      for (var current = getNextItem(start); current && current !== start; current = getNextItem(current)) {
        if (!current.matches(_this.options.selectorItemHidden) && !current.parentNode.matches(_this.options.selectorItemHidden) && !current.matches(_this.options.selectorItemSelected)) {
          current.focus();
          break;
        }
      }
    };

    _this._handleEvent = function (event) {
      var trigger = _this.element.querySelector(_this.options.selectorTrigger);

      if (!trigger) {
        return;
      }

      var action = _this._getAction(event);

      if (action) {
        var shouldBeExpanded = _this._getNewState(action);

        _this._setState({
          shouldBeExpanded: shouldBeExpanded
        });
      }
    };

    _this._handleKeyDown = function (event) {
      var trigger = _this.element.querySelector(_this.options.selectorTrigger);

      if (!trigger) {
        return;
      }

      var action = _this._getAction(event);

      if (event.which === 32) {
        event.preventDefault();
      }

      switch (action) {
        case _this.constructor.actions.DELEGATE_TO_FLYOUT_MENU:
          // currently we do not have a scenario that handles flyout menu
          // handleFlyoutMenu
          break;
        // currently we do not have a scenario that opens a submenu on keydown
        // case this.constructor.actions.OPEN_SUBMENU:

        case _this.constructor.actions.CLOSE_SUBMENU:
          {
            var shouldBeExpanded = _this._getNewState(action);

            _this._setState({
              shouldBeExpanded: shouldBeExpanded
            });

            break;
          }

        case _this.constructor.actions.TOGGLE_SUBMENU_WITH_FOCUS:
          {
            var _shouldBeExpanded = _this._getNewState(action);

            _this._setState({
              shouldBeExpanded: _shouldBeExpanded,
              shouldFocusOnOpen: true
            });

            break;
          }

        default:
          {
            var expanded = trigger.getAttribute(_this.options.attribExpanded) === 'true';

            if (expanded) {
              var direction = {
                38: _this.constructor.NAVIGATE.BACKWARD,
                40: _this.constructor.NAVIGATE.FORWARD
              }[event.which];

              switch (event.which) {
                case 35:
                  {
                    // end key
                    event.preventDefault(); // prevents key from scrolling page

                    var menuItems = _this.element.querySelectorAll(_this.options.selectorItem);

                    var lastMenuItem = menuItems[menuItems.length - 1];

                    if (lastMenuItem) {
                      lastMenuItem.focus();
                    }

                    break;
                  }

                case 36:
                  {
                    // home key
                    event.preventDefault(); // prevents key from scrolling page

                    var _this$element$querySe = _this.element.querySelectorAll(_this.options.selectorItem),
                        _this$element$querySe2 = _slicedToArray(_this$element$querySe, 1),
                        firstMenuItem = _this$element$querySe2[0];

                    if (firstMenuItem) {
                      firstMenuItem.focus();
                    }

                    break;
                  }

                case 38: // up arrow

                case 40:
                  // down arrow
                  _this.navigate(direction);

                  event.preventDefault(); // prevents keys from scrolling page

                  break;

                default:
                  break;
              }
            }

            break;
          }
      }
    };

    var hasFocusOut = ('onfocusout' in window);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, hasFocusOut ? 'focusout' : 'blur', _this._handleEvent, !hasFocusOut));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'mouseenter', _this._handleEvent));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'mouseleave', _this._handleEvent));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'click', _this._handleEvent));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, 'keydown', _this._handleKeyDown));

    return _this;
  }
  /**
   * The map associating DOM element and HeaderSubmenu instance.
   * @member HeaderSubmenu.components
   * @type {WeakMap}
   */


  _createClass(HeaderSubmenu, null, [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode HeaderSubmenu.create .create()}, or
     * {@linkcode HeaderSubmenu.init .init()},
     * properties in this object are overriden for the instance being create and
     * how {@linkcode HeaderSubmenu.init .init()} works.
     * @member HeaderSubmenu.options
     * @type {object}
     * @property {string} selectorInit The data attribute to find side navs.
     * @property {string} [selectorTrigger] The CSS selector to find the trigger button.
     * @property {string} [selectorItem] The CSS selector to find the menu items.
     * @property {string} [attribExpanded] The attribute that represents the expanded/collapsed state.
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return {
        selectorInit: '[data-header-submenu]',
        selectorTrigger: ".".concat(prefix, "--header__menu-title"),
        selectorItem: ".".concat(prefix, "--header__menu .").concat(prefix, "--header__menu-item"),
        attribExpanded: 'aria-expanded'
      };
    }
    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member HeaderSubmenu.NAVIGATE
     * @type {object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  HeaderSubmenu.components = new WeakMap();
  HeaderSubmenu.actions = {
    CLOSE_SUBMENU: 'CLOSE_SUBMENU',
    OPEN_SUBMENU: 'OPEN_SUBMENU',
    TOGGLE_SUBMENU_WITH_FOCUS: 'TOGGLE_SUBMENU_WITH_FOCUS',
    DELEGATE_TO_FLYOUT_MENU: 'DELEGATE_TO_FLYOUT_MENU'
  };
  HeaderSubmenu.NAVIGATE = {
    BACKWARD: -1,
    FORWARD: 1
  };
  return HeaderSubmenu;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeaderSubmenu);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/ui-shell/navigation-menu-panel.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/ui-shell/navigation-menu-panel.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NavigationMenuPanel)
/* harmony export */ });
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_mixins_init_component_by_launcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-launcher */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-launcher.js");
/* harmony import */ var _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/evented-show-hide-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-show-hide-state.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../globals/js/mixins/evented-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js");
/* harmony import */ var _globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/toggle-attribute */ "../../node_modules/carbon-components/es/globals/js/misc/toggle-attribute.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */











var NavigationMenuPanel = /*#__PURE__*/function (_mixin) {
  _inherits(NavigationMenuPanel, _mixin);

  var _super = _createSuper(NavigationMenuPanel);

  function NavigationMenuPanel() {
    var _this;

    _classCallCheck(this, NavigationMenuPanel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.createdByLauncher = function (event) {
      var isExpanded = !_this.element.hasAttribute('hidden');
      var newState = isExpanded ? 'collapsed' : 'expanded';
      _this.triggerButton = event.delegateTarget;

      _this.changeState(newState);
    };

    _this.shouldStateBeChanged = function (state) {
      return state === 'expanded' === _this.element.hasAttribute('hidden');
    };

    _this._changeState = function (state, callback) {
      (0,_globals_js_misc_toggle_attribute__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element, 'hidden', state !== 'expanded');

      if (_this.triggerButton) {
        if (state === 'expanded') {
          var focusableMenuItems = _this.element.querySelector(_this.options.selectorFocusableMenuItem);

          if (focusableMenuItems) {
            focusableMenuItems.focus();
          }
        }

        var label = state === 'expanded' ? _this.triggerButton.getAttribute(_this.options.attribLabelCollapse) : _this.triggerButton.getAttribute(_this.options.attribLabelExpand);

        _this.triggerButton.classList.toggle(_this.options.classNavigationMenuPanelHeaderActionActive, state === 'expanded');

        _this.triggerButton.setAttribute('aria-label', label);

        _this.triggerButton.setAttribute('title', label);
      }

      callback();
    };

    return _this;
  }

  _createClass(NavigationMenuPanel, null, [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode NavigationMenuPanel.create .create()}, or
     * {@linkcode NavigationMenuPanel.init .init()},
     * properties in this object are overriden for the instance being create and
     * how {@linkcode NavigationMenuPanel.init .init()} works.
     * @member NavigationMenuPanel.options
     * @type {object}
     * @property {string} selectorInit The CSS class to find popup navs.
     * @property {string} attribInitTarget The attribute name in the launcher buttons to find target popup nav.
     * @property {string[]} initEventNames The events that the component will handles
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"].prefix;
      return {
        initEventNames: ['click'],
        eventBeforeExpanded: 'navigation-menu-being-expanded',
        eventAfterExpanded: 'navigation-menu-expanded',
        eventBeforeCollapsed: 'navigation-menu-being-collapsed',
        eventAfterCollapsed: 'navigation-menu-collapsed',
        selectorFocusableMenuItem: ".".concat(prefix, "--navigation__category-toggle, .").concat(prefix, "--navigation-link"),
        classNavigationMenuPanelHeaderActionActive: "".concat(prefix, "--header__action--active"),
        attribLabelExpand: 'data-navigation-menu-panel-label-expand',
        attribLabelCollapse: 'data-navigation-menu-panel-label-collapse'
      };
    }
  }]);

  NavigationMenuPanel.components = new WeakMap();
  return NavigationMenuPanel;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_2__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_3__["default"], _globals_js_mixins_init_component_by_launcher__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_evented_show_hide_state__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"], _globals_js_mixins_evented_state__WEBPACK_IMPORTED_MODULE_7__["default"]));



/***/ }),

/***/ "../../node_modules/carbon-components/es/components/ui-shell/navigation-menu.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/ui-shell/navigation-menu.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NavigationMenu)
/* harmony export */ });
/* harmony import */ var _navigation_menu_panel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./navigation-menu-panel */ "../../node_modules/carbon-components/es/components/ui-shell/navigation-menu-panel.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */







var NavigationMenu = /*#__PURE__*/function (_NavigationMenuPanel) {
  _inherits(NavigationMenu, _NavigationMenuPanel);

  var _super = _createSuper(NavigationMenu);
  /**
   * A navigation menu
   * @extends NavigationMenuPanel
   * @param {HTMLElement} element The element working as a selector.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorInit] The CSS class to find navigation
   * menus.
   * @param {string} [options.attribInitTarget] The attribute name in the
   * launcher buttons to find target navigation menu.
   * @param {string} [options.selectorShellNavSubmenu] The CSS selector for a
   * nav submenu
   * @param {string} [options.selectorShellNavLink] The CSS selector for a nav
   * link
   * @param {string} [options.selectorShellNavLinkCurrent] The CSS selector for
   * the current nav link
   * @param {string} [options.selectorShellNavItem] The CSS selector for a nav
   * item
   * @param {string} [options.selectorShellNavCategory] The CSS selector for a
   * nav category
   * @param {string} [options.classShellNavItemActive] The CSS class for the
   * active nav item
   * @param {string} [options.classShellNavLinkCurrent] The CSS class for the
   * current lav link
   * @param {string} [options.classShellNavCategoryExpanded] The CSS class
   * for an expanded nav category
   */


  function NavigationMenu(element, options) {
    var _this;

    _classCallCheck(this, NavigationMenu);

    _this = _super.call(this, element, options);

    _this.getCurrentNavigation = function () {
      return _this.element.ownerDocument.activeElement;
    };

    _this.navigate = function (direction) {
      var items = _toConsumableArray(_this.element.querySelectorAll(_this.options.selectorFocusableNavItems));

      var start = _this.getCurrentNavigation();

      var getNextItem = function getNextItem(old) {
        var handleUnderflow = function handleUnderflow(index, length) {
          return index + (index >= 0 ? 0 : length);
        };

        var handleOverflow = function handleOverflow(index, length) {
          return index - (index < length ? 0 : length);
        }; // `items.indexOf(old)` may be -1 (Scenario of no previous focus)


        var index = Math.max(items.indexOf(old) + direction, -1);
        return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
      };

      getNextItem(start).focus();
    };

    _this._handleKeyDown = function (event) {
      // handle Esc
      var isExpanded = !_this.element.hasAttribute('hidden');

      if (event.which === 27 && isExpanded) {
        _this.changeState('collapsed');

        if (_this.triggerButton) {
          _this.triggerButton.focus();
        }

        return;
      } // handle up/down arrow keys


      var matchesNavSubmenu = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(event, _this.options.selectorShellNavSubmenu);
      var matchesShellNavLink = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(event, _this.options.selectorShellNavLink);

      if (!matchesNavSubmenu && !matchesShellNavLink) {
        return;
      }

      var navigationKeyCodes = {
        38: _this.constructor.NAVIGATE.BACKWARD,
        // up arrow
        40: _this.constructor.NAVIGATE.FORWARD // down arrow

      };
      var navigationKeyCodeMatches = navigationKeyCodes[event.which];

      if (navigationKeyCodeMatches) {
        event.preventDefault(); // prevent arrow keys from scrolling

        _this.navigate(navigationKeyCodeMatches);
      }
    };

    _this._handleFocusOut = function (event) {
      var nextTargetIsOfSelf = _this.element.contains(event.relatedTarget) || event.relatedTarget === _this.triggerButton || !event.relatedTarget;

      var oldTargetIsOfSelf = _this.element.contains(event.target);

      if (oldTargetIsOfSelf && !nextTargetIsOfSelf) {
        _this.changeState('collapsed');

        _this.triggerButton.focus();
      }
    };

    _this.changeNavSubmenuState = function (_ref) {
      var matchesNavSubmenu = _ref.matchesNavSubmenu,
          shouldBeCollapsed = _ref.shouldBeCollapsed;
      var shellNavCategory = matchesNavSubmenu.closest(_this.options.selectorShellNavCategory);

      if (!shellNavCategory) {
        return;
      }

      matchesNavSubmenu.setAttribute('aria-expanded', !shouldBeCollapsed);
      shellNavCategory.classList.toggle(_this.options.classShellNavCategoryExpanded);
      Array.prototype.forEach.call(shellNavCategory.querySelectorAll(_this.options.selectorShellNavLink), function (item) {
        item.tabIndex = !shouldBeCollapsed ? 0 : -1;
      });
    };

    _this._handleClick = function (event) {
      var matchesNavSubmenu = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(event, _this.options.selectorShellNavSubmenu);
      var matchesShellNavLink = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(event, _this.options.selectorShellNavLink);
      var matchesNestedShellNavLink = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_0__["default"])(event, _this.options.selectorShellNestedNavLink);

      if (!matchesNavSubmenu && !matchesShellNavLink) {
        return;
      }

      if (matchesNestedShellNavLink) {
        _toConsumableArray(_this.element.querySelectorAll(_this.options.selectorShellNavLinkCurrent)).forEach(function (el) {
          el.classList.remove(_this.options.classShellNavItemActive, _this.options.classShellNavLinkCurrent);
        });

        matchesNestedShellNavLink.closest(_this.options.selectorShellNavNestedCategory).classList.add(_this.options.classShellNavItemActive);
        return;
      }

      if (matchesNavSubmenu) {
        var isExpanded = matchesNavSubmenu.getAttribute('aria-expanded') === 'true';

        _this.changeNavSubmenuState({
          matchesNavSubmenu: matchesNavSubmenu,
          isExpanded: isExpanded
        });

        return;
      }

      if (matchesShellNavLink) {
        _toConsumableArray(_this.element.querySelectorAll(_this.options.selectorShellNavLinkCurrent)).forEach(function (el) {
          el.classList.remove(_this.options.classShellNavItemActive, _this.options.classShellNavLinkCurrent);
        });

        matchesShellNavLink.closest(_this.options.selectorShellNavItem).classList.add(_this.options.classShellNavItemActive);
      }
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(element, 'click', _this._handleClick));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(element, 'keydown', _this._handleKeyDown));

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element.ownerDocument, 'click', function (event) {
      if (!_this.element.hasAttribute('hidden') && !_this.triggerButton.contains(event.target) && !_this.element.contains(event.target)) {
        _this.changeState('collapsed');
      }
    }));

    var hasFocusOut = ('onfocusout' in window);

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.element, hasFocusOut ? 'focusout' : 'blur', _this._handleFocusOut, !hasFocusOut));

    return _this;
  }
  /**
   * @returns {Element} Currently highlighted element.
   */


  _createClass(NavigationMenu, null, [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode NavigationMenu.create .create()}, or
     * {@linkcode NavigationMenu.init .init()},
     * properties in this object are overriden for the instance being create and
     * how {@linkcode NavigationMenu.init .init()} works.
     * @member NavigationMenu.options
     * @type {object}
     * @property {string} selectorInit The CSS class to find navigation menus.
     * @property {string} attribInitTarget The attribute name in the
     * launcher buttons to find target navigation menu.
     * @property {string[]} initEventNames The events that the component
     * will handles
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return Object.assign(Object.create(_navigation_menu_panel__WEBPACK_IMPORTED_MODULE_3__["default"].options), {
        selectorInit: '[data-navigation-menu]',
        attribInitTarget: 'data-navigation-menu-target',
        selectorShellNavSubmenu: ".".concat(prefix, "--navigation__category-toggle"),
        selectorShellNavLink: ".".concat(prefix, "--navigation-link"),
        selectorShellNestedNavLink: ".".concat(prefix, "--navigation__category-item > a.").concat(prefix, "--navigation-link"),
        selectorShellNavLinkCurrent: ".".concat(prefix, "--navigation-item--active,.").concat(prefix, "--navigation__category-item--active"),
        selectorFocusableNavItems: "\n        .".concat(prefix, "--navigation__category-toggle,\n        .").concat(prefix, "--navigation-item > .").concat(prefix, "--navigation-link,\n        .").concat(prefix, "--navigation-link[tabindex=\"0\"]\n      "),
        selectorShellNavItem: ".".concat(prefix, "--navigation-item"),
        selectorShellNavCategory: ".".concat(prefix, "--navigation__category"),
        selectorShellNavNestedCategory: ".".concat(prefix, "--navigation__category-item"),
        classShellNavItemActive: "".concat(prefix, "--navigation-item--active"),
        classShellNavLinkCurrent: "".concat(prefix, "--navigation__category-item--active"),
        classShellNavCategoryExpanded: "".concat(prefix, "--navigation__category--expanded")
      });
    }
    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member NavigationMenuPanel.NAVIGATE
     * @type {object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  NavigationMenu.components = new WeakMap();
  NavigationMenu.NAVIGATE = {
    BACKWARD: -1,
    FORWARD: 1
  };
  return NavigationMenu;
}(_navigation_menu_panel__WEBPACK_IMPORTED_MODULE_3__["default"]);



/***/ }),

/***/ "../../node_modules/carbon-components/es/components/ui-shell/product-switcher.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/ui-shell/product-switcher.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _navigation_menu_panel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./navigation-menu-panel */ "../../node_modules/carbon-components/es/components/ui-shell/navigation-menu-panel.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_misc_on_focus_by_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/on-focus-by-keyboard */ "../../node_modules/carbon-components/es/globals/js/misc/on-focus-by-keyboard.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}





var seq = 0;

var ProductSwitcher = /*#__PURE__*/function (_NavigationMenuPanel) {
  _inherits(ProductSwitcher, _NavigationMenuPanel);

  var _super = _createSuper(ProductSwitcher);
  /**
   * A navigation menu.
   * @extends NavigationMenuPanel
   * @param {HTMLElement} element The element working as a selector.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorInit] The CSS class to find product
   * switchers
   * @param {string} [options.attribInitTarget] The attribute name in the
   * launcher buttons to find target product switcher
   * @param {string} [options.classProductSwitcherExpanded] The CSS class
   * for an expanded product switcher
   */


  function ProductSwitcher(element, options) {
    var _this;

    _classCallCheck(this, ProductSwitcher);

    _this = _super.call(this, element, options);
    _this.current = '';
    _this.triggerButtonIds = new Set();

    _this._handleFocusOut = function (event) {
      if (_this.element.contains(event.relatedTarget)) {
        return;
      }

      var currentTriggerButton = _this.element.ownerDocument.getElementById(_this.current);

      if (currentTriggerButton && event.relatedTarget && !event.relatedTarget.matches(_this.options.selectorFloatingMenus)) {
        currentTriggerButton.focus();
      }
    };

    _this._handleKeyDown = function (event) {
      var isExpanded = !_this.element.hasAttribute('hidden');

      if (event.which === 27 && isExpanded) {
        var triggerButton = _this.current;

        _this.changeState(_this.constructor.SELECT_NONE);

        _this.element.ownerDocument.getElementById(triggerButton).focus();
      }
    };

    _this.createdByLauncher = function (event) {
      var isExpanded = _this.element.classList.contains(_this.options.classProductSwitcherExpanded);

      var launcher = event.delegateTarget;

      if (!launcher.id) {
        launcher.id = "__carbon-product-switcher-launcher-".concat(seq++);
      }

      var current = launcher.id;

      _this.changeState(isExpanded && _this.current === current ? _this.constructor.SELECT_NONE : current);
    };

    _this.shouldStateBeChanged = function (current) {
      return _this.current !== current;
    };

    _this._changeState = function (state, callback) {
      _this.element.classList.toggle(_this.options.classProductSwitcherExpanded, state !== _this.constructor.SELECT_NONE);

      _this.current = state;

      if (_this.current !== _this.constructor.SELECT_NONE) {
        _this.triggerButtonIds.add(_this.current);
      } // deactivate all other trigger buttons


      _this.triggerButtonIds.forEach(function (id) {
        var button = _this.element.ownerDocument.getElementById(id);

        var label = button.getAttribute(_this.options.attribLabelExpand);
        button.classList.remove(_this.options.classNavigationMenuPanelHeaderActionActive);
        button.setAttribute('aria-label', label);
        button.setAttribute('title', label);
      }); // set active trigger button attributes


      var currentTriggerButton = _this.element.ownerDocument.getElementById(_this.current);

      if (currentTriggerButton) {
        var label = currentTriggerButton.getAttribute(_this.options.attribLabelCollapse);
        currentTriggerButton.classList.toggle(_this.options.classNavigationMenuPanelHeaderActionActive);
        currentTriggerButton.setAttribute('aria-label', label);
        currentTriggerButton.setAttribute('title', label);
      }

      if (state !== _this.constructor.SELECT_NONE) {
        _this.element.setAttribute('tabindex', '0');

        _this.element.focus();
      } else {
        _this.element.setAttribute('tabindex', '-1');
      }

      callback();
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(element, 'keydown', _this._handleKeyDown));

    _this.manage((0,_globals_js_misc_on_focus_by_keyboard__WEBPACK_IMPORTED_MODULE_1__["default"])(element, 'blur', _this._handleFocusOut));

    return _this;
  }
  /**
   * id of currently active trigger button
   * @type {string}
   */


  _createClass(ProductSwitcher, [{
    key: "release",
    value: function release() {
      this.triggerButtonIds.clear();
      return _get(_getPrototypeOf(ProductSwitcher.prototype), "release", this).call(this);
    }
    /**
     * The map associating DOM element and ProductSwitcher instance.
     * @member ProductSwitcher.components
     * @type {WeakMap}
     */

  }], [{
    key: "options",
    get:
    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode ProductSwitcher.create .create()}, or
     * {@linkcode ProductSwitcher.init .init()},
     * properties in this object are overriden for the instance being create and
     * how {@linkcode ProductSwitcher.init .init()} works.
     * @member ProductSwitcher.options
     * @type {object}
     * @property {string} selectorInit The CSS class to find popup navs.
     * @property {string} attribInitTarget The attribute name in the
     * launcher buttons to find target popup nav.
     * @property {string[]} initEventNames The events that the component
     * will handles
     */
    function get() {
      var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_2__["default"].prefix;
      return Object.assign(Object.create(_navigation_menu_panel__WEBPACK_IMPORTED_MODULE_3__["default"].options), {
        selectorInit: '[data-product-switcher]',
        selectorFloatingMenus: "\n        .".concat(prefix, "--overflow-menu-options,\n        .").concat(prefix, "--overflow-menu-options *,\n        .").concat(prefix, "--tooltip,\n        .").concat(prefix, "--tooltip *,\n        .flatpicker-calendar,\n        .flatpicker-calendar *\n        "),
        attribInitTarget: 'data-product-switcher-target',
        classProductSwitcherExpanded: "".concat(prefix, "--panel--expanded")
      });
    }
  }]);

  ProductSwitcher.SELECT_NONE = '__carbon-product-switcher-launcher-NONE';
  ProductSwitcher.components = new WeakMap();
  return ProductSwitcher;
}(_navigation_menu_panel__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProductSwitcher);

/***/ }),

/***/ "../../node_modules/carbon-components/es/components/ui-shell/side-nav.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/components/ui-shell/side-nav.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../globals/js/misc/mixin */ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js");
/* harmony import */ var _globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../globals/js/mixins/create-component */ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/* harmony import */ var _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../globals/js/mixins/init-component-by-search */ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js");
/* harmony import */ var _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../globals/js/mixins/handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
/* harmony import */ var _globals_js_misc_on__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../globals/js/misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
/* harmony import */ var _globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals/js/misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */









var prefix = _globals_js_settings__WEBPACK_IMPORTED_MODULE_0__["default"].prefix;

var SideNav = /*#__PURE__*/function (_mixin) {
  _inherits(SideNav, _mixin);

  var _super = _createSuper(SideNav);
  /**
   * The map associating DOM element and copy button UI instance.
   * @member SideNav.components
   * @type {WeakMap}
   */

  /**
   * Side nav.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends Handles
   * @param {HTMLElement} element The element working as a side nav.
   * @param {object} [options] The component options.
   * @param {string} [options.selectorSideNavToggle]
   *   The CSS selector to find the toggle button.
   * @param {string} [options.selectorSideNavSubmenu] The CSS selector to find the trigger buttons for sub nav items.
   * @param {string} [options.selectorSideNavItem] The CSS selector to find the nav items.
   * @param {string} [options.selectorSideNavLink] The CSS selector to find the interactive potions in non-nested nav items.
   * @param {string} [options.selectorSideNavLinkCurrent]
   *   The CSS selector to find the interactive potion in active non-nested nav item.
   * @param {string} [options.classSideNavExpanded] The CSS class for the expanded state.
   * @param {string} [options.classSideNavItemActive]
   *   The CSS class for the active/inactive state for nav items.
   * @param {string} [options.classSideNavLinkCurrent]
   *   The CSS class for the active/inactive state of the interactive potion in non-nested nav items.
   */


  function SideNav(element, options) {
    var _this;

    _classCallCheck(this, SideNav);

    _this = _super.call(this, element, options);

    _this._handleClick = function (evt) {
      var matchesToggle = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorSideNavToggle);
      var matchesNavSubmenu = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorSideNavSubmenu);
      var matchesSideNavLink = (0,_globals_js_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, _this.options.selectorSideNavLink);

      if (!matchesToggle && !matchesNavSubmenu && !matchesSideNavLink) {
        return;
      }

      if (matchesToggle) {
        _this.changeState(!_this.isNavExpanded() ? _this.constructor.state.EXPANDED : _this.constructor.state.COLLAPSED);

        return;
      }

      if (matchesNavSubmenu) {
        var isSubmenuExpanded = matchesNavSubmenu.getAttribute('aria-expanded') === 'true';
        matchesNavSubmenu.setAttribute('aria-expanded', "".concat(!isSubmenuExpanded));
        return;
      }

      if (matchesSideNavLink) {
        _toConsumableArray(_this.element.querySelectorAll(_this.options.selectorSideNavLinkCurrent)).forEach(function (el) {
          el.classList.remove(_this.options.classSideNavItemActive, _this.options.classSideNavLinkCurrent);
          el.removeAttribute('aria-current');
        });

        matchesSideNavLink.classList.add(_this.options.classSideNavLinkCurrent);
        var closestSideNavItem = matchesSideNavLink.closest(_this.options.selectorSideNavItem);

        if (closestSideNavItem) {
          closestSideNavItem.classList.add(_this.options.classSideNavItemActive);
        }
      }
    };

    _this.manage((0,_globals_js_misc_on__WEBPACK_IMPORTED_MODULE_2__["default"])(element, 'click', _this._handleClick));

    return _this;
  }
  /**
   * Enum for toggling side nav visibility
   * @readonly
   * @member SideNav.state
   * @type {object}
   * @property {string} EXPANDED Opening/visible
   * @property {string} COLLAPSED Closing/hidden
   */


  _createClass(SideNav, [{
    key: "isNavExpanded",
    value:
    /**
     * @returns {boolean} `true` if the nav is expanded.
     */
    function isNavExpanded() {
      return this.element.classList.contains(this.options.classSideNavExpanded);
    }
    /**
     * Changes the expanded/collapsed state.
     */

  }, {
    key: "changeState",
    value: function changeState(state) {
      this.element.classList.toggle(this.options.classSideNavExpanded, state === this.constructor.state.EXPANDED);
    }
  }]);

  SideNav.components = new WeakMap();
  SideNav.state = {
    EXPANDED: 'expanded',
    COLLAPSED: 'collapsed'
  };
  SideNav.options = {
    selectorInit: '[data-side-nav]',
    selectorSideNavToggle: ".".concat(prefix, "--side-nav__toggle"),
    selectorSideNavSubmenu: ".".concat(prefix, "--side-nav__submenu"),
    selectorSideNavItem: ".".concat(prefix, "--side-nav__item"),
    selectorSideNavLink: ".".concat(prefix, "--side-nav__link"),
    selectorSideNavLinkCurrent: "[aria-current=\"page\"],.".concat(prefix, "--side-nav__link--current,.").concat(prefix, "--side-nav__item--active"),
    classSideNavExpanded: "".concat(prefix, "--side-nav--expanded"),
    classSideNavItemActive: "".concat(prefix, "--side-nav__item--active"),
    classSideNavLinkCurrent: "".concat(prefix, "--side-nav__link--current")
  };
  return SideNav;
}((0,_globals_js_misc_mixin__WEBPACK_IMPORTED_MODULE_3__["default"])(_globals_js_mixins_create_component__WEBPACK_IMPORTED_MODULE_4__["default"], _globals_js_mixins_init_component_by_search__WEBPACK_IMPORTED_MODULE_5__["default"], _globals_js_mixins_handles__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SideNav);

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/components.js":
/*!************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/components.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Accordion": () => (/* reexport safe */ _components_accordion_accordion__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "Checkbox": () => (/* reexport safe */ _components_checkbox_checkbox__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "CodeSnippet": () => (/* reexport safe */ _components_code_snippet_code_snippet__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   "ContentSwitcher": () => (/* reexport safe */ _components_content_switcher_content_switcher__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "CopyButton": () => (/* reexport safe */ _components_copy_button_copy_button__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "DataTable": () => (/* reexport safe */ _components_data_table_data_table__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "DataTableV2": () => (/* reexport safe */ _components_data_table_v2_data_table_v2__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "DatePicker": () => (/* reexport safe */ _components_date_picker_date_picker__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "Dropdown": () => (/* reexport safe */ _components_dropdown_dropdown__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "FileUploader": () => (/* reexport safe */ _components_file_uploader_file_uploader__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "FloatingMenu": () => (/* reexport safe */ _components_floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   "HeaderNav": () => (/* reexport safe */ _components_ui_shell_header_nav__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   "HeaderSubmenu": () => (/* reexport safe */ _components_ui_shell_header_submenu__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   "InlineLoading": () => (/* reexport safe */ _components_inline_loading_inline_loading__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "Loading": () => (/* reexport safe */ _components_loading_loading__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "Modal": () => (/* reexport safe */ _components_modal_modal__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "NavigationMenu": () => (/* reexport safe */ _components_ui_shell_navigation_menu__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   "Notification": () => (/* reexport safe */ _components_notification_notification__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "NumberInput": () => (/* reexport safe */ _components_number_input_number_input__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "OverflowMenu": () => (/* reexport safe */ _components_overflow_menu_overflow_menu__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "Pagination": () => (/* reexport safe */ _components_pagination_pagination__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "PaginationNav": () => (/* reexport safe */ _components_pagination_nav_pagination_nav__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   "ProductSwitcher": () => (/* reexport safe */ _components_ui_shell_product_switcher__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   "ProgressIndicator": () => (/* reexport safe */ _components_progress_indicator_progress_indicator__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "Search": () => (/* reexport safe */ _components_search_search__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "SideNav": () => (/* reexport safe */ _components_ui_shell_side_nav__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   "Slider": () => (/* reexport safe */ _components_slider_slider__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   "StructuredList": () => (/* reexport safe */ _components_structured_list_structured_list__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "Tab": () => (/* reexport safe */ _components_tabs_tabs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "TextInput": () => (/* reexport safe */ _components_text_input_text_input__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   "Tile": () => (/* reexport safe */ _components_tile_tile__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   "Toolbar": () => (/* reexport safe */ _components_toolbar_toolbar__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "Tooltip": () => (/* reexport safe */ _components_tooltip_tooltip__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "TooltipSimple": () => (/* reexport safe */ _components_tooltip_tooltip_simple__WEBPACK_IMPORTED_MODULE_20__["default"])
/* harmony export */ });
/* harmony import */ var _components_checkbox_checkbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/checkbox/checkbox */ "../../node_modules/carbon-components/es/components/checkbox/checkbox.js");
/* harmony import */ var _components_file_uploader_file_uploader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/file-uploader/file-uploader */ "../../node_modules/carbon-components/es/components/file-uploader/file-uploader.js");
/* harmony import */ var _components_content_switcher_content_switcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/content-switcher/content-switcher */ "../../node_modules/carbon-components/es/components/content-switcher/content-switcher.js");
/* harmony import */ var _components_tabs_tabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/tabs/tabs */ "../../node_modules/carbon-components/es/components/tabs/tabs.js");
/* harmony import */ var _components_overflow_menu_overflow_menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/overflow-menu/overflow-menu */ "../../node_modules/carbon-components/es/components/overflow-menu/overflow-menu.js");
/* harmony import */ var _components_modal_modal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/modal/modal */ "../../node_modules/carbon-components/es/components/modal/modal.js");
/* harmony import */ var _components_loading_loading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/loading/loading */ "../../node_modules/carbon-components/es/components/loading/loading.js");
/* harmony import */ var _components_inline_loading_inline_loading__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/inline-loading/inline-loading */ "../../node_modules/carbon-components/es/components/inline-loading/inline-loading.js");
/* harmony import */ var _components_dropdown_dropdown__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../components/dropdown/dropdown */ "../../node_modules/carbon-components/es/components/dropdown/dropdown.js");
/* harmony import */ var _components_number_input_number_input__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../components/number-input/number-input */ "../../node_modules/carbon-components/es/components/number-input/number-input.js");
/* harmony import */ var _components_data_table_v2_data_table_v2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../components/data-table-v2/data-table-v2 */ "../../node_modules/carbon-components/es/components/data-table-v2/data-table-v2.js");
/* harmony import */ var _components_data_table_data_table__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../components/data-table/data-table */ "../../node_modules/carbon-components/es/components/data-table/data-table.js");
/* harmony import */ var _components_date_picker_date_picker__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../components/date-picker/date-picker */ "../../node_modules/carbon-components/es/components/date-picker/date-picker.js");
/* harmony import */ var _components_pagination_pagination__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../components/pagination/pagination */ "../../node_modules/carbon-components/es/components/pagination/pagination.js");
/* harmony import */ var _components_search_search__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../components/search/search */ "../../node_modules/carbon-components/es/components/search/search.js");
/* harmony import */ var _components_accordion_accordion__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../components/accordion/accordion */ "../../node_modules/carbon-components/es/components/accordion/accordion.js");
/* harmony import */ var _components_copy_button_copy_button__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../components/copy-button/copy-button */ "../../node_modules/carbon-components/es/components/copy-button/copy-button.js");
/* harmony import */ var _components_notification_notification__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../components/notification/notification */ "../../node_modules/carbon-components/es/components/notification/notification.js");
/* harmony import */ var _components_toolbar_toolbar__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../components/toolbar/toolbar */ "../../node_modules/carbon-components/es/components/toolbar/toolbar.js");
/* harmony import */ var _components_tooltip_tooltip__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../components/tooltip/tooltip */ "../../node_modules/carbon-components/es/components/tooltip/tooltip.js");
/* harmony import */ var _components_tooltip_tooltip_simple__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../components/tooltip/tooltip--simple */ "../../node_modules/carbon-components/es/components/tooltip/tooltip--simple.js");
/* harmony import */ var _components_progress_indicator_progress_indicator__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../components/progress-indicator/progress-indicator */ "../../node_modules/carbon-components/es/components/progress-indicator/progress-indicator.js");
/* harmony import */ var _components_floating_menu_floating_menu__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../components/floating-menu/floating-menu */ "../../node_modules/carbon-components/es/components/floating-menu/floating-menu.js");
/* harmony import */ var _components_structured_list_structured_list__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../components/structured-list/structured-list */ "../../node_modules/carbon-components/es/components/structured-list/structured-list.js");
/* harmony import */ var _components_slider_slider__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../components/slider/slider */ "../../node_modules/carbon-components/es/components/slider/slider.js");
/* harmony import */ var _components_tile_tile__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../components/tile/tile */ "../../node_modules/carbon-components/es/components/tile/tile.js");
/* harmony import */ var _components_code_snippet_code_snippet__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../components/code-snippet/code-snippet */ "../../node_modules/carbon-components/es/components/code-snippet/code-snippet.js");
/* harmony import */ var _components_text_input_text_input__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../components/text-input/text-input */ "../../node_modules/carbon-components/es/components/text-input/text-input.js");
/* harmony import */ var _components_ui_shell_side_nav__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../components/ui-shell/side-nav */ "../../node_modules/carbon-components/es/components/ui-shell/side-nav.js");
/* harmony import */ var _components_ui_shell_header_submenu__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../../components/ui-shell/header-submenu */ "../../node_modules/carbon-components/es/components/ui-shell/header-submenu.js");
/* harmony import */ var _components_ui_shell_header_nav__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../../components/ui-shell/header-nav */ "../../node_modules/carbon-components/es/components/ui-shell/header-nav.js");
/* harmony import */ var _components_ui_shell_navigation_menu__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../../components/ui-shell/navigation-menu */ "../../node_modules/carbon-components/es/components/ui-shell/navigation-menu.js");
/* harmony import */ var _components_ui_shell_product_switcher__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../../components/ui-shell/product-switcher */ "../../node_modules/carbon-components/es/components/ui-shell/product-switcher.js");
/* harmony import */ var _components_pagination_nav_pagination_nav__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../../components/pagination-nav/pagination-nav */ "../../node_modules/carbon-components/es/components/pagination-nav/pagination-nav.js");
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */



































/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/event-matches.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ eventMatches)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * @param {Event} event The event.
 * @param {string} selector The selector.
 * @returns {Element}
 *   The closest ancestor of the event target (or the event target itself) which matches the selectors given in parameter.
 */
function eventMatches(event, selector) {
  // <svg> in IE does not have `Element#msMatchesSelector()` (that should be copied to `Element#matches()` by a polyfill).
  // Also a weird behavior is seen in IE where DOM tree seems broken when `event.target` is on <svg>.
  // Therefore this function simply returns `undefined` when `event.target` is on <svg>.
  var target = event.target,
      currentTarget = event.currentTarget;

  if (typeof target.matches === 'function') {
    if (target.matches(selector)) {
      // If event target itself matches the given selector, return it
      return target;
    }

    if (target.matches("".concat(selector, " *"))) {
      var closest = target.closest(selector);

      if ((currentTarget.nodeType === Node.DOCUMENT_NODE ? currentTarget.documentElement : currentTarget).contains(closest)) {
        return closest;
      }
    }
  }

  return undefined;
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/get-launching-details.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/get-launching-details.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLaunchingDetails)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
function getLaunchingDetails(evt) {
  if (!evt || typeof evt === 'function') {
    return {
      launchingElement: null,
      launchingEvent: null
    };
  }

  var launchingElement = evt.delegateTarget || evt.currentTarget || evt;
  var launchingEvent = evt.currentTarget && evt;

  if (launchingElement && !launchingElement.nodeType) {
    throw new TypeError('DOM Node should be given for launching element.');
  }

  if (launchingEvent && !launchingEvent.type) {
    throw new TypeError('DOM event should be given for launching event.');
  }

  return {
    launchingElement: launchingElement,
    launchingEvent: launchingEvent
  };
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/mixin.js":
/*!************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/mixin.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mixin)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * @param {Array} a An array.
 * @returns {Array} The flattened version of the given array.
 */


function flatten(a) {
  return a.reduce(function (result, item) {
    if (Array.isArray(item)) {
      result.push.apply(result, _toConsumableArray(flatten(item)));
    } else {
      result.push(item);
    }

    return result;
  }, []);
}
/**
 * An interface for defining mix-in classes. Used with {@link mixin}.
 * @function mixinfn
 * @param {Class} ToMix The class to mix.
 * @returns {Class} The class mixed-in with the given ToMix class.
 */

/**
 * @function mixin
 * @param {...mixinfn} mixinfns The functions generating mix-ins.
 * @returns {Class} The class generated with the given mix-ins.
 */


function mixin() {
  for (var _len = arguments.length, mixinfns = new Array(_len), _key = 0; _key < _len; _key++) {
    mixinfns[_key] = arguments[_key];
  }

  return flatten(mixinfns).reduce(function (Class, mixinfn) {
    return mixinfn(Class);
  }, /*#__PURE__*/function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }());
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/on-focus-by-keyboard.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/on-focus-by-keyboard.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onFocusByKeyboard)
/* harmony export */ });
/**
 * Differentiate between keyboard and mouse-triggered focusout/blur events
 * @param {Element} node  The element to attach event listeners to
 * @param {string} name The event name to listen to
 * @param {Function} callback The callback function to invoke
 * @returns {Handle} The handle to release the attached event handler
 */
function onFocusByKeyboard(node, name, callback) {
  var hasFocusout = ('onfocusout' in window);
  var focusinEventName = hasFocusout ? 'focusin' : 'focus';
  var focusoutEventName = hasFocusout ? 'focusout' : 'blur';
  /**
   * Event types supported by this function
   * @type {object<string, string>}
   */

  var supportedEvents = {
    focus: focusinEventName,
    blur: focusoutEventName
  };
  var eventName = supportedEvents[name];

  if (!eventName) {
    throw new Error('Unsupported event!');
  }

  var clicked;

  var handleMousedown = function handleMousedown() {
    clicked = true;
    requestAnimationFrame(function () {
      clicked = false;
    });
  };

  var handleFocusin = function handleFocusin(evt) {
    if (!clicked) {
      callback(evt);
    }
  };

  node.ownerDocument.addEventListener('mousedown', handleMousedown);
  node.addEventListener(eventName, handleFocusin, !hasFocusout);
  return {
    release: function release() {
      if (handleFocusin) {
        node.removeEventListener(eventName, handleFocusin, !hasFocusout);
        handleFocusin = null;
      }

      if (handleMousedown) {
        node.ownerDocument.removeEventListener('mousedown', handleMousedown);
        handleMousedown = null;
      }

      return null;
    }
  };
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/on.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/on.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ on)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
function on(element) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  element.addEventListener.apply(element, args);
  return {
    release: function release() {
      element.removeEventListener.apply(element, args);
      return null;
    }
  };
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/resize.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/resize.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
// mdn resize function
var optimizedResize = /* #__PURE__ */function optimizedResize() {
  var callbacks = [];
  var running = false; // run the actual callbacks

  function runCallbacks() {
    callbacks.forEach(function (callback) {
      callback();
    });
    running = false;
  } // fired on resize event


  function resize() {
    if (!running) {
      running = true;
      window.requestAnimationFrame(runCallbacks);
    }
  } // adds callback to loop


  function addCallback(callback) {
    if (callback) {
      var index = callbacks.indexOf(callback);

      if (index < 0) {
        callbacks.push(callback);
      }
    }
  }

  return {
    // public method to add additional callback
    add: function add(callback) {
      if (!callbacks.length) {
        window.addEventListener('resize', resize);
      }

      addCallback(callback);
      return {
        release: function release() {
          var index = callbacks.indexOf(callback);

          if (index >= 0) {
            callbacks.splice(index, 1);
          }
        }
      };
    }
  };
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (optimizedResize);

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/svg-toggle-class.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/svg-toggle-class.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */


function svgToggleClass(svg, name, forceAdd) {
  var list = svg.getAttribute('class').trim().split(/\s+/);
  var uniqueList = Object.keys(list.reduce(function (o, item) {
    return Object.assign(o, _defineProperty({}, item, 1));
  }, {}));
  var index = uniqueList.indexOf(name);
  var found = index >= 0;
  var add = forceAdd === undefined ? !found : forceAdd;

  if (found === !add) {
    if (add) {
      uniqueList.push(name);
    } else {
      uniqueList.splice(index, 1);
    }

    svg.setAttribute('class', uniqueList.join(' '));
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (svgToggleClass);

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/misc/toggle-attribute.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/misc/toggle-attribute.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toggleAttribute)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Toggles the given attribute of the given element.
 * @param {Element} elem The element.
 * @param {string} name The attribute name.
 * @param {boolean} add `true` to set the attribute.
 */
function toggleAttribute(elem, name, add) {
  if (add) {
    elem.setAttribute(name, '');
  } else {
    elem.removeAttribute(name);
  }
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/create-component.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/create-component.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(ToMix) {
  var CreateComponent = /*#__PURE__*/function (_ToMix) {
    _inherits(CreateComponent, _ToMix);

    var _super = _createSuper(CreateComponent);
    /**
     * The component instances managed by this component.
     * Releasing this component also releases the components in `this.children`.
     * @type {Component[]}
     */

    /**
     * Mix-in class to manage lifecycle of component.
     * The constructor sets up this component's effective options,
     * and registers this component't instance associated to an element.
     * @implements Handle
     * @param {HTMLElement} element The element working as this component.
     * @param {object} [options] The component options.
     */


    function CreateComponent(element) {
      var _this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, CreateComponent);

      _this = _super.call(this, element, options);
      _this.children = [];

      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        throw new TypeError('DOM element should be given to initialize this widget.');
      }
      /**
       * The element the component is of.
       * @type {Element}
       */


      _this.element = element;
      /**
       * The component options.
       * @type {object}
       */

      _this.options = Object.assign(Object.create(_this.constructor.options), options);

      _this.constructor.components.set(_this.element, _assertThisInitialized(_this));

      return _this;
    }
    /**
     * Instantiates this component of the given element.
     * @param {HTMLElement} element The element.
     */


    _createClass(CreateComponent, [{
      key: "release",
      value:
      /**
       * Releases this component's instance from the associated element.
       */
      function release() {
        for (var child = this.children.pop(); child; child = this.children.pop()) {
          child.release();
        }

        this.constructor.components.delete(this.element);
        return null;
      }
    }], [{
      key: "create",
      value: function create(element, options) {
        return this.components.get(element) || new this(element, options);
      }
    }]);

    return CreateComponent;
  }(ToMix);

  return CreateComponent;
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/evented-show-hide-state.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/evented-show-hide-state.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _evented_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./evented-state */ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js");
/* harmony import */ var _misc_get_launching_details__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/get-launching-details */ "../../node_modules/carbon-components/es/globals/js/misc/get-launching-details.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */





function eventedShowHideState(ToMix) {
  /**
   * Mix-in class to launch a floating menu.
   * @class EventedShowHideState
   */
  var EventedShowHideState = /*#__PURE__*/function (_ToMix) {
    _inherits(EventedShowHideState, _ToMix);

    var _super = _createSuper(EventedShowHideState);

    function EventedShowHideState() {
      _classCallCheck(this, EventedShowHideState);

      return _super.apply(this, arguments);
    }

    _createClass(EventedShowHideState, [{
      key: "show",
      value:
      /**
       */

      /**
       * Switch to 'shown' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */
      function show(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === 'function') {
          callback = evtOrElem; // eslint-disable-line no-param-reassign
        }

        this.changeState('shown', (0,_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_0__["default"])(evtOrElem), callback);
      }
      /**
       * Switch to 'hidden' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */

    }, {
      key: "hide",
      value: function hide(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === 'function') {
          callback = evtOrElem; // eslint-disable-line no-param-reassign
        }

        this.changeState('hidden', (0,_misc_get_launching_details__WEBPACK_IMPORTED_MODULE_0__["default"])(evtOrElem), callback);
      }
    }]);

    return EventedShowHideState;
  }(ToMix);

  return EventedShowHideState;
}

var exports = [_evented_state__WEBPACK_IMPORTED_MODULE_1__["default"], eventedShowHideState];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/evented-state.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(ToMix) {
  /**
   * Mix-in class to manage events associated with states.
   * @class EventedState
   */
  var EventedState = /*#__PURE__*/function (_ToMix) {
    _inherits(EventedState, _ToMix);

    var _super = _createSuper(EventedState);

    function EventedState() {
      _classCallCheck(this, EventedState);

      return _super.apply(this, arguments);
    }

    _createClass(EventedState, [{
      key: "_changeState",
      value:
      /* eslint-disable jsdoc/check-param-names */

      /**
       * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
       * @private
       */
      function _changeState() {
        throw new Error('_changeState() should be overriden to perform actual change in state.');
      }
      /**
       * Changes the state of this component.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
       */

    }, {
      key: "changeState",
      value: function changeState() {
        var _this = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var state = typeof args[0] === 'string' ? args.shift() : undefined;
        var detail = Object(args[0]) === args[0] && typeof args[0] !== 'function' ? args.shift() : undefined;
        var callback = typeof args[0] === 'function' ? args.shift() : undefined;

        if (typeof this.shouldStateBeChanged === 'function' && !this.shouldStateBeChanged(state, detail)) {
          if (callback) {
            callback(null, true);
          }

          return;
        }

        var data = {
          group: detail && detail.group,
          state: state
        };
        var eventNameSuffix = [data.group, state].filter(Boolean).join('-').split('-') // Group or state may contain hyphen
        .map(function (item) {
          return item[0].toUpperCase() + item.substr(1);
        }).join('');
        var eventStart = new CustomEvent(this.options["eventBefore".concat(eventNameSuffix)], {
          bubbles: true,
          cancelable: true,
          detail: detail
        });
        var fireOnNode = detail && detail.delegatorNode || this.element;
        var canceled = !fireOnNode.dispatchEvent(eventStart);

        if (canceled) {
          if (callback) {
            var error = new Error("Changing state (".concat(JSON.stringify(data), ") has been canceled."));
            error.canceled = true;
            callback(error);
          }
        } else {
          var changeStateArgs = [state, detail].filter(Boolean);

          this._changeState.apply(this, _toConsumableArray(changeStateArgs).concat([function () {
            fireOnNode.dispatchEvent(new CustomEvent(_this.options["eventAfter".concat(eventNameSuffix)], {
              bubbles: true,
              cancelable: true,
              detail: detail
            }));

            if (callback) {
              callback();
            }
          }]));
        }
      }
      /* eslint-enable jsdoc/check-param-names */

      /**
       * Tests if change in state should happen or not.
       * Classes inheriting {@link EventedState `EventedState`} should override this function.
       * @function EventedState#shouldStateBeChanged
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @returns {boolean}
       *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
       */

    }]);

    return EventedState;
  }(ToMix);
  /**
   * The callback called once changing state is finished or is canceled.
   * @callback EventedState~changeStateCallback
   * @param {Error} error
   *   An error object with `true` in its `canceled` property if changing state is canceled.
   *   Cancellation happens if the handler of a custom event, that is fired before changing state happens,
   *   calls `.preventDefault()` against the event.
   * @param {boolean} keptState
   *   `true` if the call to {@link EventedState#changeState `.changeState()`} didn't cause actual change in state.
   */


  return EventedState;
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/handles.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(ToMix) {
  /**
   * Mix-in class to manage handles in component.
   * Managed handles are automatically released when the component with this class mixed in is released.
   * @class Handles
   * @implements Handle
   */
  var Handles = /*#__PURE__*/function (_ToMix) {
    _inherits(Handles, _ToMix);

    var _super = _createSuper(Handles);

    function Handles() {
      var _this;

      _classCallCheck(this, Handles);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.handles = new Set();
      return _this;
    }

    _createClass(Handles, [{
      key: "manage",
      value:
      /**
       * Manages the given handle.
       * @param {Handle} handle The handle to manage.
       * @returns {Handle} The given handle.
       */
      function manage(handle) {
        this.handles.add(handle);
        return handle;
      }
      /**
       * Stop managing the given handle.
       * @param {Handle} handle The handle to stop managing.
       * @returns {Handle} The given handle.
       */

    }, {
      key: "unmanage",
      value: function unmanage(handle) {
        this.handles.delete(handle);
        return handle;
      }
    }, {
      key: "release",
      value: function release() {
        var _this2 = this;

        this.handles.forEach(function (handle) {
          handle.release();

          _this2.handles.delete(handle);
        });
        return _get(_getPrototypeOf(Handles.prototype), "release", this).call(this);
      }
    }]);

    return Handles;
  }(ToMix);

  return Handles;
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-event.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-event.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(ToMix) {
  /**
   * Mix-in class to instantiate components upon events.
   * @class InitComponentByEvent
   */
  var InitComponentByEvent = /*#__PURE__*/function (_ToMix) {
    _inherits(InitComponentByEvent, _ToMix);

    var _super = _createSuper(InitComponentByEvent);

    function InitComponentByEvent() {
      _classCallCheck(this, InitComponentByEvent);

      return _super.apply(this, arguments);
    }

    _createClass(InitComponentByEvent, null, [{
      key: "init",
      value:
      /**
       * `true` suggests that this component is lazily initialized upon an action/event, etc.
       * @type {boolean}
       */

      /**
       * Instantiates this component in the given element.
       * If the given element indicates that it's an component of this class, instantiates it.
       * Otherwise, instantiates this component by clicking on this component in the given node.
       * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
       * @param {object} [options] The component options.
       * @param {string} [options.selectorInit] The CSS selector to find this component.
       * @returns {Handle} The handle to remove the event listener to handle clicking.
       */
      function init() {
        var _this = this;

        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var effectiveOptions = Object.assign(Object.create(this.options), options);

        if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');
        }

        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options);
        } else {
          // To work around non-bubbling `focus` event, use `focusin` event instead of it's available, and "capture mode" otherwise
          var hasFocusin = ('onfocusin' in (target.nodeType === Node.ELEMENT_NODE ? target.ownerDocument : target).defaultView);
          var handles = effectiveOptions.initEventNames.map(function (name) {
            var eventName = name === 'focus' && hasFocusin ? 'focusin' : name;
            return (0,_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(target, eventName, function (event) {
              var element = (0,_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, effectiveOptions.selectorInit); // Instantiated components handles events by themselves

              if (element && !_this.components.has(element)) {
                var component = _this.create(element, options);

                if (typeof component.createdByEvent === 'function') {
                  component.createdByEvent(event);
                }
              }
            }, name === 'focus' && !hasFocusin);
          });
          return {
            release: function release() {
              for (var handle = handles.pop(); handle; handle = handles.pop()) {
                handle.release();
              }
            }
          };
        }

        return '';
      }
    }]);

    InitComponentByEvent.forLazyInit = true;
    return InitComponentByEvent;
  }(ToMix);

  return InitComponentByEvent;
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-launcher.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-launcher.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _misc_event_matches__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc/event-matches */ "../../node_modules/carbon-components/es/globals/js/misc/event-matches.js");
/* harmony import */ var _misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(ToMix) {
  /**
   * Mix-in class to instantiate components events on launcher button.
   * @class InitComponentByLauncher
   */
  var InitComponentByLauncher = /*#__PURE__*/function (_ToMix) {
    _inherits(InitComponentByLauncher, _ToMix);

    var _super = _createSuper(InitComponentByLauncher);

    function InitComponentByLauncher() {
      _classCallCheck(this, InitComponentByLauncher);

      return _super.apply(this, arguments);
    }

    _createClass(InitComponentByLauncher, null, [{
      key: "init",
      value:
      /**
       * `true` suggests that this component is lazily initialized upon an action/event, etc.
       * @type {boolean}
       */

      /**
       * Instantiates this component in the given element.
       * If the given element indicates that it's an component of this class, instantiates it.
       * Otherwise, instantiates this component by clicking on launcher buttons
       * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
       * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
       * @param {object} [options] The component options.
       * @param {string} [options.selectorInit] The CSS selector to find this component.
       * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
       * @returns {Handle} The handle to remove the event listener to handle clicking.
       */
      function init() {
        var _this = this;

        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var effectiveOptions = Object.assign(Object.create(this.options), options);

        if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');
        }

        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options);
        } else {
          var handles = effectiveOptions.initEventNames.map(function (name) {
            return (0,_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(target, name, function (event) {
              var launcher = (0,_misc_event_matches__WEBPACK_IMPORTED_MODULE_1__["default"])(event, "[".concat(effectiveOptions.attribInitTarget, "]"));

              if (launcher) {
                event.delegateTarget = launcher; // eslint-disable-line no-param-reassign

                var elements = launcher.ownerDocument.querySelectorAll(launcher.getAttribute(effectiveOptions.attribInitTarget));

                if (elements.length > 1) {
                  throw new Error('Target widget must be unique.');
                }

                if (elements.length === 1) {
                  if (launcher.tagName === 'A') {
                    event.preventDefault();
                  }

                  var component = _this.create(elements[0], options);

                  if (typeof component.createdByLauncher === 'function') {
                    component.createdByLauncher(event);
                  }
                }
              }
            });
          });
          return {
            release: function release() {
              for (var handle = handles.pop(); handle; handle = handles.pop()) {
                handle.release();
              }
            }
          };
        }

        return '';
      }
    }]);

    InitComponentByLauncher.forLazyInit = true;
    return InitComponentByLauncher;
  }(ToMix);

  return InitComponentByLauncher;
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/init-component-by-search.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(ToMix) {
  /**
   * Mix-in class to instantiate components by searching for their root elements.
   * @class InitComponentBySearch
   */
  var InitComponentBySearch = /*#__PURE__*/function (_ToMix) {
    _inherits(InitComponentBySearch, _ToMix);

    var _super = _createSuper(InitComponentBySearch);

    function InitComponentBySearch() {
      _classCallCheck(this, InitComponentBySearch);

      return _super.apply(this, arguments);
    }

    _createClass(InitComponentBySearch, null, [{
      key: "init",
      value:
      /**
       * Instantiates component in the given node.
       * If the given element indicates that it's an component of this class, instantiates it.
       * Otherwise, instantiates components by searching for components in the given node.
       * @param {Node} target The DOM node to instantiate components in. Should be a document or an element.
       * @param {object} [options] The component options.
       * @param {boolean} [options.selectorInit] The CSS selector to find components.
       */
      function init() {
        var _this = this;

        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var effectiveOptions = Object.assign(Object.create(this.options), options);

        if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new TypeError('DOM document or DOM element should be given to search for and initialize this widget.');
        }

        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options);
        } else {
          Array.prototype.forEach.call(target.querySelectorAll(effectiveOptions.selectorInit), function (element) {
            return _this.create(element, options);
          });
        }
      }
    }]);

    return InitComponentBySearch;
  }(ToMix);

  return InitComponentBySearch;
}

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/mixins/track-blur.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/mixins/track-blur.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _misc_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/on */ "../../node_modules/carbon-components/es/globals/js/misc/on.js");
/* harmony import */ var _handles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./handles */ "../../node_modules/carbon-components/es/globals/js/mixins/handles.js");
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */





function trackBlur(ToMix) {
  var TrackBlur = /*#__PURE__*/function (_ToMix) {
    _inherits(TrackBlur, _ToMix);

    var _super = _createSuper(TrackBlur);
    /**
     * Mix-in class to add an handler for losing focus.
     * @extends Handles
     * @param {HTMLElement} element The element working as this component.
     * @param {object} [options] The component options.
     */


    function TrackBlur(element, options) {
      var _this;

      _classCallCheck(this, TrackBlur);

      _this = _super.call(this, element, options);
      var hasFocusin = ('onfocusin' in window);
      var focusinEventName = hasFocusin ? 'focusin' : 'focus';
      var focusoutEventName = hasFocusin ? 'focusout' : 'blur';

      _this.manage((0,_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, focusinEventName, function (event) {
        if (!(_this.options.contentNode || _this.element).contains(event.target)) {
          _this.handleBlur(event);
        }
      }, !hasFocusin));

      _this.manage((0,_misc_on__WEBPACK_IMPORTED_MODULE_0__["default"])(_this.element.ownerDocument, focusoutEventName, function (event) {
        if (!event.relatedTarget) {
          _this.handleBlur(event);
        }
      }, !hasFocusin));

      return _this;
    }
    /**
     * The method called when this component loses focus.
     * @abstract
     */


    _createClass(TrackBlur, [{
      key: "handleBlur",
      value: function handleBlur() {
        throw new Error('Components inheriting TrackBlur mix-in must implement handleBlur() method.');
      }
    }]);

    return TrackBlur;
  }(ToMix);

  return TrackBlur;
}

var exports = [_handles__WEBPACK_IMPORTED_MODULE_1__["default"], trackBlur];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ }),

/***/ "../../node_modules/carbon-components/es/globals/js/settings.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/carbon-components/es/globals/js/settings.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Settings.
 * @exports CarbonComponents.settings
 * @type Object
 * @property {boolean} [disableAutoInit]
 *   Disables automatic instantiation of components.
 *   By default (`CarbonComponents.disableAutoInit` is `false`),
 *   carbon-components attempts to instantiate components automatically
 *   by searching for elements with `data-component-name` (e.g. `data-loading`) attribute
 *   or upon DOM events (e.g. clicking) on such elements.
 *   See each components' static `.init()` methods for details.
 * @property {string} [prefix=bx]
 *   Brand prefix. Should be in sync with `$prefix` Sass variable in carbon-components/src/globals/scss/_vars.scss.
 * // @todo given that the default value is so long, is it appropriate to put in the JSDoc?
 * @property {string} [selectorTabbable]
 *   A selector selecting tabbable/focusable nodes.
 *   By default selectorTabbable references links, areas, inputs, buttons, selects, textareas,
 *   iframes, objects, embeds, or elements explicitly using tabindex or contenteditable attributes
 *   as long as the element is not `disabled` or the `tabindex="-1"`.
 * @property {string} [selectorFocusable]
 *   CSS selector that selects major nodes that are click focusable
 *   This property is identical to selectorTabbable with the exception of
 *   the `:not([tabindex='-1'])` pseudo class
 */
var settings = {
  prefix: 'bx',
  selectorTabbable: "\n    a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n    textarea:not([disabled]):not([tabindex='-1']),\n    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\n  ",
  selectorFocusable: "\n    a[href], area[href], input:not([disabled]),\n    button:not([disabled]),select:not([disabled]),\n    textarea:not([disabled]),\n    iframe, object, embed, *[tabindex], *[contenteditable=true]\n  "
};
var settings_1 = settings;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (settings_1);

/***/ }),

/***/ "../../node_modules/carbon-components/es/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/carbon-components/es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Accordion": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Accordion),
/* harmony export */   "Checkbox": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Checkbox),
/* harmony export */   "CodeSnippet": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.CodeSnippet),
/* harmony export */   "ContentSwitcher": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.ContentSwitcher),
/* harmony export */   "CopyButton": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.CopyButton),
/* harmony export */   "DataTable": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.DataTable),
/* harmony export */   "DataTableV2": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.DataTableV2),
/* harmony export */   "DatePicker": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.DatePicker),
/* harmony export */   "Dropdown": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Dropdown),
/* harmony export */   "FileUploader": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.FileUploader),
/* harmony export */   "FloatingMenu": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.FloatingMenu),
/* harmony export */   "HeaderNav": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.HeaderNav),
/* harmony export */   "HeaderSubmenu": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.HeaderSubmenu),
/* harmony export */   "InlineLoading": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.InlineLoading),
/* harmony export */   "Loading": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Loading),
/* harmony export */   "Modal": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Modal),
/* harmony export */   "NavigationMenu": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.NavigationMenu),
/* harmony export */   "Notification": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Notification),
/* harmony export */   "NumberInput": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.NumberInput),
/* harmony export */   "OverflowMenu": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.OverflowMenu),
/* harmony export */   "Pagination": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Pagination),
/* harmony export */   "PaginationNav": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.PaginationNav),
/* harmony export */   "ProductSwitcher": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.ProductSwitcher),
/* harmony export */   "ProgressIndicator": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.ProgressIndicator),
/* harmony export */   "Search": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Search),
/* harmony export */   "SideNav": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.SideNav),
/* harmony export */   "Slider": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Slider),
/* harmony export */   "StructuredList": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.StructuredList),
/* harmony export */   "Tab": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Tab),
/* harmony export */   "TextInput": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.TextInput),
/* harmony export */   "Tile": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Tile),
/* harmony export */   "Toolbar": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Toolbar),
/* harmony export */   "Tooltip": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.Tooltip),
/* harmony export */   "TooltipSimple": () => (/* reexport safe */ _globals_js_components__WEBPACK_IMPORTED_MODULE_0__.TooltipSimple),
/* harmony export */   "settings": () => (/* reexport safe */ _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _globals_js_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals/js/components */ "../../node_modules/carbon-components/es/globals/js/components.js");
/* harmony import */ var _globals_js_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals/js/settings */ "../../node_modules/carbon-components/es/globals/js/settings.js");
/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
// ====================//
// Imports and Exports //
// ====================//
// Base Elements & Components
// -------------
// - JavaScript classes for use with components and base-elements.
// - The following statements import classes from actual locations to
//   be consumed from this file instead of their actual locations.



/***/ }),

/***/ "../../node_modules/carbon-components/node_modules/flatpickr/dist/flatpickr.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/carbon-components/node_modules/flatpickr/dist/flatpickr.js ***!
  \*************************************************************************************/
/***/ (function(module) {

/* flatpickr v4.6.1, @license MIT */
(function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition",
    ];
    var defaults = {
        _disable: [],
        _enable: [],
        allowInput: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" &&
            window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enable: [],
        enableSeconds: false,
        enableTime: false,
        errorHandler: function (err) {
            return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function (givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            // Thursday in current week decides the year.
            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
            // January 4 is always in week 1.
            var week1 = new Date(date.getFullYear(), 0, 4);
            // Adjust to Thursday in week 1 and count number of weeks from date to week1.
            return (1 +
                Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                    3 +
                    ((week1.getDay() + 6) % 7)) /
                    7));
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
    };

    var english = {
        weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ]
        },
        months: {
            shorthand: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ],
            longhand: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function (nth) {
            var s = nth % 100;
            if (s > 3 && s < 21)
                return "th";
            switch (s % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th";
            }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        time_24hr: false
    };

    var pad = function (number) { return ("0" + number).slice(-2); };
    var int = function (bool) { return (bool === true ? 1 : 0); };
    /* istanbul ignore next */
    function debounce(func, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        var timeout;
        return function () {
            var context = this, args = arguments;
            timeout !== null && clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            }, wait);
            if (immediate && !timeout)
                func.apply(context, args);
        };
    }
    var arrayify = function (obj) {
        return obj instanceof Array ? obj : [obj];
    };

    function toggleClass(elem, className, bool) {
        if (bool === true)
            return elem.classList.add(className);
        elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined)
            e.textContent = content;
        return e;
    }
    function clearNode(node) {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    }
    function findParent(node, condition) {
        if (condition(node))
            return node;
        else if (node.parentNode)
            return findParent(node.parentNode, condition);
        return undefined; // nothing found
    }
    function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
        }
        else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
        }
        if (opts !== undefined)
            for (var key in opts)
                numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
    }
    function getEventTarget(event) {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    }

    var doNothing = function () { return undefined; };
    var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
    var revFormat = {
        D: doNothing,
        F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        H: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        J: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        K: function (dateObj, amPM, locale) {
            dateObj.setHours((dateObj.getHours() % 12) +
                12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
        W: function (dateObj, weekNum, locale) {
            var weekNumber = parseInt(weekNum);
            var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
            date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
            return date;
        },
        Y: function (dateObj, year) {
            dateObj.setFullYear(parseFloat(year));
        },
        Z: function (_, ISODate) { return new Date(ISODate); },
        d: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        h: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        i: function (dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes));
        },
        j: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        l: doNothing,
        m: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        u: function (_, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds));
        },
        w: doNothing,
        y: function (dateObj, year) {
            dateObj.setFullYear(2000 + parseFloat(year));
        }
    };
    var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
    };
    var formats = {
        // get the date in UTC
        Z: function (date) { return date.toISOString(); },
        // weekday name, short, e.g. Thu
        D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        // full month name e.g. January
        F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        // padded hour 1-12
        G: function (date, locale, options) {
            return pad(formats.h(date, locale, options));
        },
        // hours with leading zero e.g. 03
        H: function (date) { return pad(date.getHours()); },
        // day (1-30) with ordinal suffix e.g. 1st, 2nd
        J: function (date, locale) {
            return locale.ordinal !== undefined
                ? date.getDate() + locale.ordinal(date.getDate())
                : date.getDate();
        },
        // AM/PM
        K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
        // shorthand month e.g. Jan, Sep, Oct, etc
        M: function (date, locale) {
            return monthToStr(date.getMonth(), true, locale);
        },
        // seconds 00-59
        S: function (date) { return pad(date.getSeconds()); },
        // unix timestamp
        U: function (date) { return date.getTime() / 1000; },
        W: function (date, _, options) {
            return options.getWeek(date);
        },
        // full year e.g. 2016
        Y: function (date) { return date.getFullYear(); },
        // day in month, padded (01-30)
        d: function (date) { return pad(date.getDate()); },
        // hour from 1-12 (am/pm)
        h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
        // minutes, padded with leading zero e.g. 09
        i: function (date) { return pad(date.getMinutes()); },
        // day in month (1-30)
        j: function (date) { return date.getDate(); },
        // weekday name, full, e.g. Thursday
        l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()];
        },
        // padded month number (01-12)
        m: function (date) { return pad(date.getMonth() + 1); },
        // the month number (1-12)
        n: function (date) { return date.getMonth() + 1; },
        // seconds 0-59
        s: function (date) { return date.getSeconds(); },
        // Unix Milliseconds
        u: function (date) { return date.getTime(); },
        // number of the day of the week
        w: function (date) { return date.getDay(); },
        // last two digits of year e.g. 16 for 2016
        y: function (date) { return String(date.getFullYear()).substring(2); }
    };

    var createDateFormatter = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            if (config.formatDate !== undefined) {
                return config.formatDate(dateObj, frmt, locale);
            }
            return frmt
                .split("")
                .map(function (c, i, arr) {
                return formats[c] && arr[i - 1] !== "\\"
                    ? formats[c](dateObj, locale, config)
                    : c !== "\\"
                        ? c
                        : "";
            })
                .join("");
        };
    };
    var createDateParser = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (date, givenFormat, timeless, customLocale) {
            if (date !== 0 && !date)
                return undefined;
            var locale = customLocale || l10n;
            var parsedDate;
            var dateOrig = date;
            if (date instanceof Date)
                parsedDate = new Date(date.getTime());
            else if (typeof date !== "string" &&
                date.toFixed !== undefined // timestamp
            )
                // create a copy
                parsedDate = new Date(date);
            else if (typeof date === "string") {
                // date string
                var format = givenFormat || (config || defaults).dateFormat;
                var datestr = String(date).trim();
                if (datestr === "today") {
                    parsedDate = new Date();
                    timeless = true;
                }
                else if (/Z$/.test(datestr) ||
                    /GMT$/.test(datestr) // datestrings w/ timezone
                )
                    parsedDate = new Date(date);
                else if (config && config.parseDate)
                    parsedDate = config.parseDate(date, format);
                else {
                    parsedDate =
                        !config || !config.noCalendar
                            ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                            : new Date(new Date().setHours(0, 0, 0, 0));
                    var matched = void 0, ops = [];
                    for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                        var token_1 = format[i];
                        var isBackSlash = token_1 === "\\";
                        var escaped = format[i - 1] === "\\" || isBackSlash;
                        if (tokenRegex[token_1] && !escaped) {
                            regexStr += tokenRegex[token_1];
                            var match = new RegExp(regexStr).exec(date);
                            if (match && (matched = true)) {
                                ops[token_1 !== "Y" ? "push" : "unshift"]({
                                    fn: revFormat[token_1],
                                    val: match[++matchIndex]
                                });
                            }
                        }
                        else if (!isBackSlash)
                            regexStr += "."; // don't really care
                        ops.forEach(function (_a) {
                            var fn = _a.fn, val = _a.val;
                            return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                        });
                    }
                    parsedDate = matched ? parsedDate : undefined;
                }
            }
            /* istanbul ignore next */
            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                config.errorHandler(new Error("Invalid date provided: " + dateOrig));
                return undefined;
            }
            if (timeless === true)
                parsedDate.setHours(0, 0, 0, 0);
            return parsedDate;
        };
    };
    /**
     * Compute the difference in dates, measured in ms
     */
    function compareDates(date1, date2, timeless) {
        if (timeless === void 0) { timeless = true; }
        if (timeless !== false) {
            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                new Date(date2.getTime()).setHours(0, 0, 0, 0));
        }
        return date1.getTime() - date2.getTime();
    }
    var isBetween = function (ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    var duration = {
        DAY: 86400000
    };

    if (typeof Object.assign !== "function") {
        Object.assign = function (target) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!target) {
                throw TypeError("Cannot convert undefined or null to object");
            }
            var _loop_1 = function (source) {
                if (source) {
                    Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                }
            };
            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                var source = args_1[_a];
                _loop_1(source);
            }
            return target;
        };
    }

    var DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
        var self = {
            config: __assign({}, defaults, flatpickr.defaultConfig),
            l10n: english
        };
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        self._handlers = [];
        self.pluginElements = [];
        self.loadedPlugins = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;
        function setupHelperFunctions() {
            self.utils = {
                getDaysInMonth: function (month, yr) {
                    if (month === void 0) { month = self.currentMonth; }
                    if (yr === void 0) { yr = self.currentYear; }
                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                        return 29;
                    return self.l10n.daysInMonth[month];
                }
            };
        }
        function init() {
            self.element = self.input = element;
            self.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self.isMobile)
                build();
            bindEvents();
            if (self.selectedDates.length || self.config.noCalendar) {
                if (self.config.enableTime) {
                    setHoursFromDate(self.config.noCalendar
                        ? self.latestSelectedDateObj || self.config.minDate
                        : undefined);
                }
                updateValue(false);
            }
            setCalendarWidth();
            self.showTimeInput =
                self.selectedDates.length > 0 || self.config.noCalendar;
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            /* TODO: investigate this further
        
              Currently, there is weird positioning behavior in safari causing pages
              to scroll up. https://github.com/chmln/flatpickr/issues/563
        
              However, most browsers are not Safari and positioning is expensive when used
              in scale. https://github.com/chmln/flatpickr/issues/1096
            */
            if (!self.isMobile && isSafari) {
                positionCalendar();
            }
            triggerEvent("onReady");
        }
        function bindToInstance(fn) {
            return fn.bind(self);
        }
        function setCalendarWidth() {
            var config = self.config;
            if (config.weekNumbers === false && config.showMonths === 1)
                return;
            else if (config.noCalendar !== true) {
                window.requestAnimationFrame(function () {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (self.daysContainer !== undefined) {
                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width =
                            daysWidth +
                                (self.weekWrapper !== undefined
                                    ? self.weekWrapper.offsetWidth
                                    : 0) +
                                "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                });
            }
        }
        /**
         * The handler for all events targeting the time inputs
         */
        function updateTime(e) {
            if (self.selectedDates.length === 0) {
                setDefaultTime();
            }
            if (e !== undefined && e.type !== "blur") {
                timeWrapper(e);
            }
            var prevValue = self._input.value;
            setHoursFromInputs();
            updateValue();
            if (self._input.value !== prevValue) {
                self._debouncedChange();
            }
        }
        function ampm2military(hour, amPM) {
            return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
        }
        function military2ampm(hour) {
            switch (hour % 24) {
                case 0:
                case 12:
                    return 12;
                default:
                    return hour % 12;
            }
        }
        /**
         * Syncs the selected date object time with user's time input
         */
        function setHoursFromInputs() {
            if (self.hourElement === undefined || self.minuteElement === undefined)
                return;
            var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                ? (parseInt(self.secondElement.value, 10) || 0) % 60
                : 0;
            if (self.amPM !== undefined) {
                hours = ampm2military(hours, self.amPM.textContent);
            }
            var limitMinHours = self.config.minTime !== undefined ||
                (self.config.minDate &&
                    self.minDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                        0);
            var limitMaxHours = self.config.maxTime !== undefined ||
                (self.config.maxDate &&
                    self.maxDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                        0);
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours())
                    minutes = Math.max(minutes, minTime.getMinutes());
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Syncs time input values with a date
         */
        function setHoursFromDate(dateObj) {
            var date = dateObj || self.latestSelectedDateObj;
            if (date)
                setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
        function setDefaultHours() {
            var hours = self.config.defaultHour;
            var minutes = self.config.defaultMinute;
            var seconds = self.config.defaultSeconds;
            if (self.config.minDate !== undefined) {
                var minHr = self.config.minDate.getHours();
                var minMinutes = self.config.minDate.getMinutes();
                hours = Math.max(hours, minHr);
                if (hours === minHr)
                    minutes = Math.max(minMinutes, minutes);
                if (hours === minHr && minutes === minMinutes)
                    seconds = self.config.minDate.getSeconds();
            }
            if (self.config.maxDate !== undefined) {
                var maxHr = self.config.maxDate.getHours();
                var maxMinutes = self.config.maxDate.getMinutes();
                hours = Math.min(hours, maxHr);
                if (hours === maxHr)
                    minutes = Math.min(maxMinutes, minutes);
                if (hours === maxHr && minutes === maxMinutes)
                    seconds = self.config.maxDate.getSeconds();
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Sets the hours, minutes, and optionally seconds
         * of the latest selected date object and the
         * corresponding time inputs
         * @param {Number} hours the hour. whether its military
         *                 or am-pm gets inferred from config
         * @param {Number} minutes the minutes
         * @param {Number} seconds the seconds (optional)
         */
        function setHours(hours, minutes, seconds) {
            if (self.latestSelectedDateObj !== undefined) {
                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self.hourElement || !self.minuteElement || self.isMobile)
                return;
            self.hourElement.value = pad(!self.config.time_24hr
                ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                : hours);
            self.minuteElement.value = pad(minutes);
            if (self.amPM !== undefined)
                self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
            if (self.secondElement !== undefined)
                self.secondElement.value = pad(seconds);
        }
        /**
         * Handles the year input and incrementing events
         * @param {Event} event the keyup or increment event
         */
        function onYearInput(event) {
            var year = parseInt(event.target.value) + (event.delta || 0);
            if (year / 1000 > 1 ||
                (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                changeYear(year);
            }
        }
        /**
         * Essentially addEventListener + tracking
         * @param {Element} element the element to addEventListener to
         * @param {String} event the event name
         * @param {Function} handler the event handler
         */
        function bind(element, event, handler, options) {
            if (event instanceof Array)
                return event.forEach(function (ev) { return bind(element, ev, handler, options); });
            if (element instanceof Array)
                return element.forEach(function (el) { return bind(el, event, handler, options); });
            element.addEventListener(event, handler, options);
            self._handlers.push({
                element: element,
                event: event,
                handler: handler,
                options: options
            });
        }
        /**
         * A mousedown handler which mimics click.
         * Minimizes latency, since we don't need to wait for mouseup in most cases.
         * Also, avoids handling right clicks.
         *
         * @param {Function} handler the event handler
         */
        function onClick(handler) {
            return function (evt) {
                evt.which === 1 && handler(evt);
            };
        }
        function triggerChange() {
            triggerEvent("onChange");
        }
        /**
         * Adds all the necessary event listeners
         */
        function bindEvents() {
            if (self.config.wrap) {
                ["open", "close", "toggle", "clear"].forEach(function (evt) {
                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                        return bind(el, "click", self[evt]);
                    });
                });
            }
            if (self.isMobile) {
                setupMobile();
                return;
            }
            var debouncedResize = debounce(onResize, 50);
            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                bind(self.daysContainer, "mouseover", function (e) {
                    if (self.config.mode === "range")
                        onMouseOver(e.target);
                });
            bind(window.document.body, "keydown", onKeyDown);
            if (!self.config.inline && !self.config.static)
                bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== undefined)
                bind(window.document, "touchstart", documentClick);
            else
                bind(window.document, "mousedown", onClick(documentClick));
            bind(window.document, "focus", documentClick, { capture: true });
            if (self.config.clickOpens === true) {
                bind(self._input, "focus", self.open);
                bind(self._input, "mousedown", onClick(self.open));
            }
            if (self.daysContainer !== undefined) {
                bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                bind(self.monthNav, ["keyup", "increment"], onYearInput);
                bind(self.daysContainer, "mousedown", onClick(selectDate));
            }
            if (self.timeContainer !== undefined &&
                self.minuteElement !== undefined &&
                self.hourElement !== undefined) {
                var selText = function (e) {
                    return e.target.select();
                };
                bind(self.timeContainer, ["increment"], updateTime);
                bind(self.timeContainer, "blur", updateTime, { capture: true });
                bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                if (self.secondElement !== undefined)
                    bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                if (self.amPM !== undefined) {
                    bind(self.amPM, "mousedown", onClick(function (e) {
                        updateTime(e);
                        triggerChange();
                    }));
                }
            }
        }
        /**
         * Set the calendar view to a particular date.
         * @param {Date} jumpDate the date to set the view to
         * @param {boolean} triggerChange if change events should be triggered
         */
        function jumpToDate(jumpDate, triggerChange) {
            var jumpTo = jumpDate !== undefined
                ? self.parseDate(jumpDate)
                : self.latestSelectedDateObj ||
                    (self.config.minDate && self.config.minDate > self.now
                        ? self.config.minDate
                        : self.config.maxDate && self.config.maxDate < self.now
                            ? self.config.maxDate
                            : self.now);
            var oldYear = self.currentYear;
            var oldMonth = self.currentMonth;
            try {
                if (jumpTo !== undefined) {
                    self.currentYear = jumpTo.getFullYear();
                    self.currentMonth = jumpTo.getMonth();
                }
            }
            catch (e) {
                /* istanbul ignore next */
                e.message = "Invalid date supplied: " + jumpTo;
                self.config.errorHandler(e);
            }
            if (triggerChange && self.currentYear !== oldYear) {
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
            if (triggerChange &&
                (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
                triggerEvent("onMonthChange");
            }
            self.redraw();
        }
        /**
         * The up/down arrow handler for time inputs
         * @param {Event} e the click event
         */
        function timeIncrement(e) {
            if (~e.target.className.indexOf("arrow"))
                incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
        }
        /**
         * Increments/decrements the value of input associ-
         * ated with the up/down arrow by dispatching an
         * "increment" event on the input.
         *
         * @param {Event} e the click event
         * @param {Number} delta the diff (usually 1 or -1)
         * @param {Element} inputElem the input element
         */
        function incrementNumInput(e, delta, inputElem) {
            var target = e && e.target;
            var input = inputElem ||
                (target && target.parentNode && target.parentNode.firstChild);
            var event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
        }
        function build() {
            var fragment = window.document.createDocumentFragment();
            self.calendarContainer = createElement("div", "flatpickr-calendar");
            self.calendarContainer.tabIndex = -1;
            if (!self.config.noCalendar) {
                fragment.appendChild(buildMonthNav());
                self.innerContainer = createElement("div", "flatpickr-innerContainer");
                if (self.config.weekNumbers) {
                    var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                    self.innerContainer.appendChild(weekWrapper);
                    self.weekNumbers = weekNumbers;
                    self.weekWrapper = weekWrapper;
                }
                self.rContainer = createElement("div", "flatpickr-rContainer");
                self.rContainer.appendChild(buildWeekdays());
                if (!self.daysContainer) {
                    self.daysContainer = createElement("div", "flatpickr-days");
                    self.daysContainer.tabIndex = -1;
                }
                buildDays();
                self.rContainer.appendChild(self.daysContainer);
                self.innerContainer.appendChild(self.rContainer);
                fragment.appendChild(self.innerContainer);
            }
            if (self.config.enableTime) {
                fragment.appendChild(buildTime());
            }
            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
            toggleClass(self.calendarContainer, "animate", self.config.animate === true);
            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
            self.calendarContainer.appendChild(fragment);
            var customAppend = self.config.appendTo !== undefined &&
                self.config.appendTo.nodeType !== undefined;
            if (self.config.inline || self.config.static) {
                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                if (self.config.inline) {
                    if (!customAppend && self.element.parentNode)
                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                    else if (self.config.appendTo !== undefined)
                        self.config.appendTo.appendChild(self.calendarContainer);
                }
                if (self.config.static) {
                    var wrapper = createElement("div", "flatpickr-wrapper");
                    if (self.element.parentNode)
                        self.element.parentNode.insertBefore(wrapper, self.element);
                    wrapper.appendChild(self.element);
                    if (self.altInput)
                        wrapper.appendChild(self.altInput);
                    wrapper.appendChild(self.calendarContainer);
                }
            }
            if (!self.config.static && !self.config.inline)
                (self.config.appendTo !== undefined
                    ? self.config.appendTo
                    : window.document.body).appendChild(self.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
            var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i;
            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 &&
                compareDates(date, self.now) === 0) {
                self.todayDateElem = dayElement;
                dayElement.classList.add("today");
                dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
                dayElement.tabIndex = -1;
                if (isDateSelected(date)) {
                    dayElement.classList.add("selected");
                    self.selectedDateElem = dayElement;
                    if (self.config.mode === "range") {
                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                            compareDates(date, self.selectedDates[0], true) === 0);
                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                            compareDates(date, self.selectedDates[1], true) === 0);
                        if (className === "nextMonthDay")
                            dayElement.classList.add("inRange");
                    }
                }
            }
            else {
                dayElement.classList.add("flatpickr-disabled");
            }
            if (self.config.mode === "range") {
                if (isDateInRange(date) && !isDateSelected(date))
                    dayElement.classList.add("inRange");
            }
            if (self.weekNumbers &&
                self.config.showMonths === 1 &&
                className !== "prevMonthDay" &&
                dayNumber % 7 === 1) {
                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
        }
        function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self.config.mode === "range")
                onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
            var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            for (var m = startMonth; m != endMonth; m += delta) {
                var month = self.daysContainer.children[m];
                var startIndex = delta > 0 ? 0 : month.children.length - 1;
                var endIndex = delta > 0 ? month.children.length : -1;
                for (var i = startIndex; i != endIndex; i += delta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                        return c;
                }
            }
            return undefined;
        }
        function getNextAvailableDay(current, delta) {
            var givenMonth = current.className.indexOf("Month") === -1
                ? current.dateObj.getMonth()
                : self.currentMonth;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            var loopDelta = delta > 0 ? 1 : -1;
            for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                var month = self.daysContainer.children[m];
                var startIndex = givenMonth - self.currentMonth === m
                    ? current.$i + delta
                    : delta < 0
                        ? month.children.length - 1
                        : 0;
                var numMonthDays = month.children.length;
                for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 &&
                        isEnabled(c.dateObj) &&
                        Math.abs(current.$i - i) >= Math.abs(delta))
                        return focusOnDayElem(c);
                }
            }
            self.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return undefined;
        }
        function focusOnDay(current, offset) {
            var dayFocused = isInView(document.activeElement || document.body);
            var startElem = current !== undefined
                ? current
                : dayFocused
                    ? document.activeElement
                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                        ? self.selectedDateElem
                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                            ? self.todayDateElem
                            : getFirstAvailableDay(offset > 0 ? 1 : -1);
            if (startElem === undefined)
                return self._input.focus();
            if (!dayFocused)
                return focusOnDayElem(startElem);
            getNextAvailableDay(startElem, offset);
        }
        function buildMonthDays(year, month) {
            var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
            var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
            var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            // prepend days from the ending of previous month
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            // Start at 1 since there is no 0th day
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            // append days from the next month
            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            //updateNavigationCurrentMonth();
            var dayContainer = createElement("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
        }
        function buildDays() {
            if (self.daysContainer === undefined) {
                return;
            }
            clearNode(self.daysContainer);
            // TODO: week numbers for each month
            if (self.weekNumbers)
                clearNode(self.weekNumbers);
            var frag = document.createDocumentFragment();
            for (var i = 0; i < self.config.showMonths; i++) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
            }
            self.daysContainer.appendChild(frag);
            self.days = self.daysContainer.firstChild;
            if (self.config.mode === "range" && self.selectedDates.length === 1) {
                onMouseOver();
            }
        }
        function buildMonthSwitch() {
            if (self.config.showMonths > 1)
                return;
            var shouldBuildMonth = function (month) {
                if (self.config.minDate !== undefined &&
                    self.currentYear === self.config.minDate.getFullYear() &&
                    month < self.config.minDate.getMonth()) {
                    return false;
                }
                return !(self.config.maxDate !== undefined &&
                    self.currentYear === self.config.maxDate.getFullYear() &&
                    month > self.config.maxDate.getMonth());
            };
            self.monthsDropdownContainer.tabIndex = -1;
            self.monthsDropdownContainer.innerHTML = "";
            for (var i = 0; i < 12; i++) {
                if (!shouldBuildMonth(i))
                    continue;
                var month = createElement("option", "flatpickr-monthDropdown-month");
                month.value = new Date(self.currentYear, i).getMonth().toString();
                month.textContent = monthToStr(i, false, self.l10n);
                month.tabIndex = -1;
                if (self.currentMonth === i) {
                    month.selected = true;
                }
                self.monthsDropdownContainer.appendChild(month);
            }
        }
        function buildMonth() {
            var container = createElement("div", "flatpickr-month");
            var monthNavFragment = window.document.createDocumentFragment();
            var monthElement;
            if (self.config.showMonths > 1) {
                monthElement = createElement("span", "cur-month");
            }
            else {
                self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
                bind(self.monthsDropdownContainer, "change", function (e) {
                    var target = e.target;
                    var selectedMonth = parseInt(target.value, 10);
                    self.changeMonth(selectedMonth - self.currentMonth);
                    triggerEvent("onMonthChange");
                });
                buildMonthSwitch();
                monthElement = self.monthsDropdownContainer;
            }
            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            var yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
            if (self.config.minDate) {
                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
            }
            if (self.config.maxDate) {
                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                yearElement.disabled =
                    !!self.config.minDate &&
                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
            }
            var currentMonth = createElement("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container.appendChild(monthNavFragment);
            return {
                container: container,
                yearElement: yearElement,
                monthElement: monthElement
            };
        }
        function buildMonths() {
            clearNode(self.monthNav);
            self.monthNav.appendChild(self.prevMonthNav);
            if (self.config.showMonths) {
                self.yearElements = [];
                self.monthElements = [];
            }
            for (var m = self.config.showMonths; m--;) {
                var month = buildMonth();
                self.yearElements.push(month.yearElement);
                self.monthElements.push(month.monthElement);
                self.monthNav.appendChild(month.container);
            }
            self.monthNav.appendChild(self.nextMonthNav);
        }
        function buildMonthNav() {
            self.monthNav = createElement("div", "flatpickr-months");
            self.yearElements = [];
            self.monthElements = [];
            self.prevMonthNav = createElement("span", "flatpickr-prev-month");
            self.prevMonthNav.innerHTML = self.config.prevArrow;
            self.nextMonthNav = createElement("span", "flatpickr-next-month");
            self.nextMonthNav.innerHTML = self.config.nextArrow;
            buildMonths();
            Object.defineProperty(self, "_hidePrevMonthArrow", {
                get: function () { return self.__hidePrevMonthArrow; },
                set: function (bool) {
                    if (self.__hidePrevMonthArrow !== bool) {
                        toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                        self.__hidePrevMonthArrow = bool;
                    }
                }
            });
            Object.defineProperty(self, "_hideNextMonthArrow", {
                get: function () { return self.__hideNextMonthArrow; },
                set: function (bool) {
                    if (self.__hideNextMonthArrow !== bool) {
                        toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                        self.__hideNextMonthArrow = bool;
                    }
                }
            });
            self.currentYearElement = self.yearElements[0];
            updateNavigationCurrentMonth();
            return self.monthNav;
        }
        function buildTime() {
            self.calendarContainer.classList.add("hasTime");
            if (self.config.noCalendar)
                self.calendarContainer.classList.add("noCalendar");
            self.timeContainer = createElement("div", "flatpickr-time");
            self.timeContainer.tabIndex = -1;
            var separator = createElement("span", "flatpickr-time-separator", ":");
            var hourInput = createNumberInput("flatpickr-hour");
            self.hourElement = hourInput.getElementsByTagName("input")[0];
            var minuteInput = createNumberInput("flatpickr-minute");
            self.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
            self.hourElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getHours()
                : self.config.time_24hr
                    ? self.config.defaultHour
                    : military2ampm(self.config.defaultHour));
            self.minuteElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getMinutes()
                : self.config.defaultMinute);
            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
            self.minuteElement.setAttribute("min", "0");
            self.minuteElement.setAttribute("max", "59");
            self.timeContainer.appendChild(hourInput);
            self.timeContainer.appendChild(separator);
            self.timeContainer.appendChild(minuteInput);
            if (self.config.time_24hr)
                self.timeContainer.classList.add("time24hr");
            if (self.config.enableSeconds) {
                self.timeContainer.classList.add("hasSeconds");
                var secondInput = createNumberInput("flatpickr-second");
                self.secondElement = secondInput.getElementsByTagName("input")[0];
                self.secondElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getSeconds()
                    : self.config.defaultSeconds);
                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                self.secondElement.setAttribute("min", "0");
                self.secondElement.setAttribute("max", "59");
                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                self.timeContainer.appendChild(secondInput);
            }
            if (!self.config.time_24hr) {
                // add self.amPM if appropriate
                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                    ? self.hourElement.value
                    : self.config.defaultHour) > 11)]);
                self.amPM.title = self.l10n.toggleTitle;
                self.amPM.tabIndex = -1;
                self.timeContainer.appendChild(self.amPM);
            }
            return self.timeContainer;
        }
        function buildWeekdays() {
            if (!self.weekdayContainer)
                self.weekdayContainer = createElement("div", "flatpickr-weekdays");
            else
                clearNode(self.weekdayContainer);
            for (var i = self.config.showMonths; i--;) {
                var container = createElement("div", "flatpickr-weekdaycontainer");
                self.weekdayContainer.appendChild(container);
            }
            updateWeekdays();
            return self.weekdayContainer;
        }
        function updateWeekdays() {
            var firstDayOfWeek = self.l10n.firstDayOfWeek;
            var weekdays = self.l10n.weekdays.shorthand.slice();
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
            }
            for (var i = self.config.showMonths; i--;) {
                self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
        }
        /* istanbul ignore next */
        function buildWeeks() {
            self.calendarContainer.classList.add("hasWeeks");
            var weekWrapper = createElement("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
            var weekNumbers = createElement("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
                weekWrapper: weekWrapper,
                weekNumbers: weekNumbers
            };
        }
        function changeMonth(value, isOffset) {
            if (isOffset === void 0) { isOffset = true; }
            var delta = isOffset ? value : value - self.currentMonth;
            if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                (delta > 0 && self._hideNextMonthArrow === true))
                return;
            self.currentMonth += delta;
            if (self.currentMonth < 0 || self.currentMonth > 11) {
                self.currentYear += self.currentMonth > 11 ? 1 : -1;
                self.currentMonth = (self.currentMonth + 12) % 12;
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
            if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
            if (toInitial === void 0) { toInitial = true; }
            self.input.value = "";
            if (self.altInput !== undefined)
                self.altInput.value = "";
            if (self.mobileInput !== undefined)
                self.mobileInput.value = "";
            self.selectedDates = [];
            self.latestSelectedDateObj = undefined;
            if (toInitial === true) {
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
            }
            self.showTimeInput = false;
            if (self.config.enableTime === true) {
                setDefaultHours();
            }
            self.redraw();
            if (triggerChangeEvent)
                // triggerChangeEvent is true (default) or an Event
                triggerEvent("onChange");
        }
        function close() {
            self.isOpen = false;
            if (!self.isMobile) {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.classList.remove("open");
                }
                if (self._input !== undefined) {
                    self._input.classList.remove("active");
                }
            }
            triggerEvent("onClose");
        }
        function destroy() {
            if (self.config !== undefined)
                triggerEvent("onDestroy");
            for (var i = self._handlers.length; i--;) {
                var h = self._handlers[i];
                h.element.removeEventListener(h.event, h.handler, h.options);
            }
            self._handlers = [];
            if (self.mobileInput) {
                if (self.mobileInput.parentNode)
                    self.mobileInput.parentNode.removeChild(self.mobileInput);
                self.mobileInput = undefined;
            }
            else if (self.calendarContainer && self.calendarContainer.parentNode) {
                if (self.config.static && self.calendarContainer.parentNode) {
                    var wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild)
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                }
                else
                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);
            }
            if (self.altInput) {
                self.input.type = "text";
                if (self.altInput.parentNode)
                    self.altInput.parentNode.removeChild(self.altInput);
                delete self.altInput;
            }
            if (self.input) {
                self.input.type = self.input._type;
                self.input.classList.remove("flatpickr-input");
                self.input.removeAttribute("readonly");
                self.input.value = "";
            }
            [
                "_showTimeInput",
                "latestSelectedDateObj",
                "_hideNextMonthArrow",
                "_hidePrevMonthArrow",
                "__hideNextMonthArrow",
                "__hidePrevMonthArrow",
                "isMobile",
                "isOpen",
                "selectedDateElem",
                "minDateHasTime",
                "maxDateHasTime",
                "days",
                "daysContainer",
                "_input",
                "_positionElement",
                "innerContainer",
                "rContainer",
                "monthNav",
                "todayDateElem",
                "calendarContainer",
                "weekdayContainer",
                "prevMonthNav",
                "nextMonthNav",
                "monthsDropdownContainer",
                "currentMonthElement",
                "currentYearElement",
                "navigationCurrentMonth",
                "selectedDateElem",
                "config",
            ].forEach(function (k) {
                try {
                    delete self[k];
                }
                catch (_) { }
            });
        }
        function isCalendarElem(elem) {
            if (self.config.appendTo && self.config.appendTo.contains(elem))
                return true;
            return self.calendarContainer.contains(elem);
        }
        function documentClick(e) {
            if (self.isOpen && !self.config.inline) {
                var eventTarget_1 = getEventTarget(e);
                var isCalendarElement = isCalendarElem(eventTarget_1);
                var isInput = eventTarget_1 === self.input ||
                    eventTarget_1 === self.altInput ||
                    self.element.contains(eventTarget_1) ||
                    // web components
                    // e.path is not present in all browsers. circumventing typechecks
                    (e.path &&
                        e.path.indexOf &&
                        (~e.path.indexOf(self.input) ||
                            ~e.path.indexOf(self.altInput)));
                var lostFocus = e.type === "blur"
                    ? isInput &&
                        e.relatedTarget &&
                        !isCalendarElem(e.relatedTarget)
                    : !isInput &&
                        !isCalendarElement &&
                        !isCalendarElem(e.relatedTarget);
                var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                    return elem.contains(eventTarget_1);
                });
                if (lostFocus && isIgnored) {
                    self.close();
                    if (self.config.mode === "range" && self.selectedDates.length === 1) {
                        self.clear(false);
                        self.redraw();
                    }
                }
            }
        }
        function changeYear(newYear) {
            if (!newYear ||
                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                return;
            var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear;
            if (self.config.maxDate &&
                self.currentYear === self.config.maxDate.getFullYear()) {
                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
            }
            else if (self.config.minDate &&
                self.currentYear === self.config.minDate.getFullYear()) {
                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
            }
            if (isNewYear) {
                self.redraw();
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
        }
        function isEnabled(date, timeless) {
            if (timeless === void 0) { timeless = true; }
            var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
            if ((self.config.minDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                (self.config.maxDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                return false;
            if (self.config.enable.length === 0 && self.config.disable.length === 0)
                return true;
            if (dateToCheck === undefined)
                return false;
            var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
            for (var i = 0, d = void 0; i < array.length; i++) {
                d = array[i];
                if (typeof d === "function" &&
                    d(dateToCheck) // disabled by function
                )
                    return bool;
                else if (d instanceof Date &&
                    dateToCheck !== undefined &&
                    d.getTime() === dateToCheck.getTime())
                    // disabled by date
                    return bool;
                else if (typeof d === "string" && dateToCheck !== undefined) {
                    // disabled by date string
                    var parsed = self.parseDate(d, undefined, true);
                    return parsed && parsed.getTime() === dateToCheck.getTime()
                        ? bool
                        : !bool;
                }
                else if (
                // disabled by range
                typeof d === "object" &&
                    dateToCheck !== undefined &&
                    d.from &&
                    d.to &&
                    dateToCheck.getTime() >= d.from.getTime() &&
                    dateToCheck.getTime() <= d.to.getTime())
                    return bool;
            }
            return !bool;
        }
        function isInView(elem) {
            if (self.daysContainer !== undefined)
                return (elem.className.indexOf("hidden") === -1 &&
                    self.daysContainer.contains(elem));
            return false;
        }
        function onKeyDown(e) {
            // e.key                      e.keyCode
            // "Backspace"                        8
            // "Tab"                              9
            // "Enter"                           13
            // "Escape"     (IE "Esc")           27
            // "ArrowLeft"  (IE "Left")          37
            // "ArrowUp"    (IE "Up")            38
            // "ArrowRight" (IE "Right")         39
            // "ArrowDown"  (IE "Down")          40
            // "Delete"     (IE "Del")           46
            var isInput = e.target === self._input;
            var allowInput = self.config.allowInput;
            var allowKeydown = self.isOpen && (!allowInput || !isInput);
            var allowInlineKeydown = self.config.inline && isInput && !allowInput;
            if (e.keyCode === 13 && isInput) {
                if (allowInput) {
                    self.setDate(self._input.value, true, e.target === self.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                    return e.target.blur();
                }
                else {
                    self.open();
                }
            }
            else if (isCalendarElem(e.target) ||
                allowKeydown ||
                allowInlineKeydown) {
                var isTimeObj = !!self.timeContainer &&
                    self.timeContainer.contains(e.target);
                switch (e.keyCode) {
                    case 13:
                        if (isTimeObj) {
                            e.preventDefault();
                            updateTime();
                            focusAndClose();
                        }
                        else
                            selectDate(e);
                        break;
                    case 27: // escape
                        e.preventDefault();
                        focusAndClose();
                        break;
                    case 8:
                    case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;
                    case 37:
                    case 39:
                        if (!isTimeObj && !isInput) {
                            e.preventDefault();
                            if (self.daysContainer !== undefined &&
                                (allowInput === false ||
                                    (document.activeElement && isInView(document.activeElement)))) {
                                var delta_1 = e.keyCode === 39 ? 1 : -1;
                                if (!e.ctrlKey)
                                    focusOnDay(undefined, delta_1);
                                else {
                                    e.stopPropagation();
                                    changeMonth(delta_1);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        }
                        else if (self.hourElement)
                            self.hourElement.focus();
                        break;
                    case 38:
                    case 40:
                        e.preventDefault();
                        var delta = e.keyCode === 40 ? 1 : -1;
                        if ((self.daysContainer && e.target.$i !== undefined) ||
                            e.target === self.input) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                            else if (!isTimeObj)
                                focusOnDay(undefined, delta * 7);
                        }
                        else if (e.target === self.currentYearElement) {
                            changeYear(self.currentYear - delta);
                        }
                        else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement)
                                self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;
                    case 9:
                        if (isTimeObj) {
                            var elems = [
                                self.hourElement,
                                self.minuteElement,
                                self.secondElement,
                                self.amPM,
                            ]
                                .concat(self.pluginElements)
                                .filter(function (x) { return x; });
                            var i = elems.indexOf(e.target);
                            if (i !== -1) {
                                var target = elems[i + (e.shiftKey ? -1 : 1)];
                                e.preventDefault();
                                (target || self._input).focus();
                            }
                        }
                        else if (!self.config.noCalendar &&
                            self.daysContainer &&
                            self.daysContainer.contains(e.target) &&
                            e.shiftKey) {
                            e.preventDefault();
                            self._input.focus();
                        }
                        break;
                    default:
                        break;
                }
            }
            if (self.amPM !== undefined && e.target === self.amPM) {
                switch (e.key) {
                    case self.l10n.amPM[0].charAt(0):
                    case self.l10n.amPM[0].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[0];
                        setHoursFromInputs();
                        updateValue();
                        break;
                    case self.l10n.amPM[1].charAt(0):
                    case self.l10n.amPM[1].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[1];
                        setHoursFromInputs();
                        updateValue();
                        break;
                }
            }
            if (isInput || isCalendarElem(e.target)) {
                triggerEvent("onKeyDown", e);
            }
        }
        function onMouseOver(elem) {
            if (self.selectedDates.length !== 1 ||
                (elem &&
                    (!elem.classList.contains("flatpickr-day") ||
                        elem.classList.contains("flatpickr-disabled"))))
                return;
            var hoverDate = elem
                ? elem.dateObj.getTime()
                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
            var containsDisabled = false;
            var minRange = 0, maxRange = 0;
            for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
                if (!isEnabled(new Date(t), true)) {
                    containsDisabled =
                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                    if (t < initialDate && (!minRange || t > minRange))
                        minRange = t;
                    else if (t > initialDate && (!maxRange || t < maxRange))
                        maxRange = t;
                }
            }
            for (var m = 0; m < self.config.showMonths; m++) {
                var month = self.daysContainer.children[m];
                var _loop_1 = function (i, l) {
                    var dayElem = month.children[i], date = dayElem.dateObj;
                    var timestamp = date.getTime();
                    var outOfRange = (minRange > 0 && timestamp < minRange) ||
                        (maxRange > 0 && timestamp > maxRange);
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        ["inRange", "startRange", "endRange"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        return "continue";
                    }
                    else if (containsDisabled && !outOfRange)
                        return "continue";
                    ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                        dayElem.classList.remove(c);
                    });
                    if (elem !== undefined) {
                        elem.classList.add(hoverDate <= self.selectedDates[0].getTime()
                            ? "startRange"
                            : "endRange");
                        if (initialDate < hoverDate && timestamp === initialDate)
                            dayElem.classList.add("startRange");
                        else if (initialDate > hoverDate && timestamp === initialDate)
                            dayElem.classList.add("endRange");
                        if (timestamp >= minRange &&
                            (maxRange === 0 || timestamp <= maxRange) &&
                            isBetween(timestamp, initialDate, hoverDate))
                            dayElem.classList.add("inRange");
                    }
                };
                for (var i = 0, l = month.children.length; i < l; i++) {
                    _loop_1(i, l);
                }
            }
        }
        function onResize() {
            if (self.isOpen && !self.config.static && !self.config.inline)
                positionCalendar();
        }
        function setDefaultTime() {
            self.setDate(self.config.minDate !== undefined
                ? new Date(self.config.minDate.getTime())
                : new Date(), true);
            setDefaultHours();
            updateValue();
        }
        function open(e, positionElement) {
            if (positionElement === void 0) { positionElement = self._positionElement; }
            if (self.isMobile === true) {
                if (e) {
                    e.preventDefault();
                    e.target && e.target.blur();
                }
                if (self.mobileInput !== undefined) {
                    self.mobileInput.focus();
                    self.mobileInput.click();
                }
                triggerEvent("onOpen");
                return;
            }
            if (self._input.disabled || self.config.inline)
                return;
            var wasOpen = self.isOpen;
            self.isOpen = true;
            if (!wasOpen) {
                self.calendarContainer.classList.add("open");
                self._input.classList.add("active");
                triggerEvent("onOpen");
                positionCalendar(positionElement);
            }
            if (self.config.enableTime === true && self.config.noCalendar === true) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (self.config.allowInput === false &&
                    (e === undefined ||
                        !self.timeContainer.contains(e.relatedTarget))) {
                    setTimeout(function () { return self.hourElement.select(); }, 50);
                }
            }
        }
        function minMaxDateSetter(type) {
            return function (date) {
                var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                if (dateObj !== undefined) {
                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                        dateObj.getHours() > 0 ||
                            dateObj.getMinutes() > 0 ||
                            dateObj.getSeconds() > 0;
                }
                if (self.selectedDates) {
                    self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                    if (!self.selectedDates.length && type === "min")
                        setHoursFromDate(dateObj);
                    updateValue();
                }
                if (self.daysContainer) {
                    redraw();
                    if (dateObj !== undefined)
                        self.currentYearElement[type] = dateObj.getFullYear().toString();
                    else
                        self.currentYearElement.removeAttribute(type);
                    self.currentYearElement.disabled =
                        !!inverseDateObj &&
                            dateObj !== undefined &&
                            inverseDateObj.getFullYear() === dateObj.getFullYear();
                }
            };
        }
        function parseConfig() {
            var boolOpts = [
                "wrap",
                "weekNumbers",
                "allowInput",
                "clickOpens",
                "time_24hr",
                "enableTime",
                "noCalendar",
                "altInput",
                "shorthandCurrentMonth",
                "inline",
                "static",
                "enableSeconds",
                "disableMobile",
            ];
            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
            var formats = {};
            self.config.parseDate = userConfig.parseDate;
            self.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self.config, "enable", {
                get: function () { return self.config._enable; },
                set: function (dates) {
                    self.config._enable = parseDateRules(dates);
                }
            });
            Object.defineProperty(self.config, "disable", {
                get: function () { return self.config._disable; },
                set: function (dates) {
                    self.config._disable = parseDateRules(dates);
                }
            });
            var timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
                formats.dateFormat =
                    userConfig.noCalendar || timeMode
                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                        : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput &&
                (userConfig.enableTime || timeMode) &&
                !userConfig.altFormat) {
                var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
                formats.altFormat =
                    userConfig.noCalendar || timeMode
                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                        : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
            }
            if (!userConfig.altInputClass) {
                self.config.altInputClass =
                    self.input.className + " " + self.config.altInputClass;
            }
            Object.defineProperty(self.config, "minDate", {
                get: function () { return self.config._minDate; },
                set: minMaxDateSetter("min")
            });
            Object.defineProperty(self.config, "maxDate", {
                get: function () { return self.config._maxDate; },
                set: minMaxDateSetter("max")
            });
            var minMaxTimeSetter = function (type) { return function (val) {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
            }; };
            Object.defineProperty(self.config, "minTime", {
                get: function () { return self.config._minTime; },
                set: minMaxTimeSetter("min")
            });
            Object.defineProperty(self.config, "maxTime", {
                get: function () { return self.config._maxTime; },
                set: minMaxTimeSetter("max")
            });
            if (userConfig.mode === "time") {
                self.config.noCalendar = true;
                self.config.enableTime = true;
            }
            Object.assign(self.config, formats, userConfig);
            for (var i = 0; i < boolOpts.length; i++)
                self.config[boolOpts[i]] =
                    self.config[boolOpts[i]] === true ||
                        self.config[boolOpts[i]] === "true";
            HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
            });
            self.isMobile =
                !self.config.disableMobile &&
                    !self.config.inline &&
                    self.config.mode === "single" &&
                    !self.config.disable.length &&
                    !self.config.enable.length &&
                    !self.config.weekNumbers &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (var i = 0; i < self.config.plugins.length; i++) {
                var pluginConf = self.config.plugins[i](self) || {};
                for (var key in pluginConf) {
                    if (HOOKS.indexOf(key) > -1) {
                        self.config[key] = arrayify(pluginConf[key])
                            .map(bindToInstance)
                            .concat(self.config[key]);
                    }
                    else if (typeof userConfig[key] === "undefined")
                        self.config[key] = pluginConf[key];
                }
            }
            triggerEvent("onParseConfig");
        }
        function setupLocale() {
            if (typeof self.config.locale !== "object" &&
                typeof flatpickr.l10ns[self.config.locale] === "undefined")
                self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
            self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                ? self.config.locale
                : self.config.locale !== "default"
                    ? flatpickr.l10ns[self.config.locale]
                    : undefined));
            tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
            if (userConfig.time_24hr === undefined &&
                flatpickr.defaultConfig.time_24hr === undefined) {
                self.config.time_24hr = self.l10n.time_24hr;
            }
            self.formatDate = createDateFormatter(self);
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        }
        function positionCalendar(customPositionElement) {
            if (self.calendarContainer === undefined)
                return;
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self._positionElement;
            var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                (configPosVertical !== "below" &&
                    distanceFromBottom < calendarHeight &&
                    inputBounds.top > calendarHeight);
            var top = window.pageYOffset +
                inputBounds.top +
                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
            if (self.config.inline)
                return;
            var left = window.pageXOffset +
                inputBounds.left -
                (configPosHorizontal != null && configPosHorizontal === "center"
                    ? (calendarWidth - inputBounds.width) / 2
                    : 0);
            var right = window.document.body.offsetWidth - inputBounds.right;
            var rightMost = left + calendarWidth > window.document.body.offsetWidth;
            var centerMost = right + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self.calendarContainer, "rightMost", rightMost);
            if (self.config.static)
                return;
            self.calendarContainer.style.top = top + "px";
            if (!rightMost) {
                self.calendarContainer.style.left = left + "px";
                self.calendarContainer.style.right = "auto";
            }
            else if (!centerMost) {
                self.calendarContainer.style.left = "auto";
                self.calendarContainer.style.right = right + "px";
            }
            else {
                var doc = document.styleSheets[0];
                // some testing environments don't have css support
                if (doc === undefined)
                    return;
                var bodyWidth = window.document.body.offsetWidth;
                var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                var centerBefore = ".flatpickr-calendar.centerMost:before";
                var centerAfter = ".flatpickr-calendar.centerMost:after";
                var centerIndex = doc.cssRules.length;
                var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                toggleClass(self.calendarContainer, "rightMost", false);
                toggleClass(self.calendarContainer, "centerMost", true);
                doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                self.calendarContainer.style.left = centerLeft + "px";
                self.calendarContainer.style.right = "auto";
            }
        }
        function redraw() {
            if (self.config.noCalendar || self.isMobile)
                return;
            updateNavigationCurrentMonth();
            buildDays();
        }
        function focusAndClose() {
            self._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                navigator.msMaxTouchPoints !== undefined) {
                // hack - bugs in the way IE handles focus keeps the calendar open
                setTimeout(self.close, 0);
            }
            else {
                self.close();
            }
        }
        function selectDate(e) {
            e.preventDefault();
            e.stopPropagation();
            var isSelectable = function (day) {
                return day.classList &&
                    day.classList.contains("flatpickr-day") &&
                    !day.classList.contains("flatpickr-disabled") &&
                    !day.classList.contains("notAllowed");
            };
            var t = findParent(e.target, isSelectable);
            if (t === undefined)
                return;
            var target = t;
            var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
            var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                selectedDate.getMonth() >
                    self.currentMonth + self.config.showMonths - 1) &&
                self.config.mode !== "range";
            self.selectedDateElem = target;
            if (self.config.mode === "single")
                self.selectedDates = [selectedDate];
            else if (self.config.mode === "multiple") {
                var selectedIndex = isDateSelected(selectedDate);
                if (selectedIndex)
                    self.selectedDates.splice(parseInt(selectedIndex), 1);
                else
                    self.selectedDates.push(selectedDate);
            }
            else if (self.config.mode === "range") {
                if (self.selectedDates.length === 2) {
                    self.clear(false, false);
                }
                self.latestSelectedDateObj = selectedDate;
                self.selectedDates.push(selectedDate);
                // unless selecting same date twice, sort ascendingly
                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
                var isNewYear = self.currentYear !== selectedDate.getFullYear();
                self.currentYear = selectedDate.getFullYear();
                self.currentMonth = selectedDate.getMonth();
                if (isNewYear) {
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (self.config.enableTime)
                setTimeout(function () { return (self.showTimeInput = true); }, 50);
            // maintain focus
            if (!shouldChangeMonth &&
                self.config.mode !== "range" &&
                self.config.showMonths === 1)
                focusOnDayElem(target);
            else if (self.selectedDateElem !== undefined &&
                self.hourElement === undefined) {
                self.selectedDateElem && self.selectedDateElem.focus();
            }
            if (self.hourElement !== undefined)
                self.hourElement !== undefined && self.hourElement.focus();
            if (self.config.closeOnSelect) {
                var single = self.config.mode === "single" && !self.config.enableTime;
                var range = self.config.mode === "range" &&
                    self.selectedDates.length === 2 &&
                    !self.config.enableTime;
                if (single || range) {
                    focusAndClose();
                }
            }
            triggerChange();
        }
        var CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
            minDate: [jumpToDate],
            maxDate: [jumpToDate]
        };
        function set(option, value) {
            if (option !== null && typeof option === "object") {
                Object.assign(self.config, option);
                for (var key in option) {
                    if (CALLBACKS[key] !== undefined)
                        CALLBACKS[key].forEach(function (x) { return x(); });
                }
            }
            else {
                self.config[option] = value;
                if (CALLBACKS[option] !== undefined)
                    CALLBACKS[option].forEach(function (x) { return x(); });
                else if (HOOKS.indexOf(option) > -1)
                    self.config[option] = arrayify(value);
            }
            self.redraw();
            updateValue(false);
        }
        function setSelectedDate(inputDate, format) {
            var dates = [];
            if (inputDate instanceof Array)
                dates = inputDate.map(function (d) { return self.parseDate(d, format); });
            else if (inputDate instanceof Date || typeof inputDate === "number")
                dates = [self.parseDate(inputDate, format)];
            else if (typeof inputDate === "string") {
                switch (self.config.mode) {
                    case "single":
                    case "time":
                        dates = [self.parseDate(inputDate, format)];
                        break;
                    case "multiple":
                        dates = inputDate
                            .split(self.config.conjunction)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    case "range":
                        dates = inputDate
                            .split(self.l10n.rangeSeparator)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    default:
                        break;
                }
            }
            else
                self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
            self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
            if (self.config.mode === "range")
                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        function setDate(date, triggerChange, format) {
            if (triggerChange === void 0) { triggerChange = false; }
            if (format === void 0) { format = self.config.dateFormat; }
            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                return self.clear(triggerChange);
            setSelectedDate(date, format);
            self.showTimeInput = self.selectedDates.length > 0;
            self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
            self.redraw();
            jumpToDate();
            setHoursFromDate();
            if (self.selectedDates.length === 0) {
                self.clear(false);
            }
            updateValue(triggerChange);
            if (triggerChange)
                triggerEvent("onChange");
        }
        function parseDateRules(arr) {
            return arr
                .slice()
                .map(function (rule) {
                if (typeof rule === "string" ||
                    typeof rule === "number" ||
                    rule instanceof Date) {
                    return self.parseDate(rule, undefined, true);
                }
                else if (rule &&
                    typeof rule === "object" &&
                    rule.from &&
                    rule.to)
                    return {
                        from: self.parseDate(rule.from, undefined),
                        to: self.parseDate(rule.to, undefined)
                    };
                return rule;
            })
                .filter(function (x) { return x; }); // remove falsy values
        }
        function setupDates() {
            self.selectedDates = [];
            self.now = self.parseDate(self.config.now) || new Date();
            // Workaround IE11 setting placeholder as the input's value
            var preloadedDate = self.config.defaultDate ||
                ((self.input.nodeName === "INPUT" ||
                    self.input.nodeName === "TEXTAREA") &&
                    self.input.placeholder &&
                    self.input.value === self.input.placeholder
                    ? null
                    : self.input.value);
            if (preloadedDate)
                setSelectedDate(preloadedDate, self.config.dateFormat);
            self._initialDate =
                self.selectedDates.length > 0
                    ? self.selectedDates[0]
                    : self.config.minDate &&
                        self.config.minDate.getTime() > self.now.getTime()
                        ? self.config.minDate
                        : self.config.maxDate &&
                            self.config.maxDate.getTime() < self.now.getTime()
                            ? self.config.maxDate
                            : self.now;
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
            if (self.selectedDates.length > 0)
                self.latestSelectedDateObj = self.selectedDates[0];
            if (self.config.minTime !== undefined)
                self.config.minTime = self.parseDate(self.config.minTime, "H:i");
            if (self.config.maxTime !== undefined)
                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
            self.minDateHasTime =
                !!self.config.minDate &&
                    (self.config.minDate.getHours() > 0 ||
                        self.config.minDate.getMinutes() > 0 ||
                        self.config.minDate.getSeconds() > 0);
            self.maxDateHasTime =
                !!self.config.maxDate &&
                    (self.config.maxDate.getHours() > 0 ||
                        self.config.maxDate.getMinutes() > 0 ||
                        self.config.maxDate.getSeconds() > 0);
            Object.defineProperty(self, "showTimeInput", {
                get: function () { return self._showTimeInput; },
                set: function (bool) {
                    self._showTimeInput = bool;
                    if (self.calendarContainer)
                        toggleClass(self.calendarContainer, "showTimeInput", bool);
                    self.isOpen && positionCalendar();
                }
            });
        }
        function setupInputs() {
            self.input = self.config.wrap
                ? element.querySelector("[data-input]")
                : element;
            /* istanbul ignore next */
            if (!self.input) {
                self.config.errorHandler(new Error("Invalid input element specified"));
                return;
            }
            // hack: store previous type to restore it after destroy()
            self.input._type = self.input.type;
            self.input.type = "text";
            self.input.classList.add("flatpickr-input");
            self._input = self.input;
            if (self.config.altInput) {
                // replicate self.element
                self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
                self._input = self.altInput;
                self.altInput.placeholder = self.input.placeholder;
                self.altInput.disabled = self.input.disabled;
                self.altInput.required = self.input.required;
                self.altInput.tabIndex = self.input.tabIndex;
                self.altInput.type = "text";
                self.input.setAttribute("type", "hidden");
                if (!self.config.static && self.input.parentNode)
                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
            }
            if (!self.config.allowInput)
                self._input.setAttribute("readonly", "readonly");
            self._positionElement = self.config.positionElement || self._input;
        }
        function setupMobile() {
            var inputType = self.config.enableTime
                ? self.config.noCalendar
                    ? "time"
                    : "datetime-local"
                : "date";
            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
            self.mobileInput.step = self.input.getAttribute("step") || "any";
            self.mobileInput.tabIndex = 1;
            self.mobileInput.type = inputType;
            self.mobileInput.disabled = self.input.disabled;
            self.mobileInput.required = self.input.required;
            self.mobileInput.placeholder = self.input.placeholder;
            self.mobileFormatStr =
                inputType === "datetime-local"
                    ? "Y-m-d\\TH:i:S"
                    : inputType === "date"
                        ? "Y-m-d"
                        : "H:i:S";
            if (self.selectedDates.length > 0) {
                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
            }
            if (self.config.minDate)
                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
            if (self.config.maxDate)
                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
            self.input.type = "hidden";
            if (self.altInput !== undefined)
                self.altInput.type = "hidden";
            try {
                if (self.input.parentNode)
                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
            }
            catch (_a) { }
            bind(self.mobileInput, "change", function (e) {
                self.setDate(e.target.value, false, self.mobileFormatStr);
                triggerEvent("onChange");
                triggerEvent("onClose");
            });
        }
        function toggle(e) {
            if (self.isOpen === true)
                return self.close();
            self.open(e);
        }
        function triggerEvent(event, data) {
            // If the instance has been destroyed already, all hooks have been removed
            if (self.config === undefined)
                return;
            var hooks = self.config[event];
            if (hooks !== undefined && hooks.length > 0) {
                for (var i = 0; hooks[i] && i < hooks.length; i++)
                    hooks[i](self.selectedDates, self.input.value, self, data);
            }
            if (event === "onChange") {
                self.input.dispatchEvent(createEvent("change"));
                // many front-end frameworks bind to the input event
                self.input.dispatchEvent(createEvent("input"));
            }
        }
        function createEvent(name) {
            var e = document.createEvent("Event");
            e.initEvent(name, true, true);
            return e;
        }
        function isDateSelected(date) {
            for (var i = 0; i < self.selectedDates.length; i++) {
                if (compareDates(self.selectedDates[i], date) === 0)
                    return "" + i;
            }
            return false;
        }
        function isDateInRange(date) {
            if (self.config.mode !== "range" || self.selectedDates.length < 2)
                return false;
            return (compareDates(date, self.selectedDates[0]) >= 0 &&
                compareDates(date, self.selectedDates[1]) <= 0);
        }
        function updateNavigationCurrentMonth() {
            if (self.config.noCalendar || self.isMobile || !self.monthNav)
                return;
            self.yearElements.forEach(function (yearElement, i) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                if (self.config.showMonths > 1) {
                    self.monthElements[i].textContent =
                        monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
                }
                else {
                    self.monthsDropdownContainer.value = d.getMonth().toString();
                }
                yearElement.value = d.getFullYear().toString();
            });
            self._hidePrevMonthArrow =
                self.config.minDate !== undefined &&
                    (self.currentYear === self.config.minDate.getFullYear()
                        ? self.currentMonth <= self.config.minDate.getMonth()
                        : self.currentYear < self.config.minDate.getFullYear());
            self._hideNextMonthArrow =
                self.config.maxDate !== undefined &&
                    (self.currentYear === self.config.maxDate.getFullYear()
                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                        : self.currentYear > self.config.maxDate.getFullYear());
        }
        function getDateStr(format) {
            return self.selectedDates
                .map(function (dObj) { return self.formatDate(dObj, format); })
                .filter(function (d, i, arr) {
                return self.config.mode !== "range" ||
                    self.config.enableTime ||
                    arr.indexOf(d) === i;
            })
                .join(self.config.mode !== "range"
                ? self.config.conjunction
                : self.l10n.rangeSeparator);
        }
        /**
         * Updates the values of inputs associated with the calendar
         */
        function updateValue(triggerChange) {
            if (triggerChange === void 0) { triggerChange = true; }
            if (self.mobileInput !== undefined && self.mobileFormatStr) {
                self.mobileInput.value =
                    self.latestSelectedDateObj !== undefined
                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                        : "";
            }
            self.input.value = getDateStr(self.config.dateFormat);
            if (self.altInput !== undefined) {
                self.altInput.value = getDateStr(self.config.altFormat);
            }
            if (triggerChange !== false)
                triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
            var isPrevMonth = self.prevMonthNav.contains(e.target);
            var isNextMonth = self.nextMonthNav.contains(e.target);
            if (isPrevMonth || isNextMonth) {
                changeMonth(isPrevMonth ? -1 : 1);
            }
            else if (self.yearElements.indexOf(e.target) >= 0) {
                e.target.select();
            }
            else if (e.target.classList.contains("arrowUp")) {
                self.changeYear(self.currentYear + 1);
            }
            else if (e.target.classList.contains("arrowDown")) {
                self.changeYear(self.currentYear - 1);
            }
        }
        function timeWrapper(e) {
            e.preventDefault();
            var isKeyDown = e.type === "keydown", input = e.target;
            if (self.amPM !== undefined && e.target === self.amPM) {
                self.amPM.textContent =
                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }
            var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
            var newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
                var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                if (newValue < min) {
                    newValue =
                        max +
                            newValue +
                            int(!isHourElem) +
                            (int(isHourElem) && int(!self.amPM));
                    if (isMinuteElem)
                        incrementNumInput(undefined, -1, self.hourElement);
                }
                else if (newValue > max) {
                    newValue =
                        input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                    if (isMinuteElem)
                        incrementNumInput(undefined, 1, self.hourElement);
                }
                if (self.amPM &&
                    isHourElem &&
                    (step === 1
                        ? newValue + curValue === 23
                        : Math.abs(newValue - curValue) > step)) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                input.value = pad(newValue);
            }
        }
        init();
        return self;
    }
    /* istanbul ignore next */
    function _flatpickr(nodeList, config) {
        // static list
        var nodes = Array.prototype.slice
            .call(nodeList)
            .filter(function (x) { return x instanceof HTMLElement; });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            try {
                if (node.getAttribute("data-fp-omit") !== null)
                    continue;
                if (node._flatpickr !== undefined) {
                    node._flatpickr.destroy();
                    node._flatpickr = undefined;
                }
                node._flatpickr = FlatpickrInstance(node, config || {});
                instances.push(node._flatpickr);
            }
            catch (e) {
                console.error(e);
            }
        }
        return instances.length === 1 ? instances[0] : instances;
    }
    /* istanbul ignore next */
    if (typeof HTMLElement !== "undefined" &&
        typeof HTMLCollection !== "undefined" &&
        typeof NodeList !== "undefined") {
        // browser env
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function (config) {
            return _flatpickr([this], config);
        };
    }
    /* istanbul ignore next */
    var flatpickr = function (selector, config) {
        if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
        }
        else if (selector instanceof Node) {
            return _flatpickr([selector], config);
        }
        else {
            return _flatpickr(selector, config);
        }
    };
    /* istanbul ignore next */
    flatpickr.defaultConfig = {};
    flatpickr.l10ns = {
        en: __assign({}, english),
        "default": __assign({}, english)
    };
    flatpickr.localize = function (l10n) {
        flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
    };
    flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    /* istanbul ignore next */
    if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
    }
    // eslint-disable-next-line @typescript-eslint/camelcase
    Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
    };
    if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
    }

    return flatpickr;

}));


/***/ }),

/***/ "../../node_modules/lodash.debounce/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash.debounce/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;


/***/ }),

/***/ "../../node_modules/warning/browser.js":
/*!*********************************************!*\
  !*** ../../node_modules/warning/browser.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (true) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY2FyYm9uLWNvbXBvbmVudHNfZXNfaW5kZXhfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2lEO0FBQ0Q7QUFDdUI7QUFDYztBQUMvQjtBQUNTO0FBQ3JCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIsK0RBQUU7QUFDbkIsaUJBQWlCLDBFQUFZOztBQUU3QixtQkFBbUIsMEVBQVk7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUFDQSxtQkFBbUIsbUVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUMsQ0FBQyxrRUFBSyxDQUFDLDJFQUFlLEVBQUUsbUZBQXFCLEVBQUUsd0VBQVksRUFBRSxrRUFBTzs7QUFFckUsaUVBQWUsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hZM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLElBQUk7QUFDSjtBQUNB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Q1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZCQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvY2hlY2tib3gvY2hlY2tib3guanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9jb2RlLXNuaXBwZXQvY29kZS1zbmlwcGV0LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvY29udGVudC1zd2l0Y2hlci9jb250ZW50LXN3aXRjaGVyLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvY29weS1idXR0b24vY29weS1idXR0b24uanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9kYXRhLXRhYmxlLXYyL2RhdGEtdGFibGUtdjIuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9kYXRhLXRhYmxlL2RhdGEtdGFibGUuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9kYXRlLXBpY2tlci9kYXRlLXBpY2tlci5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9jb21wb25lbnRzL2Ryb3Bkb3duL2Ryb3Bkb3duLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvZmlsZS11cGxvYWRlci9maWxlLXVwbG9hZGVyLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvZmxvYXRpbmctbWVudS9mbG9hdGluZy1tZW51LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvaW5saW5lLWxvYWRpbmcvaW5saW5lLWxvYWRpbmcuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9sb2FkaW5nL2xvYWRpbmcuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9tb2RhbC9tb2RhbC5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9jb21wb25lbnRzL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9udW1iZXItaW5wdXQvbnVtYmVyLWlucHV0LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvb3ZlcmZsb3ctbWVudS9vdmVyZmxvdy1tZW51LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvcGFnaW5hdGlvbi1uYXYvcGFnaW5hdGlvbi1uYXYuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9wYWdpbmF0aW9uL3BhZ2luYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9wcm9ncmVzcy1pbmRpY2F0b3IvcHJvZ3Jlc3MtaW5kaWNhdG9yLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvc2VhcmNoL3NlYXJjaC5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy9zdHJ1Y3R1cmVkLWxpc3Qvc3RydWN0dXJlZC1saXN0LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvdGFicy90YWJzLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvdGV4dC1pbnB1dC90ZXh0LWlucHV0LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvdGlsZS90aWxlLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvdG9vbGJhci90b29sYmFyLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLS1zaW1wbGUuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy91aS1zaGVsbC9oZWFkZXItbmF2LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvdWktc2hlbGwvaGVhZGVyLXN1Ym1lbnUuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy91aS1zaGVsbC9uYXZpZ2F0aW9uLW1lbnUtcGFuZWwuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy91aS1zaGVsbC9uYXZpZ2F0aW9uLW1lbnUuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvY29tcG9uZW50cy91aS1zaGVsbC9wcm9kdWN0LXN3aXRjaGVyLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2NvbXBvbmVudHMvdWktc2hlbGwvc2lkZS1uYXYuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvZ2xvYmFscy9qcy9jb21wb25lbnRzLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2dsb2JhbHMvanMvbWlzYy9ldmVudC1tYXRjaGVzLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2dsb2JhbHMvanMvbWlzYy9nZXQtbGF1bmNoaW5nLWRldGFpbHMuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvZ2xvYmFscy9qcy9taXNjL21peGluLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2dsb2JhbHMvanMvbWlzYy9vbi1mb2N1cy1ieS1rZXlib2FyZC5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL21pc2Mvb24uanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvZ2xvYmFscy9qcy9taXNjL3Jlc2l6ZS5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL21pc2Mvc3ZnLXRvZ2dsZS1jbGFzcy5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL21pc2MvdG9nZ2xlLWF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2dsb2JhbHMvanMvbWl4aW5zL2V2ZW50ZWQtc2hvdy1oaWRlLXN0YXRlLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2dsb2JhbHMvanMvbWl4aW5zL2V2ZW50ZWQtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcy5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1ldmVudC5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1sYXVuY2hlci5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMvZXMvZ2xvYmFscy9qcy9taXhpbnMvdHJhY2stYmx1ci5qcyIsIndlYnBhY2s6Ly9Aa2VueWFlbXIvZXNtLXBhdGllbnQtZmxhZ3MtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy9lcy9nbG9iYWxzL2pzL3NldHRpbmdzLmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL2VzL2luZGV4LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuanMiLCJ3ZWJwYWNrOi8vQGtlbnlhZW1yL2VzbS1wYXRpZW50LWZsYWdzLWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwid2VicGFjazovL0BrZW55YWVtci9lc20tcGF0aWVudC1mbGFncy1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBoYW5kbGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2hhbmRsZXMnO1xuaW1wb3J0IGV2ZW50TWF0Y2hlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZXZlbnQtbWF0Y2hlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIEFjY29yZGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhBY2NvcmRpb24sIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBY2NvcmRpb24pO1xuICAvKipcbiAgICogQWNjb3JkaW9uLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGFuIGFjY29yZGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBBY2NvcmRpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvcmRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBpdGVtID0gZXZlbnRNYXRjaGVzKGV2ZW50LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yQWNjb3JkaW9uSXRlbSk7XG5cbiAgICAgIGlmIChpdGVtICYmICFldmVudE1hdGNoZXMoZXZlbnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JBY2NvcmRpb25Db250ZW50KSkge1xuICAgICAgICBfdGhpcy5fdG9nZ2xlKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqICBERVBSRUNBVEUgaW4gdjhcbiAgICAgKlxuICAgICAqICBTd2FwcGluZyB0byBhIGJ1dHRvbiBlbGVtZW5ldCBpbnN0ZWFkIG9mIGEgZGl2XG4gICAgICogIGF1dG9tYXRpY2FsbHkgbWFwcyBjbGljayBldmVudHMgdG8ga2V5cHJlc3MgYXMgd2VsbFxuICAgICAqICBUaGlzIGV2ZW50IGxpc3RlbmVyIG5vdyBpcyBvbmx5IGFkZGVkIGlmIHVzZXIgaXMgdXNpbmdcbiAgICAgKiAgdGhlIG9sZGVyIG1hcmt1cFxuICAgICAqL1xuXG5cbiAgICBpZiAoIV90aGlzLl9jaGVja0lmQnV0dG9uKCkpIHtcbiAgICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAna2V5cHJlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBldmVudE1hdGNoZXMoZXZlbnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JBY2NvcmRpb25JdGVtKTtcblxuICAgICAgICBpZiAoaXRlbSAmJiAhZXZlbnRNYXRjaGVzKGV2ZW50LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yQWNjb3JkaW9uQ29udGVudCkpIHtcbiAgICAgICAgICBfdGhpcy5faGFuZGxlS2V5cHJlc3MoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFjY29yZGlvbiwgW3tcbiAgICBrZXk6IFwiX2NoZWNrSWZCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrSWZCdXR0b24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLm5vZGVOYW1lID09PSAnQlVUVE9OJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0b2dnbGluZyBvZiBhY3RpdmUgc3RhdGUgb2YgYWNjb3JkaW9uIHZpYSBrZXlib2FyZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUtleXByZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVLZXlwcmVzcyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAxMyB8fCBldmVudC53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50LnRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZShlbGVtZW50KSB7XG4gICAgICB2YXIgaGVhZGluZyA9IGVsZW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuc2VsZWN0b3JBY2NvcmRpb25JdGVtSGVhZGluZyk7XG4gICAgICB2YXIgZXhwYW5kZWQgPSBoZWFkaW5nLmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuXG4gICAgICBpZiAoZXhwYW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgaGVhZGluZy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBleHBhbmRlZCA9PT0gJ3RydWUnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wdGlvbnMuY2xhc3NBY3RpdmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBOdW1iZXJJbnB1dC5jcmVhdGUgLmNyZWF0ZSgpfSwgb3Ige0BsaW5rY29kZSBOdW1iZXJJbnB1dC5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZSBhbmQgaG93IHtAbGlua2NvZGUgTnVtYmVySW5wdXQuaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JJbml0IFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBhY2NvcmRpb24gVUlzLlxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtYWNjb3JkaW9uXScsXG4gICAgICAgIHNlbGVjdG9yQWNjb3JkaW9uSXRlbTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWFjY29yZGlvbl9faXRlbVwiKSxcbiAgICAgICAgc2VsZWN0b3JBY2NvcmRpb25JdGVtSGVhZGluZzogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWFjY29yZGlvbl9faGVhZGluZ1wiKSxcbiAgICAgICAgc2VsZWN0b3JBY2NvcmRpb25Db250ZW50OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tYWNjb3JkaW9uX19jb250ZW50XCIpLFxuICAgICAgICBjbGFzc0FjdGl2ZTogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tYWNjb3JkaW9uX19pdGVtLS1hY3RpdmVcIilcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIGFjY29yZGlvbiBVSSBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSk7XG5cbiAgQWNjb3JkaW9uLmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gQWNjb3JkaW9uO1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeVNlYXJjaCwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBBY2NvcmRpb247IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBvbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2Mvb24nO1xudmFyIHN0YXRlQ2hhbmdlVHlwZXMgPSB7XG4gIHRydWU6ICd0cnVlJyxcbiAgZmFsc2U6ICdmYWxzZScsXG4gIG1peGVkOiAnbWl4ZWQnXG59O1xuXG52YXIgQ2hlY2tib3ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoQ2hlY2tib3gsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDaGVja2JveCk7XG4gIC8qKlxuICAgKiBDaGVja2JveCBVSS5cbiAgICogQGV4dGVuZHMgQ3JlYXRlQ29tcG9uZW50XG4gICAqIEBleHRlbmRzIEluaXRDb21wb25lbnRCeVNlYXJjaFxuICAgKiBAZXh0ZW5kcyBIYW5kbGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhIGNoZWNrYm94IFVJLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENoZWNrYm94KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tib3gpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVDbGljayhldmVudCk7XG4gICAgfSkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdmb2N1cycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMuX2hhbmRsZUZvY3VzKGV2ZW50KTtcbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2JsdXInLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVCbHVyKGV2ZW50KTtcbiAgICB9KSk7XG5cbiAgICBfdGhpcy5faW5kZXRlcm1pbmF0ZUNoZWNrYm94KCk7XG5cbiAgICBfdGhpcy5faW5pdENoZWNrYm94KCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hlY2tib3gsIFt7XG4gICAga2V5OiBcIl9oYW5kbGVDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xpY2soKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50LmNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICcnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNoZWNrZWQgPSB0cnVlOyAvLyBuZXN0ZWQgY2hlY2tib3hlcyBpbnNpZGUgbGFiZWxzXG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NMYWJlbCkpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJpYkNvbnRhaW5lZENoZWNrYm94U3RhdGUsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmNoZWNrZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ2ZhbHNlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jaGVja2VkID0gZmFsc2U7IC8vIG5lc3RlZCBjaGVja2JveGVzIGluc2lkZSBsYWJlbHNcblxuICAgICAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMub3B0aW9ucy5jbGFzc0xhYmVsKSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmliQ29udGFpbmVkQ2hlY2tib3hTdGF0ZSwgJ2ZhbHNlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVGb2N1cygpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzTGFiZWwpKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNsYXNzTGFiZWxGb2N1c2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUJsdXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUJsdXIoKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMub3B0aW9ucy5jbGFzc0xhYmVsKSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc0xhYmVsRm9jdXNlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG5ldyBjaGVja2JveCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbc3RhdGVdXG4gICAgICogICBUaGUgbmV3IGNoZWNrYm94IHN0YXRlIHRvIHNldC4gYG1peGVkYCB0byBwdXQgY2hlY2tib3ggaW4gaW5kZXRlcm1pbmF0ZSBzdGF0ZS5cbiAgICAgKiAgIElmIG9taXR0ZWQsIHRoaXMgbWV0aG9kIHNpbXBseSBtYWtlcyB0aGUgc3R5bGUgcmVmbGVjdCBgYXJpYS1jaGVja2VkYCBhdHRyaWJ1dGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQgfHwgc3RhdGVDaGFuZ2VUeXBlc1tzdGF0ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzZXRTdGF0ZSBleHBlY3RzIGEgdmFsdWUgb2YgdHJ1ZSwgZmFsc2Ugb3IgbWl4ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIHN0YXRlKTtcbiAgICAgIHRoaXMuZWxlbWVudC5pbmRldGVybWluYXRlID0gc3RhdGUgPT09IHN0YXRlQ2hhbmdlVHlwZXMubWl4ZWQ7XG4gICAgICB0aGlzLmVsZW1lbnQuY2hlY2tlZCA9IHN0YXRlID09PSBzdGF0ZUNoYW5nZVR5cGVzLnRydWU7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5lbGVtZW50LmNsb3Nlc3QodGhpcy5vcHRpb25zLnNlbGVjdG9yQ29udGFpbmVkQ2hlY2tib3hTdGF0ZSk7XG5cbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmliQ29udGFpbmVkQ2hlY2tib3hTdGF0ZSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREaXNhYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2V0RGlzYWJsZWQgZXhwZWN0cyBhIGJvb2xlYW4gdmFsdWUgb2YgdHJ1ZSBvciBmYWxzZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JDb250YWluZWRDaGVja2JveERpc2FibGVkKTtcblxuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJDb250YWluZWRDaGVja2JveERpc2FibGVkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbmRldGVybWluYXRlQ2hlY2tib3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luZGV0ZXJtaW5hdGVDaGVja2JveCgpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSA9PT0gJ21peGVkJykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAnbWl4ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NMYWJlbCkgJiYgdGhpcy5lbGVtZW50LmluZGV0ZXJtaW5hdGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJDb250YWluZWRDaGVja2JveFN0YXRlLCAnbWl4ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRDaGVja2JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdENoZWNrYm94KCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzTGFiZWwpICYmIHRoaXMuZWxlbWVudC5jaGVja2VkKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmliQ29udGFpbmVkQ2hlY2tib3hTdGF0ZSwgJ3RydWUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NMYWJlbCkpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJDb250YWluZWRDaGVja2JveERpc2FibGVkLCAnZmFsc2UnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NMYWJlbCkgJiYgdGhpcy5lbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmliQ29udGFpbmVkQ2hlY2tib3hEaXNhYmxlZCwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBhc3NvY2lhdGluZyBET00gZWxlbWVudCBhbmQgY29weSBidXR0b24gVUkgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlciBDaGVja2JveC5jb21wb25lbnRzXG4gICAgICogQHR5cGUge1dlYWtNYXB9XG4gICAgICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqIElmIGBvcHRpb25zYCBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLCB7QGxpbmtjb2RlIENoZWNrYm94LmNyZWF0ZSAuY3JlYXRlKCl9LCBvciB7QGxpbmtjb2RlIENoZWNrYm94LmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlIGFuZCBob3cge0BsaW5rY29kZSBDaGVja2JveC5pbml0IC5pbml0KCl9IHdvcmtzLlxuICAgICAqIEBtZW1iZXIgQ2hlY2tib3gub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgZGF0YSBhdHRyaWJ1dGUgdG8gZmluZCBjb3B5IGJ1dHRvbiBVSXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9yQ29udGFpbmVkQ2hlY2tib3hTdGF0ZSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgYSBjb250YWluZXIgb2YgY2hlY2tib3ggcHJlc2VydmluZyBjaGVja2VkIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckNvbnRhaW5lZENoZWNrYm94RGlzYWJsZWRcbiAgICAgKiAgIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBhIGNvbnRhaW5lciBvZiBjaGVja2JveCBwcmVzZXJ2aW5nIGRpc2FibGVkIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjbGFzc0xhYmVsIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBsYWJlbC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY2xhc3NMYWJlbEZvY3VzZWQgVGhlIENTUyBjbGFzcyBmb3IgdGhlIGZvY3VzZWQgbGFiZWwuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYkNvbnRhaW5lZENoZWNrYm94U3RhdGUgVGhlIGF0dHJpYnV0ZSBuYW1lIGZvciB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBjb250YWluZWQgY2hlY2tib3guXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYkNvbnRhaW5lZENoZWNrYm94RGlzYWJsZWQgVGhlIGF0dHJpYnV0ZSBuYW1lIGZvciB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgY29udGFpbmVkIGNoZWNrYm94LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1jaGVja2JveFwiKSxcbiAgICAgICAgc2VsZWN0b3JDb250YWluZWRDaGVja2JveFN0YXRlOiAnW2RhdGEtY29udGFpbmVkLWNoZWNrYm94LXN0YXRlXScsXG4gICAgICAgIHNlbGVjdG9yQ29udGFpbmVkQ2hlY2tib3hEaXNhYmxlZDogJ1tkYXRhLWNvbnRhaW5lZC1jaGVja2JveC1kaXNhYmxlZF0nLFxuICAgICAgICBjbGFzc0xhYmVsOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1jaGVja2JveC1sYWJlbFwiKSxcbiAgICAgICAgY2xhc3NMYWJlbEZvY3VzZWQ6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWNoZWNrYm94LWxhYmVsX19mb2N1c1wiKSxcbiAgICAgICAgYXR0cmliQ29udGFpbmVkQ2hlY2tib3hTdGF0ZTogJ2RhdGEtY29udGFpbmVkLWNoZWNrYm94LXN0YXRlJyxcbiAgICAgICAgYXR0cmliQ29udGFpbmVkQ2hlY2tib3hEaXNhYmxlZDogJ2RhdGEtY29udGFpbmVkLWNoZWNrYm94LWRpc2FibGVkJ1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBDaGVja2JveC5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgQ2hlY2tib3guc3RhdGVDaGFuZ2VUeXBlcyA9IHN0YXRlQ2hhbmdlVHlwZXM7XG4gIHJldHVybiBDaGVja2JveDtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3g7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcblxudmFyIENvZGVTbmlwcGV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKENvZGVTbmlwcGV0LCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ29kZVNuaXBwZXQpO1xuICAvKipcbiAgICogQ29kZVNuaXBwZXQgVUkuXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYSBDb2RlU25pcHBldCBVSS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBDb2RlU25pcHBldChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvZGVTbmlwcGV0KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5faW5pdENvZGVTbmlwcGV0KCk7XG5cbiAgICBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5jbGFzc0V4cGFuZEJ0bikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZUNsaWNrKGV2dCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29kZVNuaXBwZXQsIFt7XG4gICAga2V5OiBcIl9oYW5kbGVDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xpY2soKSB7XG4gICAgICB2YXIgZXhwYW5kQnRuID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmNsYXNzRXhwYW5kVGV4dCk7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wdGlvbnMuY2xhc3NFeHBhbmRlZCk7XG5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMub3B0aW9ucy5jbGFzc0V4cGFuZGVkKSkge1xuICAgICAgICBleHBhbmRCdG4udGV4dENvbnRlbnQgPSBleHBhbmRCdG4uZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJTaG93TGVzc1RleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwYW5kQnRuLnRleHRDb250ZW50ID0gZXhwYW5kQnRuLmdldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmliU2hvd01vcmVUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRDb2RlU25pcHBldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdENvZGVTbmlwcGV0KCkge1xuICAgICAgdmFyIGV4cGFuZEJ0biA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5jbGFzc0V4cGFuZFRleHQpO1xuXG4gICAgICBpZiAoIWV4cGFuZEJ0bikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZmluZCB0aGUgZXhwYW5kIGJ1dHRvbi4nKTtcbiAgICAgIH1cblxuICAgICAgZXhwYW5kQnRuLnRleHRDb250ZW50ID0gZXhwYW5kQnRuLmdldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmliU2hvd01vcmVUZXh0KTtcblxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc0hpZGVFeHBhbmQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBjb2RlIHNuaXBwZXQgVUkgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlciBDb2RlU25pcHBldC5jb21wb25lbnRzXG4gICAgICogQHR5cGUge1dlYWtNYXB9XG4gICAgICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqIElmIGBvcHRpb25zYCBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLCB7QGxpbmtjb2RlIENvZGVTbmlwcGV0LmNyZWF0ZSAuY3JlYXRlKCl9LFxuICAgICAqIG9yIHtAbGlua2NvZGUgQ29kZVNuaXBwZXQuaW5pdCAuaW5pdCgpfSxcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBvdmVycmlkZW4gZm9yIHRoZSBpbnN0YW5jZSBiZWluZyBjcmVhdGUgYW5kIGhvdyB7QGxpbmtjb2RlIENvZGVTbmlwcGV0LmluaXQgLmluaXQoKX0gd29ya3MuXG4gICAgICogQG1lbWJlciBDb2RlU25pcHBldC5vcHRpb25zXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JJbml0IFRoZSBkYXRhIGF0dHJpYnV0ZSB0byBmaW5kIGNvZGUgc25pcHBldCBVSXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLWNvZGUtc25pcHBldF0nLFxuICAgICAgICBhdHRyaWJTaG93TW9yZVRleHQ6ICdkYXRhLXNob3ctbW9yZS10ZXh0JyxcbiAgICAgICAgYXR0cmliU2hvd0xlc3NUZXh0OiAnZGF0YS1zaG93LWxlc3MtdGV4dCcsXG4gICAgICAgIG1pbkhlaWdodDogMjg4LFxuICAgICAgICBjbGFzc0V4cGFuZGVkOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zbmlwcGV0LS1leHBhbmRcIiksXG4gICAgICAgIGNsYXNzRXhwYW5kQnRuOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tc25pcHBldC1idG4tLWV4cGFuZFwiKSxcbiAgICAgICAgY2xhc3NFeHBhbmRUZXh0OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tc25pcHBldC1idG4tLXRleHRcIiksXG4gICAgICAgIGNsYXNzSGlkZUV4cGFuZDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tc25pcHBldC1idG4tLWV4cGFuZC0taGlkZVwiKVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBDb2RlU25pcHBldC5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIENvZGVTbmlwcGV0O1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeVNlYXJjaCwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBDb2RlU25pcHBldDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBldmVudGVkU3RhdGUgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvZXZlbnRlZC1zdGF0ZSc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL2V2ZW50LW1hdGNoZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59O1xuXG52YXIgQ29udGVudFN3aXRjaGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKENvbnRlbnRTd2l0Y2hlciwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvbnRlbnRTd2l0Y2hlcik7XG4gIC8qKlxuICAgKiBTZXQgb2YgY29udGVudCBzd2l0Y2hlciBidXR0b25zLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEV2ZW50ZWRTdGF0ZVxuICAgKiBAZXh0ZW5kcyBIYW5kbGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhIHNldCBvZiBjb250ZW50IHN3aXRjaGVyIGJ1dHRvbnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JCdXR0b25dIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBzd2l0Y2hlciBidXR0b25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JCdXR0b25TZWxlY3RlZF0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBzZWxlY3RlZCBzd2l0Y2hlciBidXR0b24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0FjdGl2ZV0gVGhlIENTUyBjbGFzcyBmb3Igc3dpdGNoZXIgYnV0dG9uJ3Mgc2VsZWN0ZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEJlZm9yZVNlbGVjdGVkXVxuICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgYmVmb3JlIGEgc3dpdGNoZXIgYnV0dG9uIGlzIHNlbGVjdGVkLlxuICAgKiAgIENhbmNlbGxhdGlvbiBvZiB0aGlzIGV2ZW50IHN0b3BzIHNlbGVjdGlvbiBvZiBjb250ZW50IHN3aXRjaGVyIGJ1dHRvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmV2ZW50QWZ0ZXJTZWxlY3RlZF0gVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCBmaXJlZCBhZnRlciBhIHN3aXRjaGVyIGJ1dHRvbiBpcyBzZWxlY3RlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBDb250ZW50U3dpdGNoZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZW50U3dpdGNoZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVDbGljayhldmVudCk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGNsaWNrIG9uIGNvbnRlbnQgc3dpdGNoZXIgYnV0dG9uIHNldC5cbiAgICogSWYgdGhlIGNsaWNrIGlzIG9uIGEgY29udGVudCBzd2l0Y2hlciBidXR0b24sIGFjdGl2YXRlcyBpdC5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRyaWdnZXJpbmcgdGhpcyBtZXRob2QuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRlbnRTd2l0Y2hlciwgW3tcbiAgICBrZXk6IFwiX2hhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDbGljayhldmVudCkge1xuICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50TWF0Y2hlcyhldmVudCwgdGhpcy5vcHRpb25zLnNlbGVjdG9yQnV0dG9uKTtcblxuICAgICAgaWYgKGJ1dHRvbikge1xuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKHtcbiAgICAgICAgICBncm91cDogJ3NlbGVjdGVkJyxcbiAgICAgICAgICBpdGVtOiBidXR0b24sXG4gICAgICAgICAgbGF1bmNoaW5nRXZlbnQ6IGV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2Qgb2Yge0BsaW5rY29kZSBDb250ZW50U3dpdGNoZXIjc2V0QWN0aXZlIC5zZXRBY3RpdmUoKX0sIHRvIHNlbGVjdCBhIGNvbnRlbnQgc3dpdGNoZXIgYnV0dG9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbCBUaGUgZGV0YWlsIG9mIHRoZSBldmVudCB0cmlnZ2luZyB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZXRhaWwuaXRlbSBUaGUgYnV0dG9uIHRvIGJlIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGNhbGxlZCB3aGVuIGNoYW5nZSBpbiBzdGF0ZSBjb21wbGV0ZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2hhbmdlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoYW5nZVN0YXRlKF9yZWYsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGl0ZW0gPSBfcmVmLml0ZW07IC8vIGBvcHRpb25zLnNlbGVjdG9yTGlua2AgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBjbGFzcyBpdHNlbGYsIGNvZGUgaGVyZSBwcmltYXJ5IGlzIGZvciBpbmhlcml0ZWQgY2xhc3Nlc1xuXG4gICAgICB2YXIgaXRlbUxpbmsgPSBpdGVtLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yTGluayk7XG5cbiAgICAgIGlmIChpdGVtTGluaykge1xuICAgICAgICB0b0FycmF5KHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5zZWxlY3RvckxpbmspKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgaWYgKGxpbmsgIT09IGl0ZW1MaW5rKSB7XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1MaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RvckJ1dHRvbnMgPSB0b0FycmF5KHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5zZWxlY3RvckJ1dHRvbikpO1xuICAgICAgc2VsZWN0b3JCdXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGJ1dHRvbikge1xuICAgICAgICBpZiAoYnV0dG9uICE9PSBpdGVtKSB7XG4gICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShfdGhpczIub3B0aW9ucy5jbGFzc0FjdGl2ZSwgZmFsc2UpO1xuICAgICAgICAgIHRvQXJyYXkoYnV0dG9uLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChidXR0b24uZGF0YXNldC50YXJnZXQpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJycpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVtLmNsYXNzTGlzdC50b2dnbGUodGhpcy5vcHRpb25zLmNsYXNzQWN0aXZlLCB0cnVlKTtcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICB0b0FycmF5KGl0ZW0ub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGl0ZW0uZGF0YXNldC50YXJnZXQpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBjb250ZW50IHN3aXRjaGVyIGJ1dHRvbi5cbiAgICAgKiBJZiB0aGUgc2VsZWN0ZWQgYnV0dG9uIGhhcyBgZGF0YS10YXJnZXRgIGF0dHJpYnV0ZSwgRE9NIGVsZW1lbnRzIGl0IHBvaW50cyB0byBhcyBhIENTUyBzZWxlY3RvciB3aWxsIGJlIHNob3duLlxuICAgICAqIERPTSBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGggdW5zZWxlY3RlZCBidXR0b25zIGluIHRoZSBzYW1lIHdheSB3aWxsIGJlIGhpZGRlbi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIFRoZSBidXR0b24gdG8gYmUgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtDaGFuZ2VTdGF0ZX5jYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBvbmNlIHNlbGVjdGlvbiBpcyBmaW5pc2hlZFxuICAgICAqIG9yIGlzIGNhbmNlbGVkLiBXaWxsIG9ubHkgaW52b2tlIGNhbGxiYWNrIGlmIGl0J3MgcGFzc2VkIGluLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QWN0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFjdGl2ZShpdGVtLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSh7XG4gICAgICAgIGdyb3VwOiAnc2VsZWN0ZWQnLFxuICAgICAgICBpdGVtOiBpdGVtXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhPYmplY3QuYXNzaWduKGVycm9yLCB7XG4gICAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIGNvbnRlbnQgc3dpdGNoZXIgc2V0IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXIgQ29udGVudFN3aXRjaGVyLmNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBDb250ZW50U3dpdGNoZXIuY3JlYXRlIC5jcmVhdGUoKX0sIG9yIHtAbGlua2NvZGUgQ29udGVudFN3aXRjaGVyLmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlIGFuZCBob3cge0BsaW5rY29kZSBDb250ZW50U3dpdGNoZXIuaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAbWVtYmVyIENvbnRlbnRTd2l0Y2hlci5vcHRpb25zXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JJbml0IFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBjb250ZW50IHN3aXRjaGVyIGJ1dHRvbiBzZXQuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvckJ1dHRvbl0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHN3aXRjaGVyIGJ1dHRvbnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvckJ1dHRvblNlbGVjdGVkXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHNlbGVjdGVkIHN3aXRjaGVyIGJ1dHRvbi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzQWN0aXZlXSBUaGUgQ1NTIGNsYXNzIGZvciBzd2l0Y2hlciBidXR0b24ncyBzZWxlY3RlZCBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50QmVmb3JlU2VsZWN0ZWRdXG4gICAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIGJlZm9yZSBhIHN3aXRjaGVyIGJ1dHRvbiBpcyBzZWxlY3RlZC5cbiAgICAgKiAgIENhbmNlbGxhdGlvbiBvZiB0aGlzIGV2ZW50IHN0b3BzIHNlbGVjdGlvbiBvZiBjb250ZW50IHN3aXRjaGVyIGJ1dHRvbi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50QWZ0ZXJTZWxlY3RlZF0gVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCBmaXJlZCBhZnRlciBhIHN3aXRjaGVyIGJ1dHRvbiBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtY29udGVudC1zd2l0Y2hlcl0nLFxuICAgICAgICBzZWxlY3RvckJ1dHRvbjogXCJpbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdLCAuXCIuY29uY2F0KHByZWZpeCwgXCItLWNvbnRlbnQtc3dpdGNoZXItYnRuXCIpLFxuICAgICAgICBjbGFzc0FjdGl2ZTogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tY29udGVudC1zd2l0Y2hlci0tc2VsZWN0ZWRcIiksXG4gICAgICAgIGV2ZW50QmVmb3JlU2VsZWN0ZWQ6ICdjb250ZW50LXN3aXRjaGVyLWJlaW5nc2VsZWN0ZWQnLFxuICAgICAgICBldmVudEFmdGVyU2VsZWN0ZWQ6ICdjb250ZW50LXN3aXRjaGVyLXNlbGVjdGVkJ1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBDb250ZW50U3dpdGNoZXIuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBDb250ZW50U3dpdGNoZXI7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBldmVudGVkU3RhdGUsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29udGVudFN3aXRjaGVyOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIENvcHlCdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoQ29weUJ1dHRvbiwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvcHlCdXR0b24pO1xuICAvKipcbiAgICogQ29weUJ0biBVSS5cbiAgICogQGV4dGVuZHMgQ3JlYXRlQ29tcG9uZW50XG4gICAqIEBleHRlbmRzIEluaXRDb21wb25lbnRCeVNlYXJjaFxuICAgKiBAZXh0ZW5kcyBIYW5kbGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhIGNvcHkgYnV0dG9uIFVJLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENvcHlCdXR0b24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3B5QnV0dG9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUNsaWNrKCk7XG4gICAgfSkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdhbmltYXRpb25lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVBbmltYXRpb25FbmQoZXZlbnQpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xlYW51cCBhbmltYXRpb24gY2xhc3Nlc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDb3B5QnV0dG9uLCBbe1xuICAgIGtleTogXCJoYW5kbGVBbmltYXRpb25FbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQW5pbWF0aW9uRW5kKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuYW5pbWF0aW9uTmFtZSA9PT0gJ2hpZGUtZmVlZGJhY2snKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc0FuaW1hdGluZyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc0ZhZGVPdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBmZWVkYmFjayB0b29sdGlwIG9uIGNsaWNrLiBIaWRlIHRoZSBmZWVkYmFjayB0b29sdGlwIGFmdGVyIHNwZWNpZmllZCB0aW1lb3V0IHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZlZWRiYWNrID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmZlZWRiYWNrVG9vbHRpcCk7XG5cbiAgICAgIGlmIChmZWVkYmFjaykge1xuICAgICAgICBmZWVkYmFjay5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc1Nob3dGZWVkYmFjayk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZlZWRiYWNrLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMyLm9wdGlvbnMuY2xhc3NTaG93RmVlZGJhY2spO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc0FuaW1hdGluZyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc0ZhZGVJbik7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMyLm9wdGlvbnMuY2xhc3NGYWRlSW4pO1xuXG4gICAgICAgICAgX3RoaXMyLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChfdGhpczIub3B0aW9ucy5jbGFzc0ZhZGVPdXQpO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBhc3NvY2lhdGluZyBET00gZWxlbWVudCBhbmQgY29weSBidXR0b24gVUkgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlciBDb3B5QnRuLmNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsIHtAbGlua2NvZGUgQ29weUJ0bi5jcmVhdGUgLmNyZWF0ZSgpfSwgb3Ige0BsaW5rY29kZSBDb3B5QnRuLmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlIGFuZCBob3cge0BsaW5rY29kZSBDb3B5QnRuLmluaXQgLmluaXQoKX0gd29ya3MuXG4gICAgICogQG1lbWJlciBDb3B5QnRuLm9wdGlvbnNcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIGRhdGEgYXR0cmlidXRlIHRvIGZpbmQgY29weSBidXR0b24gVUlzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmZWVkYmFja1Rvb2x0aXAgVGhlIGRhdGEgYXR0cmlidXRlIHRvIGZpbmQgZmVlZGJhY2sgdG9vbHRpcC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY2xhc3NTaG93RmVlZGJhY2sgVGhlIENTUyBzZWxlY3RvciBmb3Igc2hvd2luZyB0aGUgZmVlZGJhY2sgdG9vbHRpcC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZW91dFZhbHVlIFRoZSBzcGVjaWZpZWQgdGltZW91dCB2YWx1ZSBiZWZvcmUgdGhlIGZlZWRiYWNrIHRvb2x0aXAgaXMgaGlkZGVuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS1jb3B5LWJ0bl0nLFxuICAgICAgICBmZWVkYmFja1Rvb2x0aXA6ICdbZGF0YS1mZWVkYmFja10nLFxuICAgICAgICBjbGFzc1Nob3dGZWVkYmFjazogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tYnRuLS1jb3B5X19mZWVkYmFjay0tZGlzcGxheWVkXCIpLFxuICAgICAgICBjbGFzc0FuaW1hdGluZzogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tY29weS1idG4tLWFuaW1hdGluZ1wiKSxcbiAgICAgICAgY2xhc3NGYWRlSW46IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWNvcHktYnRuLS1mYWRlLWluXCIpLFxuICAgICAgICBjbGFzc0ZhZGVPdXQ6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWNvcHktYnRuLS1mYWRlLW91dFwiKSxcbiAgICAgICAgdGltZW91dFZhbHVlOiAyMDAwXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIENvcHlCdXR0b24uY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBDb3B5QnV0dG9uO1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeVNlYXJjaCwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBDb3B5QnV0dG9uOyIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgRGF0YVRhYmxlVjIgZnJvbSAnLi4vZGF0YS10YWJsZS9kYXRhLXRhYmxlJztcbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZVYyOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgZXZlbnRlZFN0YXRlIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2V2ZW50ZWQtc3RhdGUnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgZXZlbnRNYXRjaGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9ldmVudC1tYXRjaGVzJztcbmltcG9ydCBvbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2Mvb24nO1xuXG52YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoYXJyYXlMaWtlKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UpO1xufTtcblxudmFyIERhdGFUYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhEYXRhVGFibGUsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEYXRhVGFibGUpO1xuICAvKipcbiAgICogRGF0YSBUYWJsZVxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzICAgRXZlbnRlZFN0YXRlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIHJvb3QgZWxlbWVudCBvZiB0YWJsZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSB0aGUuLi4gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JJbml0XSBzZWxlY3RvciBpbml0aWFsaXphdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JFeHBhbmRDZWxsc10gY3NzIHNlbGVjdG9yIGZvciBleHBhbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmV4cGFuZGFibGVSb3ddIGNzcyBzZWxlY3RvciBmb3IgZXhwYW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclBhcmVudFJvd3NdIGNzcyBzZWxlY3RvciBmb3Igcm93cyBob3VzaW5nIGV4cGFuc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JUYWJsZUJvZHldIHJvb3QgY3NzIGZvciB0YWJsZSBib2R5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudFRyaWdnZXJdIHNlbGVjdG9yIGZvciBldmVudCBidWJibGUgY2FwdHVyZSBwb2ludHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmV2ZW50UGFyZW50Q29udGFpbmVyXSB1c2VkIGZpbmQgdGhlIGJ1YmJsZSBjb250YWluZXJcbiAgICovXG5cblxuICBmdW5jdGlvbiBEYXRhVGFibGUoX2VsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVRhYmxlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX2VsZW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMuX3NvcnRUb2dnbGUgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGRldGFpbC5lbGVtZW50LFxuICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBkZXRhaWwucHJldmlvdXNWYWx1ZTtcbiAgICAgIHRvQXJyYXkoX3RoaXMudGFibGVIZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgdmFyIHNvcnRFbCA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUYWJsZVNvcnQpO1xuXG4gICAgICAgIGlmIChzb3J0RWwgIT09IG51bGwgJiYgc29ydEVsICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgc29ydEVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1RhYmxlU29ydEFjdGl2ZSk7XG4gICAgICAgICAgc29ydEVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1RhYmxlU29ydEFzY2VuZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5kYXRhc2V0LnByZXZpb3VzVmFsdWUgPSAnYXNjZW5kaW5nJztcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NUYWJsZVNvcnRBY3RpdmUpO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoX3RoaXMub3B0aW9ucy5jbGFzc1RhYmxlU29ydEFzY2VuZGluZyk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzVmFsdWUgPT09ICdhc2NlbmRpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQuZGF0YXNldC5wcmV2aW91c1ZhbHVlID0gJ2Rlc2NlbmRpbmcnO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoX3RoaXMub3B0aW9ucy5jbGFzc1RhYmxlU29ydEFjdGl2ZSk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5vcHRpb25zLmNsYXNzVGFibGVTb3J0QXNjZW5kaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNWYWx1ZSA9PT0gJ2Rlc2NlbmRpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLXZhbHVlJyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5vcHRpb25zLmNsYXNzVGFibGVTb3J0QWN0aXZlKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKF90aGlzLm9wdGlvbnMuY2xhc3NUYWJsZVNvcnRBc2NlbmRpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5fc2VsZWN0VG9nZ2xlID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBkZXRhaWwuZWxlbWVudDtcbiAgICAgIHZhciBjaGVja2VkID0gZWxlbWVudC5jaGVja2VkOyAvLyBpbmNyZW1lbnQgdGhlICBjb3VudFxuXG4gICAgICBfdGhpcy5zdGF0ZS5jaGVja2JveENvdW50ICs9IGNoZWNrZWQgPyAxIDogLTE7XG4gICAgICBfdGhpcy5jb3VudEVsLnRleHRDb250ZW50ID0gX3RoaXMuc3RhdGUuY2hlY2tib3hDb3VudDtcbiAgICAgIHZhciByb3cgPSBlbGVtZW50LnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIHJvdy5jbGFzc0xpc3QudG9nZ2xlKF90aGlzLm9wdGlvbnMuY2xhc3NUYWJsZVNlbGVjdGVkKTsgLy8gdG9nZ2xlIG9uL29mZiBiYXRjaCBhY3Rpb24gYmFyXG5cbiAgICAgIF90aGlzLl9hY3Rpb25CYXJUb2dnbGUoX3RoaXMuc3RhdGUuY2hlY2tib3hDb3VudCA+IDApO1xuICAgIH07XG5cbiAgICBfdGhpcy5fc2VsZWN0QWxsVG9nZ2xlID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuICAgICAgdmFyIGNoZWNrZWQgPSBlbGVtZW50LmNoZWNrZWQ7XG4gICAgICB2YXIgaW5wdXRzID0gdG9BcnJheShfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoX3RoaXMub3B0aW9ucy5zZWxlY3RvckNoZWNrYm94KSk7XG4gICAgICBfdGhpcy5zdGF0ZS5jaGVja2JveENvdW50ID0gY2hlY2tlZCA/IGlucHV0cy5sZW5ndGggLSAxIDogMDtcbiAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgIHZhciByb3cgPSBpdGVtLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICBpZiAoY2hlY2tlZCAmJiByb3cpIHtcbiAgICAgICAgICByb3cuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzVGFibGVTZWxlY3RlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm93LmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1RhYmxlU2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuX2FjdGlvbkJhclRvZ2dsZShfdGhpcy5zdGF0ZS5jaGVja2JveENvdW50ID4gMCk7XG5cbiAgICAgIGlmIChfdGhpcy5iYXRjaEFjdGlvbkVsKSB7XG4gICAgICAgIF90aGlzLmNvdW50RWwudGV4dENvbnRlbnQgPSBfdGhpcy5zdGF0ZS5jaGVja2JveENvdW50O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5fYWN0aW9uQmFyQ2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlucHV0cyA9IHRvQXJyYXkoX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JDaGVja2JveCkpO1xuICAgICAgdmFyIHJvdyA9IHRvQXJyYXkoX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUYWJsZVNlbGVjdGVkKSk7XG4gICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1RhYmxlU2VsZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuc3RhdGUuY2hlY2tib3hDb3VudCA9IDA7XG5cbiAgICAgIF90aGlzLl9hY3Rpb25CYXJUb2dnbGUoZmFsc2UpO1xuXG4gICAgICBpZiAoX3RoaXMuYmF0Y2hBY3Rpb25FbCkge1xuICAgICAgICBfdGhpcy5jb3VudEVsLnRleHRDb250ZW50ID0gX3RoaXMuc3RhdGUuY2hlY2tib3hDb3VudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX2FjdGlvbkJhclRvZ2dsZSA9IGZ1bmN0aW9uICh0b2dnbGVPbikge1xuICAgICAgdmFyIGhhbmRsZVRyYW5zaXRpb25FbmQ7XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGhhbmRsZVRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgICBoYW5kbGVUcmFuc2l0aW9uRW5kID0gX3RoaXMudW5tYW5hZ2UoaGFuZGxlVHJhbnNpdGlvbkVuZCkucmVsZWFzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2dC50YXJnZXQubWF0Y2hlcyhfdGhpcy5vcHRpb25zLnNlbGVjdG9yQWN0aW9ucykpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuYmF0Y2hBY3Rpb25FbC5kYXRhc2V0LmFjdGl2ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgX3RoaXMuYmF0Y2hBY3Rpb25FbC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgLTEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5iYXRjaEFjdGlvbkVsLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0b2dnbGVPbikge1xuICAgICAgICBfdGhpcy5iYXRjaEFjdGlvbkVsLmRhdGFzZXQuYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5iYXRjaEFjdGlvbkVsLmNsYXNzTGlzdC5hZGQoX3RoaXMub3B0aW9ucy5jbGFzc0FjdGlvbkJhckFjdGl2ZSk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLmJhdGNoQWN0aW9uRWwpIHtcbiAgICAgICAgX3RoaXMuYmF0Y2hBY3Rpb25FbC5kYXRhc2V0LmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLmJhdGNoQWN0aW9uRWwuY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5vcHRpb25zLmNsYXNzQWN0aW9uQmFyQWN0aXZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmJhdGNoQWN0aW9uRWwpIHtcbiAgICAgICAgaGFuZGxlVHJhbnNpdGlvbkVuZCA9IF90aGlzLm1hbmFnZShvbihfdGhpcy5iYXRjaEFjdGlvbkVsLCAndHJhbnNpdGlvbmVuZCcsIHRyYW5zaXRpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX3Jvd0V4cGFuZFRvZ2dsZSA9IGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfcmVmMi5lbGVtZW50LFxuICAgICAgICAgIGZvcmNlRXhwYW5kID0gX3JlZjIuZm9yY2VFeHBhbmQ7XG4gICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5jbG9zZXN0KF90aGlzLm9wdGlvbnMuZXZlbnRQYXJlbnRDb250YWluZXIpOyAvLyBOT1RFOiBgZGF0YS1wcmV2aW91cy12YWx1ZWAga2VlcHMgVUkgc3RhdGUgYmVmb3JlIHRoaXMgbWV0aG9kIG1ha2VzIGNoYW5nZSBpbiBzdHlsZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG4gICAgICB2YXIgc2hvdWxkRXhwYW5kID0gZm9yY2VFeHBhbmQgIT0gbnVsbCA/IGZvcmNlRXhwYW5kIDogZWxlbWVudC5kYXRhc2V0LnByZXZpb3VzVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBlbGVtZW50LmRhdGFzZXQucHJldmlvdXNWYWx1ZSA9PT0gJ2V4cGFuZGVkJztcblxuICAgICAgaWYgKHNob3VsZEV4cGFuZCkge1xuICAgICAgICBlbGVtZW50LmRhdGFzZXQucHJldmlvdXNWYWx1ZSA9ICdjb2xsYXBzZWQnO1xuICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzRXhwYW5kYWJsZVJvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5vcHRpb25zLmNsYXNzRXhwYW5kYWJsZVJvdyk7XG4gICAgICAgIGVsZW1lbnQuZGF0YXNldC5wcmV2aW91c1ZhbHVlID0gJ2V4cGFuZGVkJztcblxuICAgICAgICB2YXIgZXhwYW5kSGVhZGVyID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JFeHBhbmRIZWFkZXIpO1xuXG4gICAgICAgIGlmIChleHBhbmRIZWFkZXIpIHtcbiAgICAgICAgICBleHBhbmRIZWFkZXIuZGF0YXNldC5wcmV2aW91c1ZhbHVlID0gJ2V4cGFuZGVkJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5fcm93RXhwYW5kVG9nZ2xlQWxsID0gZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IF9yZWYzLmVsZW1lbnQ7IC8vIE5PVEU6IGBkYXRhLXByZXZpb3VzLXZhbHVlYCBrZWVwcyBVSSBzdGF0ZSBiZWZvcmUgdGhpcyBtZXRob2QgbWFrZXMgY2hhbmdlIGluIHN0eWxlXG5cbiAgICAgIHZhciBzaG91bGRFeHBhbmQgPSBlbGVtZW50LmRhdGFzZXQucHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGVsZW1lbnQuZGF0YXNldC5wcmV2aW91c1ZhbHVlID09PSAnZXhwYW5kZWQnO1xuICAgICAgZWxlbWVudC5kYXRhc2V0LnByZXZpb3VzVmFsdWUgPSBzaG91bGRFeHBhbmQgPyAnY29sbGFwc2VkJyA6ICdleHBhbmRlZCc7XG5cbiAgICAgIHZhciBleHBhbmRDZWxscyA9IF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChfdGhpcy5vcHRpb25zLnNlbGVjdG9yRXhwYW5kQ2VsbHMpO1xuXG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGV4cGFuZENlbGxzLCBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBfdGhpcy5fcm93RXhwYW5kVG9nZ2xlKHtcbiAgICAgICAgICBlbGVtZW50OiBjZWxsLFxuICAgICAgICAgIGZvcmNlRXhwYW5kOiBzaG91bGRFeHBhbmRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2V4cGFuZGFibGVIb3ZlclRvZ2dsZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnRNYXRjaGVzKGV2dCwgX3RoaXMub3B0aW9ucy5zZWxlY3RvckNoaWxkUm93KTtcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmNsYXNzTGlzdC50b2dnbGUoX3RoaXMub3B0aW9ucy5jbGFzc0V4cGFuZGFibGVSb3dIb3ZlciwgZXZ0LnR5cGUgPT09ICdtb3VzZW92ZXInKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX3RvZ2dsZVN0YXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2dCkge1xuICAgICAgdmFyIGRhdGEgPSBlbGVtZW50LmRhdGFzZXQ7XG4gICAgICB2YXIgbGFiZWwgPSBkYXRhLmxhYmVsID8gZGF0YS5sYWJlbCA6ICcnO1xuICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSBkYXRhLnByZXZpb3VzVmFsdWUgPyBkYXRhLnByZXZpb3VzVmFsdWUgOiAnJztcbiAgICAgIHZhciBpbml0aWFsRXZ0ID0gZXZ0O1xuXG4gICAgICBfdGhpcy5jaGFuZ2VTdGF0ZSh7XG4gICAgICAgIGdyb3VwOiBkYXRhLmV2ZW50LFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIHByZXZpb3VzVmFsdWU6IHByZXZpb3VzVmFsdWUsXG4gICAgICAgIGluaXRpYWxFdnQ6IGluaXRpYWxFdnRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICB2YXIgc2VhcmNoQ29udGFpbmVyID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUb29sYmFyU2VhcmNoQ29udGFpbmVyKTtcblxuICAgICAgdmFyIHNlYXJjaEV2ZW50ID0gZXZlbnRNYXRjaGVzKGV2dCwgX3RoaXMub3B0aW9ucy5zZWxlY3RvclNlYXJjaE1hZ25pZmllcik7XG4gICAgICB2YXIgYWN0aXZlU2VhcmNoID0gc2VhcmNoQ29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhfdGhpcy5vcHRpb25zLmNsYXNzVG9vbGJhclNlYXJjaEFjdGl2ZSk7XG5cbiAgICAgIGlmIChldnQud2hpY2ggPT09IDI3KSB7XG4gICAgICAgIF90aGlzLl9hY3Rpb25CYXJDYW5jZWwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaENvbnRhaW5lciAmJiBzZWFyY2hFdmVudCAmJiBldnQud2hpY2ggPT09IDEzKSB7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlU2VhcmNoKHNlYXJjaENvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVTZWFyY2ggJiYgZXZ0LndoaWNoID09PSAyNykge1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlU2VhcmNoKHNlYXJjaENvbnRhaW5lciwgZXZ0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMucmVmcmVzaFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV3RXhwYW5kQ2VsbHMgPSB0b0FycmF5KF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChfdGhpcy5vcHRpb25zLnNlbGVjdG9yRXhwYW5kQ2VsbHMpKTtcbiAgICAgIHZhciBuZXdFeHBhbmRhYmxlUm93cyA9IHRvQXJyYXkoX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JFeHBhbmRhYmxlUm93cykpO1xuICAgICAgdmFyIG5ld1BhcmVudFJvd3MgPSB0b0FycmF5KF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChfdGhpcy5vcHRpb25zLnNlbGVjdG9yUGFyZW50Um93cykpOyAvLyBjaGVjayBpZiB0aGlzIGlzIGEgcmVmcmVzaCBvciB0aGUgZmlyc3QgdGltZVxuXG4gICAgICBpZiAoX3RoaXMucGFyZW50Um93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBkaWZmUGFyZW50Um93cyA9IG5ld1BhcmVudFJvd3MuZmlsdGVyKGZ1bmN0aW9uIChuZXdSb3cpIHtcbiAgICAgICAgICByZXR1cm4gIV90aGlzLnBhcmVudFJvd3Muc29tZShmdW5jdGlvbiAob2xkUm93KSB7XG4gICAgICAgICAgICByZXR1cm4gb2xkUm93ID09PSBuZXdSb3c7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pOyAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZXhwYW5kYWJsZSByb3dzXG5cbiAgICAgICAgaWYgKG5ld0V4cGFuZGFibGVSb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgZGlmZkV4cGFuZGFibGVSb3dzID0gZGlmZlBhcmVudFJvd3MubWFwKGZ1bmN0aW9uIChuZXdSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdSb3cubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBtZXJnZWRFeHBhbmRhYmxlUm93cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodG9BcnJheShfdGhpcy5leHBhbmRhYmxlUm93cykpLCBfdG9Db25zdW1hYmxlQXJyYXkodG9BcnJheShkaWZmRXhwYW5kYWJsZVJvd3MpKSk7XG4gICAgICAgICAgX3RoaXMuZXhwYW5kYWJsZVJvd3MgPSBtZXJnZWRFeHBhbmRhYmxlUm93cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdFeHBhbmRhYmxlUm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIF90aGlzLmV4cGFuZGFibGVSb3dzID0gbmV3RXhwYW5kYWJsZVJvd3M7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmV4cGFuZENlbGxzID0gbmV3RXhwYW5kQ2VsbHM7XG4gICAgICBfdGhpcy5wYXJlbnRSb3dzID0gbmV3UGFyZW50Um93cztcbiAgICB9O1xuXG4gICAgX3RoaXMuY29udGFpbmVyID0gX2VsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBfdGhpcy50b29sYmFyRWwgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRvb2xiYXIpO1xuICAgIF90aGlzLmJhdGNoQWN0aW9uRWwgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckFjdGlvbnMpO1xuICAgIF90aGlzLmNvdW50RWwgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckNvdW50KTtcbiAgICBfdGhpcy5jYW5jZWxFbCA9IF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yQWN0aW9uQ2FuY2VsKTtcbiAgICBfdGhpcy50YWJsZUhlYWRlcnMgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoJyk7XG4gICAgX3RoaXMudGFibGVCb2R5ID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUYWJsZUJvZHkpO1xuICAgIF90aGlzLmV4cGFuZENlbGxzID0gW107XG4gICAgX3RoaXMuZXhwYW5kYWJsZVJvd3MgPSBbXTtcbiAgICBfdGhpcy5wYXJlbnRSb3dzID0gW107XG5cbiAgICBfdGhpcy5yZWZyZXNoUm93cygpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdtb3VzZW92ZXInLCBfdGhpcy5fZXhwYW5kYWJsZUhvdmVyVG9nZ2xlKSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ21vdXNlb3V0JywgX3RoaXMuX2V4cGFuZGFibGVIb3ZlclRvZ2dsZSkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHZhciBldmVudEVsZW1lbnQgPSBldmVudE1hdGNoZXMoZXZ0LCBfdGhpcy5vcHRpb25zLmV2ZW50VHJpZ2dlcik7XG5cbiAgICAgIHZhciBzZWFyY2hDb250YWluZXIgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRvb2xiYXJTZWFyY2hDb250YWluZXIpO1xuXG4gICAgICBpZiAoZXZlbnRFbGVtZW50KSB7XG4gICAgICAgIF90aGlzLl90b2dnbGVTdGF0ZShldmVudEVsZW1lbnQsIGV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2hDb250YWluZXIpIHtcbiAgICAgICAgX3RoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2soZXZ0KTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2tleWRvd24nLCBfdGhpcy5fa2V5ZG93bkhhbmRsZXIpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgY2hlY2tib3hDb3VudDogMFxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFUYWJsZSwgW3tcbiAgICBrZXk6IFwiX2hhbmRsZURvY3VtZW50Q2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURvY3VtZW50Q2xpY2soZXZ0KSB7XG4gICAgICB2YXIgc2VhcmNoQ29udGFpbmVyID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yVG9vbGJhclNlYXJjaENvbnRhaW5lcik7XG4gICAgICB2YXIgc2VhcmNoRXZlbnQgPSBldmVudE1hdGNoZXMoZXZ0LCB0aGlzLm9wdGlvbnMuc2VsZWN0b3JTZWFyY2hNYWduaWZpZXIpO1xuICAgICAgdmFyIGFjdGl2ZVNlYXJjaCA9IHNlYXJjaENvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzVG9vbGJhclNlYXJjaEFjdGl2ZSk7XG5cbiAgICAgIGlmIChzZWFyY2hDb250YWluZXIgJiYgc2VhcmNoRXZlbnQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZVNlYXJjaChzZWFyY2hDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlU2VhcmNoKSB7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZVNlYXJjaChzZWFyY2hDb250YWluZXIsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFjdGl2YXRlU2VhcmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2YXRlU2VhcmNoKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGlucHV0ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yU2VhcmNoSW5wdXQpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNsYXNzVG9vbGJhclNlYXJjaEFjdGl2ZSk7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWFjdGl2YXRlU2VhcmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYWN0aXZhdGVTZWFyY2goY29udGFpbmVyLCBldnQpIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yU2VhcmNoTWFnbmlmaWVyKTtcbiAgICAgIHZhciBpbnB1dCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvclNlYXJjaElucHV0KTtcbiAgICAgIHZhciBzdmcgPSB0cmlnZ2VyLnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xuXG4gICAgICBpZiAoaW5wdXQudmFsdWUubGVuZ3RoID09PSAwICYmIGV2dC50YXJnZXQgIT09IGlucHV0ICYmIGV2dC50YXJnZXQgIT09IHRyaWdnZXIgJiYgZXZ0LnRhcmdldCAhPT0gc3ZnKSB7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc1Rvb2xiYXJTZWFyY2hBY3RpdmUpO1xuICAgICAgICB0cmlnZ2VyLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldnQud2hpY2ggPT09IDI3ICYmIGV2dC50YXJnZXQgPT09IGlucHV0KSB7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc1Rvb2xiYXJTZWFyY2hBY3RpdmUpO1xuICAgICAgICB0cmlnZ2VyLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jaGFuZ2VTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hhbmdlU3RhdGUoZGV0YWlsLCBjYWxsYmFjaykge1xuICAgICAgdGhpc1t0aGlzLmNvbnN0cnVjdG9yLmV2ZW50SGFuZGxlcnNbZGV0YWlsLmdyb3VwXV0oZGV0YWlsKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogXCJbZGF0YS10YWJsZV1cIixcbiAgICAgICAgc2VsZWN0b3JUb29sYmFyOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tdGFibGUtLXRvb2xiYXJcIiksXG4gICAgICAgIHNlbGVjdG9yQWN0aW9uczogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWJhdGNoLWFjdGlvbnNcIiksXG4gICAgICAgIHNlbGVjdG9yQ291bnQ6ICdbZGF0YS1pdGVtcy1zZWxlY3RlZF0nLFxuICAgICAgICBzZWxlY3RvckFjdGlvbkNhbmNlbDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWJhdGNoLXN1bW1hcnlfX2NhbmNlbFwiKSxcbiAgICAgICAgc2VsZWN0b3JDaGVja2JveDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWNoZWNrYm94XCIpLFxuICAgICAgICBzZWxlY3RvckV4cGFuZEhlYWRlcjogXCJ0aC5cIi5jb25jYXQocHJlZml4LCBcIi0tdGFibGUtZXhwYW5kXCIpLFxuICAgICAgICBzZWxlY3RvckV4cGFuZENlbGxzOiBcInRkLlwiLmNvbmNhdChwcmVmaXgsIFwiLS10YWJsZS1leHBhbmRcIiksXG4gICAgICAgIHNlbGVjdG9yRXhwYW5kYWJsZVJvd3M6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1leHBhbmRhYmxlLXJvd1wiKSxcbiAgICAgICAgc2VsZWN0b3JQYXJlbnRSb3dzOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tcGFyZW50LXJvd1wiKSxcbiAgICAgICAgc2VsZWN0b3JDaGlsZFJvdzogJ1tkYXRhLWNoaWxkLXJvd10nLFxuICAgICAgICBzZWxlY3RvclRhYmxlQm9keTogJ3Rib2R5JyxcbiAgICAgICAgc2VsZWN0b3JUYWJsZVNvcnQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS10YWJsZS1zb3J0XCIpLFxuICAgICAgICBzZWxlY3RvclRhYmxlU2VsZWN0ZWQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1kYXRhLXRhYmxlLS1zZWxlY3RlZFwiKSxcbiAgICAgICAgc2VsZWN0b3JUb29sYmFyU2VhcmNoQ29udGFpbmVyOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tdG9vbGJhci1zZWFyY2gtY29udGFpbmVyLWV4cGFuZGFibGVcIiksXG4gICAgICAgIHNlbGVjdG9yU2VhcmNoTWFnbmlmaWVyOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tc2VhcmNoLW1hZ25pZmllclwiKSxcbiAgICAgICAgc2VsZWN0b3JTZWFyY2hJbnB1dDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXNlYXJjaC1pbnB1dFwiKSxcbiAgICAgICAgY2xhc3NFeHBhbmRhYmxlUm93OiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1leHBhbmRhYmxlLXJvd1wiKSxcbiAgICAgICAgY2xhc3NFeHBhbmRhYmxlUm93SGlkZGVuOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1leHBhbmRhYmxlLXJvdy0taGlkZGVuXCIpLFxuICAgICAgICBjbGFzc0V4cGFuZGFibGVSb3dIb3ZlcjogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZXhwYW5kYWJsZS1yb3ctLWhvdmVyXCIpLFxuICAgICAgICBjbGFzc1RhYmxlU29ydEFzY2VuZGluZzogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tdGFibGUtc29ydC0tYXNjZW5kaW5nXCIpLFxuICAgICAgICBjbGFzc1RhYmxlU29ydEFjdGl2ZTogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tdGFibGUtc29ydC0tYWN0aXZlXCIpLFxuICAgICAgICBjbGFzc1Rvb2xiYXJTZWFyY2hBY3RpdmU6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXRvb2xiYXItc2VhcmNoLWNvbnRhaW5lci1hY3RpdmVcIiksXG4gICAgICAgIGNsYXNzQWN0aW9uQmFyQWN0aXZlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1iYXRjaC1hY3Rpb25zLS1hY3RpdmVcIiksXG4gICAgICAgIGNsYXNzVGFibGVTZWxlY3RlZDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZGF0YS10YWJsZS0tc2VsZWN0ZWRcIiksXG4gICAgICAgIGV2ZW50QmVmb3JlRXhwYW5kOiBcImRhdGEtdGFibGUtYmVmb3JldG9nZ2xlZXhwYW5kXCIsXG4gICAgICAgIGV2ZW50QWZ0ZXJFeHBhbmQ6IFwiZGF0YS10YWJsZS1hZnRlcnRvZ2dsZWV4cGFuZFwiLFxuICAgICAgICBldmVudEJlZm9yZUV4cGFuZEFsbDogXCJkYXRhLXRhYmxlLWJlZm9yZXRvZ2dsZWV4cGFuZGFsbFwiLFxuICAgICAgICBldmVudEFmdGVyRXhwYW5kQWxsOiBcImRhdGEtdGFibGUtYWZ0ZXJ0b2dnbGVleHBhbmRhbGxcIixcbiAgICAgICAgZXZlbnRCZWZvcmVTb3J0OiBcImRhdGEtdGFibGUtYmVmb3JldG9nZ2xlc29ydFwiLFxuICAgICAgICBldmVudEFmdGVyU29ydDogXCJkYXRhLXRhYmxlLWFmdGVydG9nZ2xlc29ydFwiLFxuICAgICAgICBldmVudFRyaWdnZXI6ICdbZGF0YS1ldmVudF0nLFxuICAgICAgICBldmVudFBhcmVudENvbnRhaW5lcjogJ1tkYXRhLXBhcmVudC1yb3ddJ1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBEYXRhVGFibGUuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIERhdGFUYWJsZS5ldmVudEhhbmRsZXJzID0ge1xuICAgIGV4cGFuZDogJ19yb3dFeHBhbmRUb2dnbGUnLFxuICAgIGV4cGFuZEFsbDogJ19yb3dFeHBhbmRUb2dnbGVBbGwnLFxuICAgIHNvcnQ6ICdfc29ydFRvZ2dsZScsXG4gICAgc2VsZWN0OiAnX3NlbGVjdFRvZ2dsZScsXG4gICAgJ3NlbGVjdC1hbGwnOiAnX3NlbGVjdEFsbFRvZ2dsZScsXG4gICAgJ2FjdGlvbi1iYXItY2FuY2VsJzogJ19hY3Rpb25CYXJDYW5jZWwnXG4gIH07XG4gIHJldHVybiBEYXRhVGFibGU7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBldmVudGVkU3RhdGUsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IEZsYXRwaWNrciBmcm9tICdmbGF0cGlja3InO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcbi8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogWzIsIHsgXCJhbGxvd1wiOiBbXCJfaW5wdXRcIiwgXCJfdXBkYXRlQ2xhc3NOYW1lc1wiLCBcIl91cGRhdGVJbnB1dEZpZWxkc1wiXSwgXCJhbGxvd0FmdGVyVGhpc1wiOiB0cnVlIH1dICovXG4vLyBgdGhpcy5vcHRpb25zYCBjcmVhdGUtY29tcG9uZW50IG1peC1pbiBjcmVhdGVzIHByb3RvdHlwZSBjaGFpblxuLy8gc28gdGhhdCBgb3B0aW9uc2AgZ2l2ZW4gaW4gY29uc3RydWN0b3IgYXJndW1lbnQgd2lucyBvdmVyIHRoZSBvbmUgZGVmaW5lZCBpbiBzdGF0aWMgYG9wdGlvbnNgIHByb3BlcnR5XG4vLyAnRmxhdHBpY2tyJyB3YW50cyBmbGF0IHN0cnVjdHVyZSBvZiBvYmplY3QgaW5zdGVhZFxuXG5mdW5jdGlvbiBmbGF0dGVuT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBvID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4sIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cblxuICByZXR1cm4gbztcbn0gLy8gV2Vla2RheXMgc2hvcnRoYW5kIGZvciBlbmdsaXNoIGxvY2FsZVxuXG5cbkZsYXRwaWNrci5sMTBucy5lbi53ZWVrZGF5cy5zaG9ydGhhbmQuZm9yRWFjaChmdW5jdGlvbiAoZGF5LCBpbmRleCkge1xuICB2YXIgY3VycmVudERheSA9IEZsYXRwaWNrci5sMTBucy5lbi53ZWVrZGF5cy5zaG9ydGhhbmQ7XG5cbiAgaWYgKGN1cnJlbnREYXlbaW5kZXhdID09PSAnVGh1JyB8fCBjdXJyZW50RGF5W2luZGV4XSA9PT0gJ1RoJykge1xuICAgIGN1cnJlbnREYXlbaW5kZXhdID0gJ1RoJztcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50RGF5W2luZGV4XSA9IGN1cnJlbnREYXlbaW5kZXhdLmNoYXJBdCgwKTtcbiAgfVxufSk7XG5cbnZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbW9udGhOdW1iZXIgVGhlIG1vbnRoIG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvcnRoYW5kIGB0cnVlYCB0byB1c2Ugc2hvcnRoYW5kIG1vbnRoLlxuICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZSBUaGUgRmxhdHBpY2tyIGxvY2FsZSBkYXRhLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIG1vbnRoIHN0cmluZy5cbiAqL1xuXG5cbnZhciBtb250aFRvU3RyID0gZnVuY3Rpb24gbW9udGhUb1N0cihtb250aE51bWJlciwgc2hvcnRoYW5kLCBsb2NhbGUpIHtcbiAgcmV0dXJuIGxvY2FsZS5tb250aHNbc2hvcnRoYW5kID8gJ3Nob3J0aGFuZCcgOiAnbG9uZ2hhbmQnXVttb250aE51bWJlcl07XG59O1xuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFBsdWdpbiBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbY29uZmlnLnNob3J0aGFuZF0gYHRydWVgIHRvIHVzZSBzaG9ydGhhbmQgbW9udGguXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnNlbGVjdG9yRmxhdHBpY2tyTW9udGhZZWFyQ29udGFpbmVyIFRoZSBDU1Mgc2VsZWN0b3IgZm9yIHRoZSBjb250YWluZXIgb2YgbW9udGgveWVhciBzZWxlY3Rpb24gVUkuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnNlbGVjdG9yRmxhdHBpY2tyWWVhckNvbnRhaW5lciBUaGUgQ1NTIHNlbGVjdG9yIGZvciB0aGUgY29udGFpbmVyIG9mIHllYXIgc2VsZWN0aW9uIFVJLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5zZWxlY3RvckZsYXRwaWNrckN1cnJlbnRNb250aCBUaGUgQ1NTIHNlbGVjdG9yIGZvciB0aGUgdGV4dC1iYXNlZCBtb250aCBzZWxlY3Rpb24gVUkuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLmNsYXNzRmxhdHBpY2tyQ3VycmVudE1vbnRoIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSB0ZXh0LWJhc2VkIG1vbnRoIHNlbGVjdGlvbiBVSS5cbiAqIEByZXR1cm5zIHtQbHVnaW59IEEgRmxhdHBpY2tyIHBsdWdpbiB0byB1c2UgdGV4dCBpbnN0ZWFkIG9mIGA8c2VsZWN0PmAgZm9yIG1vbnRoIHBpY2tlci5cbiAqL1xuXG5cbnZhciBjYXJib25GbGF0cGlja3JNb250aFNlbGVjdFBsdWdpbiA9IGZ1bmN0aW9uIGNhcmJvbkZsYXRwaWNrck1vbnRoU2VsZWN0UGx1Z2luKGNvbmZpZykge1xuICByZXR1cm4gZnVuY3Rpb24gKGZwKSB7XG4gICAgdmFyIHNldHVwRWxlbWVudHMgPSBmdW5jdGlvbiBzZXR1cEVsZW1lbnRzKCkge1xuICAgICAgdmFyIF9mcCRtb250aEVsZW1lbnRzO1xuXG4gICAgICBpZiAoIWZwLm1vbnRoRWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmcC5tb250aEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgaWYgKCFlbGVtLnBhcmVudE5vZGUpIHJldHVybjtcbiAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIChfZnAkbW9udGhFbGVtZW50cyA9IGZwLm1vbnRoRWxlbWVudHMpLnNwbGljZS5hcHBseShfZnAkbW9udGhFbGVtZW50cywgWzAsIGZwLm1vbnRoRWxlbWVudHMubGVuZ3RoXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGZwLm1vbnRoRWxlbWVudHMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgICAgIHZhciBtb250aEVsZW1lbnQgPSBmcC5fY3JlYXRlRWxlbWVudCgnc3BhbicsIGNvbmZpZy5jbGFzc0ZsYXRwaWNrckN1cnJlbnRNb250aCk7XG5cbiAgICAgICAgbW9udGhFbGVtZW50LnRleHRDb250ZW50ID0gbW9udGhUb1N0cihmcC5jdXJyZW50TW9udGgsIGNvbmZpZy5zaG9ydGhhbmQgPT09IHRydWUsIGZwLmwxMG4pO1xuICAgICAgICBmcC55ZWFyRWxlbWVudHNbMF0uY2xvc2VzdChjb25maWcuc2VsZWN0b3JGbGF0cGlja3JNb250aFllYXJDb250YWluZXIpLmluc2VydEJlZm9yZShtb250aEVsZW1lbnQsIGZwLnllYXJFbGVtZW50c1swXS5jbG9zZXN0KGNvbmZpZy5zZWxlY3RvckZsYXRwaWNrclllYXJDb250YWluZXIpKTtcbiAgICAgICAgcmV0dXJuIG1vbnRoRWxlbWVudDtcbiAgICAgIH0pKSkpO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlQ3VycmVudE1vbnRoID0gZnVuY3Rpb24gdXBkYXRlQ3VycmVudE1vbnRoKCkge1xuICAgICAgdmFyIG1vbnRoU3RyID0gbW9udGhUb1N0cihmcC5jdXJyZW50TW9udGgsIGNvbmZpZy5zaG9ydGhhbmQgPT09IHRydWUsIGZwLmwxMG4pO1xuICAgICAgZnAueWVhckVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIGN1cnJlbnRNb250aENvbnRhaW5lciA9IGVsZW0uY2xvc2VzdChjb25maWcuc2VsZWN0b3JGbGF0cGlja3JNb250aFllYXJDb250YWluZXIpO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGN1cnJlbnRNb250aENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuY3VyLW1vbnRoJyksIGZ1bmN0aW9uIChtb250aEVsZW1lbnQpIHtcbiAgICAgICAgICBtb250aEVsZW1lbnQudGV4dENvbnRlbnQgPSBtb250aFN0cjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBmcC5sb2FkZWRQbHVnaW5zLnB1c2goJ2NhcmJvbkZsYXRwaWNrck1vbnRoU2VsZWN0UGx1Z2luJyk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBvbk1vbnRoQ2hhbmdlOiB1cGRhdGVDdXJyZW50TW9udGgsXG4gICAgICBvblZhbHVlVXBkYXRlOiB1cGRhdGVDdXJyZW50TW9udGgsXG4gICAgICBvbk9wZW46IHVwZGF0ZUN1cnJlbnRNb250aCxcbiAgICAgIG9uUmVhZHk6IFtzZXR1cEVsZW1lbnRzLCB1cGRhdGVDdXJyZW50TW9udGgsIHJlZ2lzdGVyXVxuICAgIH07XG4gIH07XG59O1xuXG52YXIgRGF0ZVBpY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhEYXRlUGlja2VyLCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGF0ZVBpY2tlcik7XG4gIC8qKlxuICAgKiBEYXRlUGlja2VyLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGFuIGRhdGUgcGlja2VyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIERhdGVQaWNrZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlUGlja2VyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5faGFuZGxlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuY2FsZW5kYXIpIHtcbiAgICAgICAgX3RoaXMuY2FsZW5kYXIub3BlbigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5faGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLmNhbGVuZGFyKSB7XG4gICAgICAgIHZhciBmb2N1c1RvID0gZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgICAgICBpZiAoIWZvY3VzVG8gfHwgIV90aGlzLmVsZW1lbnQuY29udGFpbnMoZm9jdXNUbykgJiYgKCFfdGhpcy5jYWxlbmRhci5jYWxlbmRhckNvbnRhaW5lciB8fCAhX3RoaXMuY2FsZW5kYXIuY2FsZW5kYXJDb250YWluZXIuY29udGFpbnMoZm9jdXNUbykpKSB7XG4gICAgICAgICAgX3RoaXMuY2FsZW5kYXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5faW5pdERhdGVQaWNrZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdyYW5nZScpIHtcbiAgICAgICAgLy8gR2l2ZW4gRmxhdFBpY2tyIGFzc3VtZXMgb25lIGA8aW5wdXQ+YCBldmVuIGluIHJhbmdlIG1vZGUsXG4gICAgICAgIC8vIHVzZSBhIGhpZGRlbiBgPGlucHV0PmAgZm9yIHN1Y2ggcHVycG9zZSwgc2VwYXJhdGUgZnJvbSBvdXIgZnJvbS90byBgPGlucHV0PmBzXG4gICAgICAgIHZhciBkb2MgPSBfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHZhciByYW5nZUlucHV0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHJhbmdlSW5wdXQuY2xhc3NOYW1lID0gX3RoaXMub3B0aW9ucy5jbGFzc1Zpc3VhbGx5SGlkZGVuO1xuICAgICAgICByYW5nZUlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQocmFuZ2VJbnB1dCk7XG5cbiAgICAgICAgX3RoaXMuX3JhbmdlSW5wdXQgPSByYW5nZUlucHV0OyAvLyBBbiBhdHRlbXB0IHRvIG9wZW4gdGhlIGRhdGUgcGlja2VyIGRyb3Bkb3duIHdoZW4gdGhpcyBjb21wb25lbnQgZ2V0cyBmb2N1cyxcbiAgICAgICAgLy8gYW5kIGNsb3NlIHRoZSBkYXRlIHBpY2tlciBkcm9wZG93biB3aGVuIHRoaXMgY29tcG9uZW50IGxvc2VzIGZvY3VzXG5cbiAgICAgICAgdmFyIHcgPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgIHZhciBoYXNGb2N1c2luID0gKCdvbmZvY3VzaW4nIGluIHcpO1xuICAgICAgICB2YXIgaGFzRm9jdXNvdXQgPSAoJ29uZm9jdXNvdXQnIGluIHcpO1xuICAgICAgICB2YXIgZm9jdXNpbkV2ZW50TmFtZSA9IGhhc0ZvY3VzaW4gPyAnZm9jdXNpbicgOiAnZm9jdXMnO1xuICAgICAgICB2YXIgZm9jdXNvdXRFdmVudE5hbWUgPSBoYXNGb2N1c291dCA/ICdmb2N1c291dCcgOiAnYmx1cic7XG5cbiAgICAgICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsIGZvY3VzaW5FdmVudE5hbWUsIF90aGlzLl9oYW5kbGVGb2N1cywgIWhhc0ZvY3VzaW4pKTtcblxuICAgICAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgZm9jdXNvdXRFdmVudE5hbWUsIF90aGlzLl9oYW5kbGVCbHVyLCAhaGFzRm9jdXNvdXQpKTtcblxuICAgICAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JEYXRlUGlja2VySWNvbiksIGZvY3Vzb3V0RXZlbnROYW1lLCBfdGhpcy5faGFuZGxlQmx1ciwgIWhhc0ZvY3Vzb3V0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG5cbiAgICAgIHZhciBkYXRlID0gdHlwZSA9PT0gJ3JhbmdlJyA/IF90aGlzLl9yYW5nZUlucHV0IDogX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JEYXRlUGlja2VySW5wdXQpO1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICAgIF9vbkNsb3NlID0gX3RoaXMkb3B0aW9ucy5vbkNsb3NlLFxuICAgICAgICAgIF9vbkNoYW5nZSA9IF90aGlzJG9wdGlvbnMub25DaGFuZ2UsXG4gICAgICAgICAgX29uTW9udGhDaGFuZ2UgPSBfdGhpcyRvcHRpb25zLm9uTW9udGhDaGFuZ2UsXG4gICAgICAgICAgX29uWWVhckNoYW5nZSA9IF90aGlzJG9wdGlvbnMub25ZZWFyQ2hhbmdlLFxuICAgICAgICAgIF9vbk9wZW4gPSBfdGhpcyRvcHRpb25zLm9uT3BlbixcbiAgICAgICAgICBfb25WYWx1ZVVwZGF0ZSA9IF90aGlzJG9wdGlvbnMub25WYWx1ZVVwZGF0ZTtcbiAgICAgIHZhciBjYWxlbmRhciA9IG5ldyBGbGF0cGlja3IoZGF0ZSwgT2JqZWN0LmFzc2lnbihmbGF0dGVuT3B0aW9ucyhfdGhpcy5vcHRpb25zKSwge1xuICAgICAgICBhbGxvd0lucHV0OiB0cnVlLFxuICAgICAgICBtb2RlOiB0eXBlLFxuICAgICAgICBkaXNhYmxlTW9iaWxlOiB0cnVlLFxuICAgICAgICBwb3NpdGlvbkVsZW1lbnQ6IHR5cGUgPT09ICdyYW5nZScgJiYgX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JEYXRlUGlja2VySW5wdXRGcm9tKSxcbiAgICAgICAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZShzZWxlY3RlZERhdGVzKSB7XG4gICAgICAgICAgLy8gQW4gYXR0ZW1wdCB0byBkaXNhYmxlIEZsYXRwaWNrcidzIGZvY3VzIHRyYWNraW5nIHN5c3RlbSxcbiAgICAgICAgICAvLyB3aGljaCBoYXMgYWR2ZXJzZSBlZmZlY3Qgd2l0aCBvdXIgb2xkIHNldCB1cCB3aXRoIHR3byBgPGlucHV0PmBzIG9yIG91ciBsYXRlc3Qgc2V0dXAgd2l0aCBhIGhpZGRlbiBgPGlucHV0PmBcbiAgICAgICAgICBpZiAoc2VsZi5zaG91bGRGb3JjZU9wZW4pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyLmNhbGVuZGFyQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXIuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbWFpbmRlciA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICByZW1haW5kZXJbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX29uQ2xvc2UgfHwgX29uQ2xvc2UuY2FsbC5hcHBseShfb25DbG9zZSwgW3RoaXMsIHNlbGVjdGVkRGF0ZXNdLmNvbmNhdChyZW1haW5kZXIpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNsYXNzTmFtZXMoY2FsZW5kYXIpO1xuXG4gICAgICAgICAgICBzZWxmLl91cGRhdGVJbnB1dEZpZWxkcyhzZWxlY3RlZERhdGVzLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9vbkNoYW5nZSB8fCBfb25DaGFuZ2UuY2FsbC5hcHBseShfb25DaGFuZ2UsIFt0aGlzXS5jb25jYXQoYXJncykpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ2xhc3NOYW1lcyhjYWxlbmRhcik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICAgIGlmIChjYWxlbmRhci5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSAmJiBjYWxlbmRhci5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxmLm9wdGlvbnMuc2VsZWN0b3JEYXRlUGlja2VySW5wdXRUbykuY2xhc3NMaXN0LmFkZChzZWxmLm9wdGlvbnMuY2xhc3NGb2N1c2VkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxmLm9wdGlvbnMuc2VsZWN0b3JEYXRlUGlja2VySW5wdXRUbykuY2xhc3NMaXN0LnJlbW92ZShzZWxmLm9wdGlvbnMuY2xhc3NGb2N1c2VkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Nb250aENoYW5nZTogZnVuY3Rpb24gb25Nb250aENoYW5nZSgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9vbk1vbnRoQ2hhbmdlIHx8IF9vbk1vbnRoQ2hhbmdlLmNhbGwuYXBwbHkoX29uTW9udGhDaGFuZ2UsIFt0aGlzXS5jb25jYXQoYXJncykpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ2xhc3NOYW1lcyhjYWxlbmRhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblllYXJDaGFuZ2U6IGZ1bmN0aW9uIG9uWWVhckNoYW5nZSgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9vblllYXJDaGFuZ2UgfHwgX29uWWVhckNoYW5nZS5jYWxsLmFwcGx5KF9vblllYXJDaGFuZ2UsIFt0aGlzXS5jb25jYXQoYXJncykpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ2xhc3NOYW1lcyhjYWxlbmRhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbk9wZW46IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgICAvLyBBbiBhdHRlbXB0IHRvIGRpc2FibGUgRmxhdHBpY2tyJ3MgZm9jdXMgdHJhY2tpbmcgc3lzdGVtLFxuICAgICAgICAgIC8vIHdoaWNoIGhhcyBhZHZlcnNlIGVmZmVjdCB3aXRoIG91ciBvbGQgc2V0IHVwIHdpdGggdHdvIGA8aW5wdXQ+YHMgb3Igb3VyIGxhdGVzdCBzZXR1cCB3aXRoIGEgaGlkZGVuIGA8aW5wdXQ+YFxuICAgICAgICAgIHNlbGYuc2hvdWxkRm9yY2VPcGVuID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuc2hvdWxkRm9yY2VPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9vbk9wZW4gfHwgX29uT3Blbi5jYWxsLmFwcGx5KF9vbk9wZW4sIFt0aGlzXS5jb25jYXQoYXJncykpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ2xhc3NOYW1lcyhjYWxlbmRhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblZhbHVlVXBkYXRlOiBmdW5jdGlvbiBvblZhbHVlVXBkYXRlKCkge1xuICAgICAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgoIV9vblZhbHVlVXBkYXRlIHx8IF9vblZhbHVlVXBkYXRlLmNhbGwuYXBwbHkoX29uVmFsdWVVcGRhdGUsIFt0aGlzXS5jb25jYXQoYXJncykpICE9PSBmYWxzZSkgJiYgdHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlSW5wdXRGaWVsZHMoc2VsZi5jYWxlbmRhci5zZWxlY3RlZERhdGVzLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5leHRBcnJvdzogX3RoaXMuX3JpZ2h0QXJyb3dIVE1MKCksXG4gICAgICAgIHByZXZBcnJvdzogX3RoaXMuX2xlZnRBcnJvd0hUTUwoKSxcbiAgICAgICAgcGx1Z2luczogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5vcHRpb25zLnBsdWdpbnMgfHwgW10pLCBbY2FyYm9uRmxhdHBpY2tyTW9udGhTZWxlY3RQbHVnaW4oX3RoaXMub3B0aW9ucyldKVxuICAgICAgfSkpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICBfdGhpcy5fYWRkSW5wdXRMb2dpYyhfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckRhdGVQaWNrZXJJbnB1dEZyb20pLCAwKTtcblxuICAgICAgICBfdGhpcy5fYWRkSW5wdXRMb2dpYyhfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckRhdGVQaWNrZXJJbnB1dFRvKSwgMSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckRhdGVQaWNrZXJJY29uKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxlbmRhci5vcGVuKCk7XG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLl91cGRhdGVDbGFzc05hbWVzKGNhbGVuZGFyKTtcblxuICAgICAgaWYgKHR5cGUgIT09ICdyYW5nZScpIHtcbiAgICAgICAgX3RoaXMuX2FkZElucHV0TG9naWMoZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2FkZElucHV0TG9naWMgPSBmdW5jdGlvbiAoaW5wdXQsIGluZGV4KSB7XG4gICAgICBpZiAoIWlzTmFOKGluZGV4KSAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgaW5kZXggb2YgPGlucHV0PiAoXCIuY29uY2F0KGluZGV4LCBcIikgaXMgb3V0IG9mIHJhbmdlLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dEZpZWxkID0gaW5wdXQ7XG5cbiAgICAgIF90aGlzLm1hbmFnZShvbihpbnB1dEZpZWxkLCAnY2hhbmdlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LmlzVHJ1c3RlZCB8fCBldnQuZGV0YWlsICYmIGV2dC5kZXRhaWwuaXNOb3RGcm9tRmxhdHBpY2tyKSB7XG4gICAgICAgICAgdmFyIGlucHV0RGF0ZSA9IF90aGlzLmNhbGVuZGFyLnBhcnNlRGF0ZShpbnB1dEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChpbnB1dERhdGUgJiYgIWlzTmFOKGlucHV0RGF0ZS52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnNldERhdGUoaW5wdXREYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZERhdGVzID0gX3RoaXMuY2FsZW5kYXIuc2VsZWN0ZWREYXRlcztcbiAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlc1tpbmRleF0gPSBpbnB1dERhdGU7XG5cbiAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIuc2V0RGF0ZShzZWxlY3RlZERhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5fdXBkYXRlQ2xhc3NOYW1lcyhfdGhpcy5jYWxlbmRhcik7XG4gICAgICB9KSk7IC8vIEFuIGF0dGVtcHQgdG8gdGVtcG9yYXJpbHkgc2V0IHRoZSBgPGlucHV0PmAgYmVpbmcgZWRpdGVkIGFzIHRoZSBvbmUgRmxhdFBpY2tlciBtYW5hZ2VzLFxuICAgICAgLy8gYXMgRmxhdFBpY2tlciBhdHRlbXB0cyB0byB0YWtlIG92ZXIgYGtleWRvd25gIGV2ZW50IGhhbmRsZXIgb24gYGRvY3VtZW50YCB0byBydW4gb24gdGhlIGRhdGUgcGlja2VyIGRyb3Bkb3duLlxuXG5cbiAgICAgIF90aGlzLm1hbmFnZShvbihpbnB1dEZpZWxkLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIG9yaWdJbnB1dCA9IF90aGlzLmNhbGVuZGFyLl9pbnB1dDtcbiAgICAgICAgX3RoaXMuY2FsZW5kYXIuX2lucHV0ID0gZXZ0LnRhcmdldDtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuY2FsZW5kYXIuX2lucHV0ID0gb3JpZ0lucHV0O1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX3VwZGF0ZUNsYXNzTmFtZXMgPSBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGNhbGVuZGFyQ29udGFpbmVyID0gX3JlZi5jYWxlbmRhckNvbnRhaW5lcixcbiAgICAgICAgICBzZWxlY3RlZERhdGVzID0gX3JlZi5zZWxlY3RlZERhdGVzO1xuXG4gICAgICBpZiAoY2FsZW5kYXJDb250YWluZXIpIHtcbiAgICAgICAgY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzQ2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICBjYWxlbmRhckNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZmxhdHBpY2tyLW1vbnRoJykuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzTW9udGgpO1xuICAgICAgICBjYWxlbmRhckNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZmxhdHBpY2tyLXdlZWtkYXlzJykuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzV2Vla2RheXMpO1xuICAgICAgICBjYWxlbmRhckNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZmxhdHBpY2tyLWRheXMnKS5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NEYXlzKTtcbiAgICAgICAgdG9BcnJheShjYWxlbmRhckNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuZmxhdHBpY2tyLXdlZWtkYXknKSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHZhciBjdXJyZW50SXRlbSA9IGl0ZW07XG4gICAgICAgICAgY3VycmVudEl0ZW0uaW5uZXJIVE1MID0gY3VycmVudEl0ZW0uaW5uZXJIVE1MLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgICAgICAgIGN1cnJlbnRJdGVtLmNsYXNzTGlzdC5hZGQoX3RoaXMub3B0aW9ucy5jbGFzc1dlZWtkYXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdG9BcnJheShjYWxlbmRhckNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuZmxhdHBpY2tyLWRheScpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NEYXkpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCd0b2RheScpICYmIHNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCduby1ib3JkZXInKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCd0b2RheScpICYmIHNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ25vLWJvcmRlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLl91cGRhdGVJbnB1dEZpZWxkcyA9IGZ1bmN0aW9uIChzZWxlY3RlZERhdGVzLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICBpZiAoc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckRhdGVQaWNrZXJJbnB1dEZyb20pLnZhbHVlID0gX3RoaXMuX2Zvcm1hdERhdGUoc2VsZWN0ZWREYXRlc1swXSk7XG4gICAgICAgICAgX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JEYXRlUGlja2VySW5wdXRUbykudmFsdWUgPSBfdGhpcy5fZm9ybWF0RGF0ZShzZWxlY3RlZERhdGVzWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yRGF0ZVBpY2tlcklucHV0RnJvbSkudmFsdWUgPSBfdGhpcy5fZm9ybWF0RGF0ZShzZWxlY3RlZERhdGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckRhdGVQaWNrZXJJbnB1dCkudmFsdWUgPSBfdGhpcy5fZm9ybWF0RGF0ZShzZWxlY3RlZERhdGVzWzBdKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX3VwZGF0ZUNsYXNzTmFtZXMoX3RoaXMuY2FsZW5kYXIpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICByZXR1cm4gX3RoaXMuY2FsZW5kYXIuZm9ybWF0RGF0ZShkYXRlLCBfdGhpcy5jYWxlbmRhci5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgfTtcblxuICAgIHZhciBfdHlwZSA9IF90aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKF90aGlzLm9wdGlvbnMuYXR0cmliVHlwZSk7XG5cbiAgICBfdGhpcy5jYWxlbmRhciA9IF90aGlzLl9pbml0RGF0ZVBpY2tlcihfdHlwZSk7XG5cbiAgICBpZiAoX3RoaXMuY2FsZW5kYXIuY2FsZW5kYXJDb250YWluZXIpIHtcbiAgICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSA0MCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIChfdGhpcy5jYWxlbmRhci5zZWxlY3RlZERhdGVFbGVtIHx8IF90aGlzLmNhbGVuZGFyLnRvZGF5RGF0ZUVsZW0gfHwgX3RoaXMuY2FsZW5kYXIuY2FsZW5kYXJDb250YWluZXIpLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmNhbGVuZGFyLmNhbGVuZGFyQ29udGFpbmVyLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSA5ICYmIF90eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgX3RoaXMuX3VwZGF0ZUNsYXNzTmFtZXMoX3RoaXMuY2FsZW5kYXIpO1xuXG4gICAgICAgICAgX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JEYXRlUGlja2VySW5wdXRGcm9tKS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgZGF0ZSBwaWNrZXIgZHJvcGRvd24gd2hlbiB0aGlzIGNvbXBvbmVudCBnZXRzIGZvY3VzLlxuICAgKiBVc2VkIG9ubHkgZm9yIHJhbmdlIG1vZGUgZm9yIG5vdy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGF0ZVBpY2tlciwgW3tcbiAgICBrZXk6IFwiX3JpZ2h0QXJyb3dIVE1MXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yaWdodEFycm93SFRNTCgpIHtcbiAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzdmdcXG4gICAgICAgIGZvY3VzYWJsZT1cXFwiZmFsc2VcXFwiXFxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWlkWU1pZCBtZWV0XFxcIlxcbiAgICAgICAgc3R5bGU9XFxcIndpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxcIlxcbiAgICAgICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgICAgICAgd2lkdGg9XFxcIjE2XFxcIlxcbiAgICAgICAgaGVpZ2h0PVxcXCIxNlxcXCJcXG4gICAgICAgIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCJcXG4gICAgICAgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cXG4gICAgICAgICAgPHBhdGggZD1cXFwiTTExIDhsLTUgNS0uNy0uN0w5LjYgOCA1LjMgMy43IDYgM3pcXFwiPjwvcGF0aD5cXG4gICAgICA8L3N2Zz5cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2xlZnRBcnJvd0hUTUxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xlZnRBcnJvd0hUTUwoKSB7XG4gICAgICByZXR1cm4gXCJcXG4gICAgICA8c3ZnXFxuICAgICAgICBmb2N1c2FibGU9XFxcImZhbHNlXFxcIlxcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCJcXG4gICAgICAgIHN0eWxlPVxcXCJ3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcXCJcXG4gICAgICAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICAgICAgIHdpZHRoPVxcXCIxNlxcXCJcXG4gICAgICAgIGhlaWdodD1cXFwiMTZcXFwiXFxuICAgICAgICB2aWV3Qm94PVxcXCIwIDAgMTYgMTZcXFwiXFxuICAgICAgICBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCJcXG4gICAgICA+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNNSA4bDUtNSAuNy43TDYuNCA4bDQuMyA0LjMtLjcuN3pcXFwiPjwvcGF0aD5cXG4gICAgICA8L3N2Zz5cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICAgaWYgKHRoaXMuX3JhbmdlSW5wdXQgJiYgdGhpcy5fcmFuZ2VJbnB1dC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuX3JhbmdlSW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9yYW5nZUlucHV0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FsZW5kYXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyLmRlc3Ryb3koKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cblxuICAgICAgICB0aGlzLmNhbGVuZGFyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKERhdGVQaWNrZXIucHJvdG90eXBlKSwgXCJyZWxlYXNlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgKiB7QGxpbmtjb2RlIERhdGVQaWNrZXIuY3JlYXRlIC5jcmVhdGUoKX0sIG9yIHtAbGlua2NvZGUgRGF0ZVBpY2tlci5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZSBhbmQgaG93IHtAbGlua2NvZGUgRGF0ZVBpY2tlci5pbml0IC5pbml0KCl9IHdvcmtzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIGRhdGUgcGlja2VyIFVJcy5cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLWRhdGUtcGlja2VyXScsXG4gICAgICAgIHNlbGVjdG9yRGF0ZVBpY2tlcklucHV0OiAnW2RhdGEtZGF0ZS1waWNrZXItaW5wdXRdJyxcbiAgICAgICAgc2VsZWN0b3JEYXRlUGlja2VySW5wdXRGcm9tOiAnW2RhdGEtZGF0ZS1waWNrZXItaW5wdXQtZnJvbV0nLFxuICAgICAgICBzZWxlY3RvckRhdGVQaWNrZXJJbnB1dFRvOiAnW2RhdGEtZGF0ZS1waWNrZXItaW5wdXQtdG9dJyxcbiAgICAgICAgc2VsZWN0b3JEYXRlUGlja2VySWNvbjogJ1tkYXRhLWRhdGUtcGlja2VyLWljb25dJyxcbiAgICAgICAgc2VsZWN0b3JGbGF0cGlja3JNb250aFllYXJDb250YWluZXI6ICcuZmxhdHBpY2tyLWN1cnJlbnQtbW9udGgnLFxuICAgICAgICBzZWxlY3RvckZsYXRwaWNrclllYXJDb250YWluZXI6ICcubnVtSW5wdXRXcmFwcGVyJyxcbiAgICAgICAgc2VsZWN0b3JGbGF0cGlja3JDdXJyZW50TW9udGg6ICcuY3VyLW1vbnRoJyxcbiAgICAgICAgY2xhc3NDYWxlbmRhckNvbnRhaW5lcjogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZGF0ZS1waWNrZXJfX2NhbGVuZGFyXCIpLFxuICAgICAgICBjbGFzc01vbnRoOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1kYXRlLXBpY2tlcl9fbW9udGhcIiksXG4gICAgICAgIGNsYXNzV2Vla2RheXM6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWRhdGUtcGlja2VyX193ZWVrZGF5c1wiKSxcbiAgICAgICAgY2xhc3NEYXlzOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1kYXRlLXBpY2tlcl9fZGF5c1wiKSxcbiAgICAgICAgY2xhc3NXZWVrZGF5OiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1kYXRlLXBpY2tlcl9fd2Vla2RheVwiKSxcbiAgICAgICAgY2xhc3NEYXk6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWRhdGUtcGlja2VyX19kYXlcIiksXG4gICAgICAgIGNsYXNzRm9jdXNlZDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZm9jdXNlZFwiKSxcbiAgICAgICAgY2xhc3NWaXN1YWxseUhpZGRlbjogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tdmlzdWFsbHktaGlkZGVuXCIpLFxuICAgICAgICBjbGFzc0ZsYXRwaWNrckN1cnJlbnRNb250aDogJ2N1ci1tb250aCcsXG4gICAgICAgIGF0dHJpYlR5cGU6ICdkYXRhLWRhdGUtcGlja2VyLXR5cGUnLFxuICAgICAgICBkYXRlRm9ybWF0OiAnbS9kL1knXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBkYXRlIHBpY2tlciBVSSBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSk7XG5cbiAgRGF0ZVBpY2tlci5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIERhdGVQaWNrZXI7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBoYW5kbGVzKSk7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVQaWNrZXI7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgdHJhY2tCbHVyIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL3RyYWNrLWJsdXInO1xuaW1wb3J0IGV2ZW50TWF0Y2hlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZXZlbnQtbWF0Y2hlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbnZhciBEcm9wZG93biA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhEcm9wZG93biwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERyb3Bkb3duKTtcbiAgLyoqXG4gICAqIEEgc2VsZWN0b3Igd2l0aCBkcm9wIGRvd25zLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIFRyYWNrQmx1clxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYSBzZWxlY3Rvci5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3Rvckl0ZW1dIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBjbGlja2FibGUgYXJlYXMgaW4gZHJvcGRvd24gaXRlbXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3Rvckl0ZW1TZWxlY3RlZF0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBjbGlja2FibGUgYXJlYSBpbiB0aGUgc2VsZWN0ZWQgZHJvcGRvd24gaXRlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzU2VsZWN0ZWRdIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBzZWxlY3RlZCBkcm9wZG93biBpdGVtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NPcGVuXSBUaGUgQ1NTIGNsYXNzIGZvciB0aGUgb3BlbiBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzRGlzYWJsZWRdIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmV2ZW50QmVmb3JlU2VsZWN0ZWRdXG4gICAqICAgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCBmaXJlZCBiZWZvcmUgYSBkcm9wIGRvd24gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICogICBDYW5jZWxsYXRpb24gb2YgdGhpcyBldmVudCBzdG9wcyBzZWxlY3Rpb24gb2YgZHJvcCBkb3duIGl0ZW0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEFmdGVyU2VsZWN0ZWRdIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgYWZ0ZXIgYSBkcm9wIGRvd24gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBEcm9wZG93bihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3Bkb3duKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl90b2dnbGUoZXZlbnQpO1xuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMuX2hhbmRsZUtleURvd24oZXZlbnQpO1xuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBpdGVtID0gZXZlbnRNYXRjaGVzKGV2ZW50LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbSk7XG5cbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIF90aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIFdoZW4gdXNpbmcgdGhlIGFjdGl2ZSBkZXNjZW5kYW50IGFwcHJvYWNoIHdlIHVzZSBhIGNsYXNzIHRvIGdpdmUgZm9jdXMgc3R5bGVzIGR1cmluZyBrZXlib2FyZCAodXAvZG93biBhcnJvd3MpXG4gICAgLy8gbmF2aWdhdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIDpmb2N1cyBzZWxlY3Rvci4gVGhpcyBsZWF2ZXMgdGhlIHBvdGVudGlhbCB0byBoYXZlIG11bHRpcGxlIGl0ZW1zIHdoZW5cbiAgICAvLyBzd2l0Y2hpbmcgaW50ZXJhY3Rpb25zIGJldHdlZW4ga2V5Ym9hcmQgYW5kIG1vdXNlIHVzZXJzLiBUbyBtb3JlIGNsb3NlbHkgYWxpZ24gd2l0aCBDYXJib24gUmVhY3QgaW1wbGVtZW50YXRpb24sXG4gICAgLy8gd2Ugd2FudCB0aGUgZm9jdXMgY2xhc3MgdG8gbW92ZSBhcyB0aGUgdXNlciBob3ZlcnMgb3ZlciBpdGVtcy4gVGhpcyBhbHNvIHVwZGF0ZXMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzIGJhc2VkIG9uXG4gICAgLy8gdGhlIGxhc3QgaG92ZXJlZCBpdGVtIGlmIHRoZSB1c2VyIHN3aXRjaGVzIGJhY2sgdG8gdXNpbmcgdGhlIGtleWJvYXJkLlxuXG5cbiAgICBpZiAoIC8vIE5PVEU6IGBzZWxlY3RvclRyaWdnZXJgIGRvZXMgTk9UIG1hdGNoIHRoZSB0cmlnZ2VyIGJ1dHRvbiBpbiBvbGRlciBtYXJrdXBcbiAgICBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRyaWdnZXIpICYmIF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yTWVudSkpIHtcbiAgICAgIC8vIFVzaW5nIHRoZSBsYXRlc3QgSFRNTCBzdHJ1Y3R1cmUgdGhhdCBzdXBwb3J0cyB0aGUgYXJpYS1hY3RpdmVkZXNjZW5kYW50IGF0dHJpYnV0ZVxuICAgICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBldmVudE1hdGNoZXMoZXZlbnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtKTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIF90aGlzLl91cGRhdGVGb2N1cyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdHJpZ2dlcmluZyB0aGlzIG1ldGhvZC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRHJvcGRvd24sIFt7XG4gICAga2V5OiBcIl9oYW5kbGVLZXlEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICB2YXIgaXNPcGVuID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NPcGVuKTtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSB7XG4gICAgICAgIDM4OiB0aGlzLmNvbnN0cnVjdG9yLk5BVklHQVRFLkJBQ0tXQVJELFxuICAgICAgICA0MDogdGhpcy5jb25zdHJ1Y3Rvci5OQVZJR0FURS5GT1JXQVJEXG4gICAgICB9W2V2ZW50LndoaWNoXTtcblxuICAgICAgaWYgKGlzT3BlbiAmJiBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlKGRpcmVjdGlvbik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnRzIHVwL2Rvd24ga2V5cyBmcm9tIHNjcm9sbGluZyBjb250YWluZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldCBzZWxlY3RlZCBpdGVtXG4gICAgICAgIC8vIGluIHYxMC4wLCB0aGUgYW5jaG9yIGVsZW1lbnRzIGZpcmUgY2xpY2sgZXZlbnRzIG9uIEVudGVyIGtleXByZXNzIHdoZW4gYSBkcm9wZG93biBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgIC8vIGluIHYxMC41ICgjMzU4NiksIGZvY3VzIGlzIG5vIGxvbmdlciBwbGFjZWQgb24gdGhlIGRyb3Bkb3duIGl0ZW1zIGFuZCBpcyBpbnN0ZWFkIGtlcHQgZml4ZWQgb24gdGhlIHVsIG1lbnVcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBtYW51YWxseSBjYWxsIGdldEN1cnJlbnROYXZpZ2F0aW9uIGFuZCBzZWxlY3QgdGhlIGl0ZW1cbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEN1cnJlbnROYXZpZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgaXNPcGVuICYmIChldmVudC53aGljaCA9PT0gMTMgfHwgZXZlbnQud2hpY2ggPT09IDMyKSAmJiAhdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudC5tYXRjaGVzKHRoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW0pKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RvZ2dsZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgYXJpYS1hY3RpdmVkZXNjZW5kYW50IHdlIHdhbnQgdG8gbWFrZSBzdXJlIGF0dHJpYnV0ZXMgYW5kIGNsYXNzZXNcbiAgICAgKiBhcmUgcHJvcGVybHkgY2xlYW5lZCB1cCB3aGVuIHRoZSBkcm9wZG93biBpcyBjbG9zZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZvY3VzQ2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9jdXNDbGVhbnVwKCkge1xuICAgICAgLy8gTk9URTogYHNlbGVjdG9yVHJpZ2dlcmAgZG9lcyBOT1QgbWF0Y2ggdGhlIHRyaWdnZXIgYnV0dG9uIGluIG9sZGVyIG1hcmt1cFxuICAgICAgdmFyIHRyaWdnZXJOb2RlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yVHJpZ2dlcik7IC8vIG9ubHkgd2FudCB0byBncmFiIHRoZSBsaXN0Tm9kZSBJRiBpdCdzIHVzaW5nIHRoZSBsYXRlc3QgYTExeSBIVE1MIHN0cnVjdHVyZVxuXG4gICAgICB2YXIgbGlzdE5vZGUgPSB0cmlnZ2VyTm9kZSA/IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvck1lbnUpIDogbnVsbDtcblxuICAgICAgaWYgKGxpc3ROb2RlKSB7XG4gICAgICAgIGxpc3ROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgICAgIHZhciBmb2N1c2VkSXRlbSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW1Gb2N1c2VkKTtcblxuICAgICAgICBpZiAoZm9jdXNlZEl0ZW0pIHtcbiAgICAgICAgICBmb2N1c2VkSXRlbS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc0ZvY3VzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmb2N1cyB1c2luZyBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQgSFRNTCBzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtVG9Gb2N1cyBUaGUgZWxlbWVudCB0byBiZSBmb2N1c2VkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVGb2N1cyhpdGVtVG9Gb2N1cykge1xuICAgICAgLy8gTk9URTogYHNlbGVjdG9yVHJpZ2dlcmAgZG9lcyBOT1QgbWF0Y2ggdGhlIHRyaWdnZXIgYnV0dG9uIGluIG9sZGVyIG1hcmt1cFxuICAgICAgdmFyIHRyaWdnZXJOb2RlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yVHJpZ2dlcik7IC8vIG9ubHkgd2FudCB0byBncmFiIHRoZSBsaXN0Tm9kZSBJRiBpdCdzIHVzaW5nIHRoZSBsYXRlc3QgYTExeSBIVE1MIHN0cnVjdHVyZVxuXG4gICAgICB2YXIgbGlzdE5vZGUgPSB0cmlnZ2VyTm9kZSA/IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvck1lbnUpIDogbnVsbDtcbiAgICAgIHZhciBwcmV2aW91c2x5Rm9jdXNlZCA9IGxpc3ROb2RlLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbUZvY3VzZWQpO1xuICAgICAgaXRlbVRvRm9jdXMuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY2xhc3NGb2N1c2VkKTtcbiAgICAgIGxpc3ROb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgaXRlbVRvRm9jdXMuaWQpO1xuXG4gICAgICBpZiAocHJldmlvdXNseUZvY3VzZWQpIHtcbiAgICAgICAgcHJldmlvdXNseUZvY3VzZWQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY2xhc3NGb2N1c2VkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgYW5kIGNsb3NlcyB0aGUgZHJvcGRvd24gbWVudS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnRdIFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHRvZG8gaHR0cHM6Ly9naXRodWIuY29tL2NhcmJvbi1kZXNpZ24tc3lzdGVtL2NhcmJvbi9pc3N1ZXMvMzY0MVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RvZ2dsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGlzRGlzYWJsZWQgPSB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMub3B0aW9ucy5jbGFzc0Rpc2FibGVkKTtcblxuICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBOT1RFOiBgc2VsZWN0b3JUcmlnZ2VyYCBkb2VzIE5PVCBtYXRjaCB0aGUgdHJpZ2dlciBidXR0b24gaW4gb2xkZXIgbWFya3VwXG5cblxuICAgICAgdmFyIHRyaWdnZXJOb2RlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yVHJpZ2dlcik7XG5cbiAgICAgIGlmICggLy8gVXNlciBwcmVzc2VzIGRvd24gYXJyb3dcbiAgICAgIGV2ZW50LndoaWNoID09PSA0MCAmJiAhZXZlbnQudGFyZ2V0Lm1hdGNoZXModGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbSkgfHwgLy8gVXNlciBwcmVzc2VzIHNwYWNlIG9yIGVudGVyIGFuZCB0aGUgdHJpZ2dlciBpcyBub3QgYSBidXR0b24gT1IgZXZlbnQgaXMgbm90IGZpcmVkIGJ5IHRyaWdnZXJcbiAgICAgICghdHJpZ2dlck5vZGUgfHwgIXRyaWdnZXJOb2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpICYmIFsxMywgMzJdLmluZGV4T2YoZXZlbnQud2hpY2gpID49IDAgJiYgIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW0pIHx8IC8vIFVzZXIgcHJlc3NlcyBlc2NcbiAgICAgIGV2ZW50LndoaWNoID09PSAyNyB8fCAvLyBVc2VyIGNsaWNrc1xuICAgICAgZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICB2YXIgaXNPcGVuID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NPcGVuKTtcbiAgICAgICAgdmFyIGlzT2ZTZWxmID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7IC8vIERldGVybWluZSBpZiB0aGUgb3BlbiBjbGFzc05hbWUgc2hvdWxkIGJlIGFkZGVkLCByZW1vdmVkLCBvciB0b2dnbGVkXG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB7XG4gICAgICAgICAgYWRkOiBpc09mU2VsZiAmJiBldmVudC53aGljaCA9PT0gNDAgJiYgIWlzT3BlbixcbiAgICAgICAgICByZW1vdmU6ICghaXNPZlNlbGYgfHwgZXZlbnQud2hpY2ggPT09IDI3KSAmJiBpc09wZW4sXG4gICAgICAgICAgdG9nZ2xlOiBpc09mU2VsZiAmJiBldmVudC53aGljaCAhPT0gMjcgJiYgZXZlbnQud2hpY2ggIT09IDQwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjaGFuZ2VkU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmtleXMoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGFjdGlvbnNbYWN0aW9uXSkge1xuICAgICAgICAgICAgY2hhbmdlZFN0YXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgX3RoaXMyLmVsZW1lbnQuY2xhc3NMaXN0W2FjdGlvbl0oX3RoaXMyLm9wdGlvbnMuY2xhc3NPcGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGlzdEl0ZW1zID0gdG9BcnJheSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtKSk7IC8vIG9ubHkgd2FudCB0byBncmFiIHRoZSBsaXN0Tm9kZSBJRiBpdCdzIHVzaW5nIHRoZSBsYXRlc3QgYTExeSBIVE1MIHN0cnVjdHVyZVxuXG4gICAgICAgIHZhciBsaXN0Tm9kZSA9IHRyaWdnZXJOb2RlID8gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yTWVudSkgOiBudWxsOyAvLyBAdG9kbyByZW1vdmUgY29uZGl0aW9uYWxzIGZvciBlbGVtZW50cyBleGlzdGluZyBvbmNlIGxlZ2FjeSBzdHJ1Y3R1cmUgaXMgZGVwcmVjaWF0ZWRcblxuICAgICAgICBpZiAoY2hhbmdlZFN0YXRlICYmIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzT3BlbikpIHtcbiAgICAgICAgICAvLyB0b2dnbGVkIG9wZW5cbiAgICAgICAgICBpZiAodHJpZ2dlck5vZGUpIHtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKGxpc3ROb2RlIHx8IHRoaXMuZWxlbWVudCkuZm9jdXMoKTtcblxuICAgICAgICAgIGlmIChsaXN0Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGxpc3ROb2RlLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yTGlua1NlbGVjdGVkKTtcbiAgICAgICAgICAgIGxpc3ROb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgKHNlbGVjdGVkTm9kZSB8fCBsaXN0SXRlbXNbMF0pLmlkKTtcbiAgICAgICAgICAgIChzZWxlY3RlZE5vZGUgfHwgbGlzdEl0ZW1zWzBdKS5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc0ZvY3VzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2VkU3RhdGUgJiYgKGlzT2ZTZWxmIHx8IGFjdGlvbnMucmVtb3ZlKSkge1xuICAgICAgICAgIC8vIHRvZ2dsZWQgY2xvc2VcbiAgICAgICAgICAvLyB0aW1lciBpcyB1c2VkIHRvIGNhbGwgZm9jdXMgQUZURVIgdGhlIGNsaWNrIGV2ZW50IG9uXG4gICAgICAgICAgLy8gdHJpZ2dlciBidXR0b24gKHdoaWNoIGlzIGNhdXNlZCBieSBrZXlwcmVzcyBlLmcuIGR1cmluZyBrZXlib2FyZCBuYXZpZ2F0aW9uKVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0cmlnZ2VyTm9kZSB8fCBfdGhpczIuZWxlbWVudCkuZm9jdXMoKTtcbiAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgIGlmICh0cmlnZ2VyTm9kZSkge1xuICAgICAgICAgICAgdHJpZ2dlck5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZm9jdXNDbGVhbnVwKCk7XG4gICAgICAgIH0gLy8gQHRvZG8gcmVtb3ZlIG9uY2UgbGVnYWN5IHN0cnVjdHVyZSBpcyBkZXByZWNpYXRlZFxuXG5cbiAgICAgICAgaWYgKCF0cmlnZ2VyTm9kZSkge1xuICAgICAgICAgIGxpc3RJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKF90aGlzMi5vcHRpb25zLmNsYXNzT3BlbikpIHtcbiAgICAgICAgICAgICAgaXRlbS50YWJJbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVudUxpc3ROb2RlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yTWVudSk7XG5cbiAgICAgICAgaWYgKG1lbnVMaXN0Tm9kZSkge1xuICAgICAgICAgIG1lbnVMaXN0Tm9kZS50YWJJbmRleCA9IHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzT3BlbikgPyAnMCcgOiAnLTEnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBDdXJyZW50bHkgaGlnaGxpZ2h0ZWQgZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnROYXZpZ2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnROYXZpZ2F0aW9uKCkge1xuICAgICAgdmFyIGZvY3VzZWROb2RlOyAvLyBVc2luZyB0aGUgbGF0ZXN0IHNlbWFudGljIG1hcmt1cCBzdHJ1Y3R1cmUgd2hlcmUgdHJpZ2dlciBpcyBhIGJ1dHRvblxuICAgICAgLy8gQHRvZG8gcmVtb3ZlIGNvbmRpdGlvbmFsIG9uY2UgbGVnYWN5IHN0cnVjdHVyZSBpcyBkZXByZWNpYXRlZFxuICAgICAgLy8gTk9URTogYHNlbGVjdG9yVHJpZ2dlcmAgZG9lcyBOT1QgbWF0Y2ggdGhlIHRyaWdnZXIgYnV0dG9uIGluIG9sZGVyIG1hcmt1cFxuXG4gICAgICBpZiAodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yVHJpZ2dlcikpIHtcbiAgICAgICAgdmFyIGxpc3ROb2RlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yTWVudSk7XG4gICAgICAgIHZhciBmb2N1c2VkSWQgPSBsaXN0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgICBmb2N1c2VkTm9kZSA9IGZvY3VzZWRJZCA/IGxpc3ROb2RlLnF1ZXJ5U2VsZWN0b3IoXCIjXCIuY29uY2F0KGZvY3VzZWRJZCkpIDogbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb2N1c2VkID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgZm9jdXNlZE5vZGUgPSBmb2N1c2VkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBmb2N1c2VkLm1hdGNoZXModGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbSkgPyBmb2N1c2VkIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvY3VzZWROb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB1cC9kb3duIHRoZSBmb2N1cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gb2YgbmF2aWdhdGluZy5cbiAgICAgKi9cbiAgICAvLyBAdG9kbyBjcmVhdGUgaXNzdWUgaXQncyBhIGJldHRlciBVWCB0byBtb3ZlIHRoZSBmb2N1cyB3aGVuIHRoZSB1c2VyIGhvdmVycyBzbyB0aGV5IHN0YXkgaW4gc3luY1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmF2aWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF2aWdhdGUoZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0b0FycmF5KHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW0pKTtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0Q3VycmVudE5hdmlnYXRpb24oKSB8fCB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuc2VsZWN0b3JMaW5rU2VsZWN0ZWQpO1xuXG4gICAgICB2YXIgZ2V0TmV4dEl0ZW0gPSBmdW5jdGlvbiBnZXROZXh0SXRlbShvbGQpIHtcbiAgICAgICAgdmFyIGhhbmRsZVVuZGVyZmxvdyA9IGZ1bmN0aW9uIGhhbmRsZVVuZGVyZmxvdyhpLCBsKSB7XG4gICAgICAgICAgcmV0dXJuIGkgKyAoaSA+PSAwID8gMCA6IGwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVPdmVyZmxvdyA9IGZ1bmN0aW9uIGhhbmRsZU92ZXJmbG93KGksIGwpIHtcbiAgICAgICAgICByZXR1cm4gaSAtIChpIDwgbCA/IDAgOiBsKTtcbiAgICAgICAgfTsgLy8gYGl0ZW1zLmluZGV4T2Yob2xkKWAgbWF5IGJlIC0xIChTY2VuYXJpbyBvZiBubyBwcmV2aW91cyBmb2N1cylcblxuXG4gICAgICAgIHZhciBpbmRleCA9IE1hdGgubWF4KGl0ZW1zLmluZGV4T2Yob2xkKSArIGRpcmVjdGlvbiwgLTEpO1xuICAgICAgICByZXR1cm4gaXRlbXNbaGFuZGxlVW5kZXJmbG93KGhhbmRsZU92ZXJmbG93KGluZGV4LCBpdGVtcy5sZW5ndGgpLCBpdGVtcy5sZW5ndGgpXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBpc1Nob3dTZWxlY3RlZCA9IHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzU2hvd1NlbGVjdGVkKTtcblxuICAgICAgZm9yICh2YXIgY3VycmVudCA9IGdldE5leHRJdGVtKHN0YXJ0KTsgY3VycmVudCAmJiBjdXJyZW50ICE9PSBzdGFydDsgY3VycmVudCA9IGdldE5leHRJdGVtKGN1cnJlbnQpKSB7XG4gICAgICAgIGlmICghY3VycmVudC5tYXRjaGVzKHRoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW1IaWRkZW4pICYmICFjdXJyZW50LnBhcmVudE5vZGUubWF0Y2hlcyh0aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtSGlkZGVuKSAmJiAoaXNTaG93U2VsZWN0ZWQgfHwgIWlzU2hvd1NlbGVjdGVkICYmICFjdXJyZW50LnBhcmVudEVsZW1lbnQubWF0Y2hlcyh0aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtU2VsZWN0ZWQpKSkge1xuICAgICAgICAgIC8vIFVzaW5nIHRoZSBsYXRlc3Qgc2VtYW50aWMgbWFya3VwIHN0cnVjdHVyZSB3aGVyZSB0cmlnZ2VyIGlzIGEgYnV0dG9uXG4gICAgICAgICAgLy8gQHRvZG8gcmVtb3ZlIGNvbmRpdGlvbmFsIG9uY2UgbGVnYWN5IHN0cnVjdHVyZSBpcyBkZXByZWNpYXRlZFxuICAgICAgICAgIC8vIE5PVEU6IGBzZWxlY3RvclRyaWdnZXJgIGRvZXMgTk9UIG1hdGNoIHRoZSB0cmlnZ2VyIGJ1dHRvbiBpbiBvbGRlciBtYXJrdXBcbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yVHJpZ2dlcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvY3VzKGN1cnJlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBjbGlja2luZyBvbiB0aGUgZHJvcGRvd24gb3B0aW9ucywgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAgICAgKiAqIENoYW5nZSBEcm9wZG93biB0ZXh0IHRvIHNlbGVjdGVkIG9wdGlvbi5cbiAgICAgKiAqIFJlbW92ZSBzZWxlY3RlZCBvcHRpb24gZnJvbSBvcHRpb25zIHdoZW4gc2VsZWN0ZWQuXG4gICAgICogKiBFbWl0IGN1c3RvbSBldmVudHMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbVRvU2VsZWN0IFRoZSBlbGVtZW50IHRvIGJlIGFjdGl2YXRlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoaXRlbVRvU2VsZWN0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGV2ZW50U3RhcnQgPSBuZXcgQ3VzdG9tRXZlbnQodGhpcy5vcHRpb25zLmV2ZW50QmVmb3JlU2VsZWN0ZWQsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgaXRlbTogaXRlbVRvU2VsZWN0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnRTdGFydCkpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5kYXRhc2V0LmRyb3Bkb3duVHlwZSAhPT0gJ25hdmlnYXRpb24nKSB7XG4gICAgICAgICAgLy8gTk9URTogYHNlbGVjdG9yVHJpZ2dlcmAgZG9lcyBOT1QgbWF0Y2ggdGhlIHRyaWdnZXIgYnV0dG9uIGluIG9sZGVyIG1hcmt1cFxuICAgICAgICAgIHZhciBzZWxlY3RvclRleHQgPSAhdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yVHJpZ2dlcikgJiYgdGhpcy5lbGVtZW50LmRhdGFzZXQuZHJvcGRvd25UeXBlICE9PSAnaW5saW5lJyA/IHRoaXMub3B0aW9ucy5zZWxlY3RvclRleHQgOiB0aGlzLm9wdGlvbnMuc2VsZWN0b3JUZXh0SW5uZXI7XG4gICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvclRleHQpO1xuXG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQuaW5uZXJIVE1MID0gaXRlbVRvU2VsZWN0LmlubmVySFRNTDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVtVG9TZWxlY3QucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc1NlbGVjdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudC5kYXRhc2V0LnZhbHVlID0gaXRlbVRvU2VsZWN0LnBhcmVudEVsZW1lbnQuZGF0YXNldC52YWx1ZTtcbiAgICAgICAgdG9BcnJheSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JMaW5rU2VsZWN0ZWQpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW1Ub1NlbGVjdCAhPT0gaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMzLm9wdGlvbnMuY2xhc3NTZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KHRoaXMub3B0aW9ucy5ldmVudEFmdGVyU2VsZWN0ZWQsIHtcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpdGVtOiBpdGVtVG9TZWxlY3RcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBkcm9wZG93biBtZW51IGlmIHRoaXMgY29tcG9uZW50IGxvc2VzIGZvY3VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQmx1clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNsYXNzT3Blbik7XG5cbiAgICAgIHRoaXMuX2ZvY3VzQ2xlYW51cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBzZWxlY3RvciBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIERyb3Bkb3duLmNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsIHtAbGlua2NvZGUgRHJvcGRvd24uY3JlYXRlIC5jcmVhdGUoKX0sIG9yIHtAbGlua2NvZGUgRHJvcGRvd24uaW5pdCAuaW5pdCgpfSxcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBvdmVycmlkZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlIGFuZCBob3cge0BsaW5rY29kZSBEcm9wZG93bi5pbml0IC5pbml0KCl9IHdvcmtzLlxuICAgICAqIEBtZW1iZXIgRHJvcGRvd24ub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgc2VsZWN0b3JzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JUcmlnZ2VyXVxuICAgICAqICAgVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSB0cmlnZ2VyIGJ1dHRvbiB3aGVuIHVzaW5nIGExMXkgY29tcGxpYW50IG1hcmt1cC5cbiAgICAgKiAgIE5PVEU6IERvZXMgTk9UIG1hdGNoIHRoZSB0cmlnZ2VyIGJ1dHRvbiBpbiBvbGRlciBtYXJrdXAuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3Rvck1lbnVdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBtZW51IGxpc3Qgd2hlbiB1c2luZyBhMTF5IGNvbXBsaWFudCBtYXJrdXAuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclRleHRdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgZWxlbWVudCBzaG93aW5nIHRoZSBzZWxlY3RlZCBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JUZXh0SW5uZXJdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgZWxlbWVudCBzaG93aW5nIHRoZSBzZWxlY3RlZCBpdGVtLCB1c2VkIGZvciBpbmxpbmUgbW9kZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9ySXRlbV0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIGNsaWNrYWJsZSBhcmVhcyBpbiBkcm9wZG93biBpdGVtcy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9ySXRlbUhpZGRlbl1cbiAgICAgKiAgIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBoaWRkZW4gZHJvcGRvd24gaXRlbXMuXG4gICAgICogICBVc2VkIHRvIHNraXAgZHJvcGRvd24gaXRlbXMgZm9yIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3Rvckl0ZW1TZWxlY3RlZF0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBjbGlja2FibGUgYXJlYSBpbiB0aGUgc2VsZWN0ZWQgZHJvcGRvd24gaXRlbS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9ySXRlbUZvY3VzZWRdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgY2xpY2thYmxlIGFyZWEgaW4gdGhlIGZvY3VzZWQgZHJvcGRvd24gaXRlbS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yTGlua1NlbGVjdGVkXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIHRhcmdldCB0aGUgbGluayBub2RlIG9mIHRoZSBzZWxlY3RlZCBkcm9wZG93biBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NTaG93U2VsZWN0ZWRdIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBzaG93IHNlbGVjdGVkIG1vZGlmaWVyIG9mIHRoZSBkcm9wZG93bi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzU2VsZWN0ZWRdIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBzZWxlY3RlZCBkcm9wZG93biBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NGb2N1c2VkXSBUaGUgQ1NTIGNsYXNzIGZvciB0aGUgZm9jdXNlZCBkcm9wZG93biBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NPcGVuXSBUaGUgQ1NTIGNsYXNzIGZvciB0aGUgb3BlbiBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzRGlzYWJsZWRdIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50QmVmb3JlU2VsZWN0ZWRdXG4gICAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIGJlZm9yZSBhIGRyb3AgZG93biBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAqICAgQ2FuY2VsbGF0aW9uIG9mIHRoaXMgZXZlbnQgc3RvcHMgc2VsZWN0aW9uIG9mIGRyb3AgZG93biBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXZlbnRBZnRlclNlbGVjdGVkXSBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIGFmdGVyIGEgZHJvcCBkb3duIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLWRyb3Bkb3duXScsXG4gICAgICAgIHNlbGVjdG9yVHJpZ2dlcjogXCJidXR0b24uXCIuY29uY2F0KHByZWZpeCwgXCItLWRyb3Bkb3duLXRleHRcIiksXG4gICAgICAgIC8vIE5PVEU6IERvZXMgTk9UIG1hdGNoIHRoZSB0cmlnZ2VyIGJ1dHRvbiBpbiBvbGRlciBtYXJrdXAuXG4gICAgICAgIHNlbGVjdG9yTWVudTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWRyb3Bkb3duLWxpc3RcIiksXG4gICAgICAgIHNlbGVjdG9yVGV4dDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWRyb3Bkb3duLXRleHRcIiksXG4gICAgICAgIHNlbGVjdG9yVGV4dElubmVyOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tZHJvcGRvd24tdGV4dF9faW5uZXJcIiksXG4gICAgICAgIHNlbGVjdG9ySXRlbTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWRyb3Bkb3duLWxpbmtcIiksXG4gICAgICAgIHNlbGVjdG9ySXRlbVNlbGVjdGVkOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tZHJvcGRvd24tLXNlbGVjdGVkXCIpLFxuICAgICAgICBzZWxlY3Rvckl0ZW1Gb2N1c2VkOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tZHJvcGRvd24tLWZvY3VzZWRcIiksXG4gICAgICAgIHNlbGVjdG9ySXRlbUhpZGRlbjogXCJbaGlkZGVuXSxbYXJpYS1oaWRkZW49XFxcInRydWVcXFwiXVwiLFxuICAgICAgICBzZWxlY3RvckxpbmtTZWxlY3RlZDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWRyb3Bkb3duLS1zZWxlY3RlZCAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1kcm9wZG93bi1saW5rXCIpLFxuICAgICAgICBjbGFzc1Nob3dTZWxlY3RlZDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZHJvcGRvd24tLXNob3ctc2VsZWN0ZWRcIiksXG4gICAgICAgIGNsYXNzU2VsZWN0ZWQ6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWRyb3Bkb3duLS1zZWxlY3RlZFwiKSxcbiAgICAgICAgY2xhc3NGb2N1c2VkOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1kcm9wZG93bi0tZm9jdXNlZFwiKSxcbiAgICAgICAgY2xhc3NPcGVuOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1kcm9wZG93bi0tb3BlblwiKSxcbiAgICAgICAgY2xhc3NEaXNhYmxlZDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZHJvcGRvd24tLWRpc2FibGVkXCIpLFxuICAgICAgICBldmVudEJlZm9yZVNlbGVjdGVkOiAnZHJvcGRvd24tYmVpbmdzZWxlY3RlZCcsXG4gICAgICAgIGV2ZW50QWZ0ZXJTZWxlY3RlZDogJ2Ryb3Bkb3duLXNlbGVjdGVkJ1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW51bSBmb3IgbmF2aWdhdGluZyBiYWNrd2FyZC9mb3J3YXJkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIgRHJvcGRvd24uTkFWSUdBVEVcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCQUNLV0FSRCBOYXZpZ2F0aW5nIGJhY2t3YXJkLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGT1JXQVJEIE5hdmlnYXRpbmcgZm9yd2FyZC5cbiAgICAgKi9cblxuICB9XSk7XG5cbiAgRHJvcGRvd24uY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIERyb3Bkb3duLk5BVklHQVRFID0ge1xuICAgIEJBQ0tXQVJEOiAtMSxcbiAgICBGT1JXQVJEOiAxXG4gIH07XG4gIHJldHVybiBEcm9wZG93bjtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gsIHRyYWNrQmx1cikpO1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bjsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBldmVudGVkU3RhdGUgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvZXZlbnRlZC1zdGF0ZSc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL2V2ZW50LW1hdGNoZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59O1xuXG52YXIgRmlsZVVwbG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKEZpbGVVcGxvYWRlciwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEZpbGVVcGxvYWRlcik7XG4gIC8qKlxuICAgKiBGaWxlIHVwbG9hZGVyLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIGV2ZW50ZWRTdGF0ZVxuICAgKiBAZXh0ZW5kcyBIYW5kbGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhIGZpbGUgdXBsb2FkZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLiBTZWUgc3RhdGljIG9wdGlvbnMuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gRmlsZVVwbG9hZGVyKGVsZW1lbnQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZVVwbG9hZGVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRldGFpbCwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2RlbGV0ZS1maWxlbmFtZS1maWxldXBsb2FkZXInKSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZChkZXRhaWwuZmlsZW5hbWVFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5faGFuZGxlRGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyIHRhcmdldCA9IGV2ZW50TWF0Y2hlcyhldnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JDbG9zZUJ1dHRvbik7XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgX3RoaXMuY2hhbmdlU3RhdGUoJ2RlbGV0ZS1maWxlbmFtZS1maWxldXBsb2FkZXInLCB7XG4gICAgICAgICAgaW5pdGlhbEV2dDogZXZ0LFxuICAgICAgICAgIGZpbGVuYW1lRWxlbWVudDogdGFyZ2V0LmNsb3Nlc3QoX3RoaXMub3B0aW9ucy5zZWxlY3RvclNlbGVjdGVkRmlsZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLl9oYW5kbGVEcmFnRHJvcCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHZhciBpc09mU2VsZiA9IF90aGlzLmVsZW1lbnQuY29udGFpbnMoZXZ0LnRhcmdldCk7IC8vIEluIElFMTEgYGV2dC5kYXRhVHJhbnNmZXIudHlwZXNgIGlzIGEgYERPTVN0cmluZ0xpc3RgIGluc3RlYWQgb2YgYW4gYXJyYXlcblxuXG4gICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChldnQuZGF0YVRyYW5zZmVyLnR5cGVzLCAnRmlsZXMnKSA+PSAwICYmICFldmVudE1hdGNoZXMoZXZ0LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yT3RoZXJEcm9wQ29udGFpbmVycykpIHtcbiAgICAgICAgdmFyIGluQXJlYSA9IGlzT2ZTZWxmICYmIGV2ZW50TWF0Y2hlcyhldnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JEcm9wQ29udGFpbmVyKTtcblxuICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdkcmFnb3ZlcicpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgZHJvcEVmZmVjdCA9IGluQXJlYSA/ICdjb3B5JyA6ICdub25lJztcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2dC5kYXRhVHJhbnNmZXIudHlwZXMpKSB7XG4gICAgICAgICAgICAvLyBJRTExIHRocm93cyBhIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciBhY2Nlc3NpbmcgYC5lZmZlY3RBbGxvd2VkYFxuICAgICAgICAgICAgZXZ0LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gZHJvcEVmZmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBkcm9wRWZmZWN0O1xuXG4gICAgICAgICAgX3RoaXMuZHJvcENvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKF90aGlzLm9wdGlvbnMuY2xhc3NEcmFnT3ZlciwgQm9vbGVhbihpbkFyZWEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldnQudHlwZSA9PT0gJ2RyYWdsZWF2ZScpIHtcbiAgICAgICAgICBfdGhpcy5kcm9wQ29udGFpbmVyLmNsYXNzTGlzdC50b2dnbGUoX3RoaXMub3B0aW9ucy5jbGFzc0RyYWdPdmVyLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5BcmVhICYmIGV2dC50eXBlID09PSAnZHJvcCcpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLl9kaXNwbGF5RmlsZW5hbWVzKGV2dC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuXG4gICAgICAgICAgX3RoaXMuZHJvcENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKF90aGlzLm9wdGlvbnMuY2xhc3NEcmFnT3Zlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaW5wdXQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvcklucHV0KTtcbiAgICBfdGhpcy5jb250YWluZXIgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckNvbnRhaW5lcik7XG4gICAgX3RoaXMuZHJvcENvbnRhaW5lciA9IF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yRHJvcENvbnRhaW5lcik7XG5cbiAgICBpZiAoIV90aGlzLmlucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZmluZCB0aGUgZmlsZSBpbnB1dCBib3guJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBmaW5kIHRoZSBmaWxlIG5hbWVzIGNvbnRhaW5lci4nKTtcbiAgICB9XG5cbiAgICBfdGhpcy5pbnB1dElkID0gX3RoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmlucHV0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9kaXNwbGF5RmlsZW5hbWVzKCk7XG4gICAgfSkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmNvbnRhaW5lciwgJ2NsaWNrJywgX3RoaXMuX2hhbmRsZURlbGV0ZUJ1dHRvbikpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudCwgJ2RyYWdsZWF2ZScsIF90aGlzLl9oYW5kbGVEcmFnRHJvcCkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmRyb3BDb250YWluZXIsICdkcmFnb3ZlcicsIF90aGlzLl9oYW5kbGVEcmFnRHJvcCkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmRyb3BDb250YWluZXIsICdkcm9wJywgX3RoaXMuX2hhbmRsZURyYWdEcm9wKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmlsZVVwbG9hZGVyLCBbe1xuICAgIGtleTogXCJfZmlsZW5hbWVzSFRNTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsZW5hbWVzSFRNTChuYW1lLCBpZCkge1xuICAgICAgcmV0dXJuIFwiPHNwYW4gY2xhc3M9XFxcIlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuY2xhc3NTZWxlY3RlZEZpbGUsIFwiXFxcIj5cXG4gICAgICA8cCBjbGFzcz1cXFwiXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMuY2xhc3NGaWxlTmFtZSwgXCJcXFwiPlwiKS5jb25jYXQobmFtZSwgXCI8L3A+XFxuICAgICAgPHNwYW4gZGF0YS1mb3I9XFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMuY2xhc3NTdGF0ZUNvbnRhaW5lciwgXCJcXFwiPjwvc3Bhbj5cXG4gICAgPC9zcGFuPlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwbG9hZEhUTUxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwbG9hZEhUTUwoKSB7XG4gICAgICByZXR1cm4gXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLmNsYXNzTG9hZGluZ0FuaW1hdGlvbiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdiBkYXRhLWlubGluZS1sb2FkaW5nLXNwaW5uZXIgY2xhc3M9XFxcIlwiKS5jb25jYXQodGhpcy5vcHRpb25zLmNsYXNzTG9hZGluZywgXCJcXFwiPlxcbiAgICAgICAgICA8c3ZnIGNsYXNzPVxcXCJcIikuY29uY2F0KHRoaXMub3B0aW9ucy5jbGFzc0xvYWRpbmdTdmcsIFwiXFxcIiB2aWV3Qm94PVxcXCItNzUgLTc1IDE1MCAxNTBcXFwiPlxcbiAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XFxcIlwiKS5jb25jYXQodGhpcy5vcHRpb25zLmNsYXNzTG9hZGluZ0JhY2tncm91bmQsIFwiXFxcIiBjeD1cXFwiMFxcXCIgY3k9XFxcIjBcXFwiIHI9XFxcIjM3LjVcXFwiIC8+XFxuICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cXFwiXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMuY2xhc3NMb2FkaW5nU3Ryb2tlLCBcIlxcXCIgY3g9XFxcIjBcXFwiIGN5PVxcXCIwXFxcIiByPVxcXCIzNy41XFxcIiAvPlxcbiAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nsb3NlQnV0dG9uSFRNTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xvc2VCdXR0b25IVE1MKCkge1xuICAgICAgcmV0dXJuIFwiXFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5jbGFzc0ZpbGVDbG9zZSwgXCJcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgYXJpYS1sYWJlbD1cXFwiY2xvc2VcXFwiPlxcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjE2XFxcIj5cXG4gICAgICA8cGF0aCBmaWxsPVxcXCIjMjMxRjIwXFxcIiBkPVxcXCJNMTIgNC43bC0uNy0uN0w4IDcuMyA0LjcgNGwtLjcuN0w3LjMgOCA0IDExLjNsLjcuN0w4IDguN2wzLjMgMy4zLjctLjdMOC43IDh6XFxcIi8+XFxuICAgICAgPC9zdmc+XFxuICAgICAgPC9idXR0b24+XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2ttYXJrSFRNTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2ttYXJrSFRNTCgpIHtcbiAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzdmcgZm9jdXNhYmxlPVxcXCJmYWxzZVxcXCJcXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XFxcInhNaWRZTWlkIG1lZXRcXFwiXFxuICAgICAgICBzdHlsZT1cXFwid2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXFwiXFxuICAgICAgICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5jbGFzc0ZpbGVDb21wbGV0ZSwgXCJcXFwiXFxuICAgICAgICB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCJcXG4gICAgICAgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIk04IDFDNC4xIDEgMSA0LjEgMSA4czMuMSA3IDcgNyA3LTMuMSA3LTctMy4xLTctNy03ek03IDExTDQuMyA4LjNsLjktLjhMNyA5LjNsNC0zLjkuOS44TDcgMTF6XFxcIj48L3BhdGg+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNNyAxMUw0LjMgOC4zbC45LS44TDcgOS4zbDQtMy45LjkuOEw3IDExelxcXCIgZGF0YS1pY29uLXBhdGg9XFxcImlubmVyLXBhdGhcXFwiIG9wYWNpdHk9XFxcIjBcXFwiPjwvcGF0aD5cXG4gICAgICA8L3N2Zz5cXG4gICAgXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RhdGVDb250YWluZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdGF0ZUNvbnRhaW5lcnMoKSB7XG4gICAgICB2YXIgc3RhdGVDb250YWluZXJzID0gdG9BcnJheSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWZvcj1cIi5jb25jYXQodGhpcy5pbnB1dElkLCBcIl1cIikpKTtcblxuICAgICAgaWYgKHN0YXRlQ29udGFpbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhdGUgY29udGFpbmVyIGVsZW1lbnRzIG5vdCBmb3VuZDsgaW52b2tlIF9kaXNwbGF5RmlsZW5hbWVzKCkgZmlyc3QnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlQ29udGFpbmVyc1swXS5kYXRhc2V0LmZvciAhPT0gdGhpcy5pbnB1dElkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpbGUgaW5wdXQgaWQgbXVzdCBlcXVhbCBbZGF0YS1mb3JdIGF0dHJpYnV0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGVDb250YWluZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmplY3Qgc2VsZWN0ZWQgZmlsZXMgaW50byBET00uIEludm9rZWQgb24gY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RmlsZVtdfSBmaWxlcyBUaGUgZmlsZXMgdG8gdXBsb2FkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rpc3BsYXlGaWxlbmFtZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3BsYXlGaWxlbmFtZXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZpbGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmlucHV0LmZpbGVzO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvckNvbnRhaW5lcik7XG4gICAgICB2YXIgSFRNTFN0cmluZyA9IHRvQXJyYXkoZmlsZXMpLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9maWxlbmFtZXNIVE1MKGZpbGUubmFtZSwgX3RoaXMyLmlucHV0SWQpO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgSFRNTFN0cmluZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlU3RhdGUoZWxlbWVudCkge1xuICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RPTSBlbGVtZW50IHNob3VsZCBiZSBnaXZlbiB0byBpbml0aWFsaXplIHRoaXMgd2lkZ2V0LicpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVN0YXRlQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVTdGF0ZUNoYW5nZShlbGVtZW50cywgc2VsZWN0SW5kZXgsIGh0bWwpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZWN0SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIF90aGlzMy5fcmVtb3ZlU3RhdGUoZWwpO1xuXG4gICAgICAgICAgZWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBodG1sKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IHNlbGVjdEluZGV4KSB7XG4gICAgICAgICAgICBfdGhpczMuX3JlbW92ZVN0YXRlKGVsKTtcblxuICAgICAgICAgICAgZWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBodG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGRlbGV0ZSBidXR0b24uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZ0IFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSwgc2VsZWN0SW5kZXgpIHtcbiAgICAgIHZhciBzdGF0ZUNvbnRhaW5lcnMgPSB0aGlzLl9nZXRTdGF0ZUNvbnRhaW5lcnMoKTtcblxuICAgICAgaWYgKHN0YXRlID09PSAnZWRpdCcpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlU3RhdGVDaGFuZ2Uoc3RhdGVDb250YWluZXJzLCBzZWxlY3RJbmRleCwgdGhpcy5fY2xvc2VCdXR0b25IVE1MKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09ICd1cGxvYWQnKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVN0YXRlQ2hhbmdlKHN0YXRlQ29udGFpbmVycywgc2VsZWN0SW5kZXgsIHRoaXMuX3VwbG9hZEhUTUwoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICB0aGlzLl9oYW5kbGVTdGF0ZUNoYW5nZShzdGF0ZUNvbnRhaW5lcnMsIHNlbGVjdEluZGV4LCB0aGlzLl9jaGVja21hcmtIVE1MKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBmaWxlIHVwbG9hZGVyIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXIgRmlsZVVwbG9hZGVyLmNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLWZpbGVdJyxcbiAgICAgICAgc2VsZWN0b3JJbnB1dDogXCJpbnB1dFt0eXBlPVxcXCJmaWxlXFxcIl0uXCIuY29uY2F0KHByZWZpeCwgXCItLWZpbGUtaW5wdXRcIiksXG4gICAgICAgIHNlbGVjdG9yQ29udGFpbmVyOiAnW2RhdGEtZmlsZS1jb250YWluZXJdJyxcbiAgICAgICAgc2VsZWN0b3JDbG9zZUJ1dHRvbjogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWZpbGUtY2xvc2VcIiksXG4gICAgICAgIHNlbGVjdG9yU2VsZWN0ZWRGaWxlOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tZmlsZV9fc2VsZWN0ZWQtZmlsZVwiKSxcbiAgICAgICAgc2VsZWN0b3JEcm9wQ29udGFpbmVyOiBcIltkYXRhLWZpbGUtZHJvcC1jb250YWluZXJdXCIsXG4gICAgICAgIHNlbGVjdG9yT3RoZXJEcm9wQ29udGFpbmVyczogJ1tkYXRhLWRyb3AtY29udGFpbmVyXScsXG4gICAgICAgIGNsYXNzTG9hZGluZzogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tbG9hZGluZyBcIikuY29uY2F0KHByZWZpeCwgXCItLWxvYWRpbmctLXNtYWxsXCIpLFxuICAgICAgICBjbGFzc0xvYWRpbmdBbmltYXRpb246IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWlubGluZS1sb2FkaW5nX19hbmltYXRpb25cIiksXG4gICAgICAgIGNsYXNzTG9hZGluZ1N2ZzogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tbG9hZGluZ19fc3ZnXCIpLFxuICAgICAgICBjbGFzc0xvYWRpbmdCYWNrZ3JvdW5kOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1sb2FkaW5nX19iYWNrZ3JvdW5kXCIpLFxuICAgICAgICBjbGFzc0xvYWRpbmdTdHJva2U6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWxvYWRpbmdfX3N0cm9rZVwiKSxcbiAgICAgICAgY2xhc3NGaWxlTmFtZTogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZmlsZS1maWxlbmFtZVwiKSxcbiAgICAgICAgY2xhc3NGaWxlQ2xvc2U6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWZpbGUtY2xvc2VcIiksXG4gICAgICAgIGNsYXNzRmlsZUNvbXBsZXRlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1maWxlLWNvbXBsZXRlXCIpLFxuICAgICAgICBjbGFzc1NlbGVjdGVkRmlsZTogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZmlsZV9fc2VsZWN0ZWQtZmlsZVwiKSxcbiAgICAgICAgY2xhc3NTdGF0ZUNvbnRhaW5lcjogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tZmlsZV9fc3RhdGUtY29udGFpbmVyXCIpLFxuICAgICAgICBjbGFzc0RyYWdPdmVyOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1maWxlX19kcm9wLWNvbnRhaW5lci0tZHJhZy1vdmVyXCIpLFxuICAgICAgICBldmVudEJlZm9yZURlbGV0ZUZpbGVuYW1lRmlsZXVwbG9hZGVyOiAnZmlsZXVwbG9hZGVyLWJlZm9yZS1kZWxldGUtZmlsZW5hbWUnLFxuICAgICAgICBldmVudEFmdGVyRGVsZXRlRmlsZW5hbWVGaWxldXBsb2FkZXI6ICdmaWxldXBsb2FkZXItYWZ0ZXItZGVsZXRlLWZpbGVuYW1lJ1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBGaWxlVXBsb2FkZXIuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBGaWxlVXBsb2FkZXI7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBldmVudGVkU3RhdGUsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgRmlsZVVwbG9hZGVyOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBldmVudGVkU2hvd0hpZGVTdGF0ZSBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9ldmVudGVkLXNob3ctaGlkZS1zdGF0ZSc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCB0cmFja0JsdXIgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvdHJhY2stYmx1cic7XG5pbXBvcnQgZ2V0TGF1bmNoaW5nRGV0YWlscyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZ2V0LWxhdW5jaGluZy1kZXRhaWxzJztcbmltcG9ydCBvcHRpbWl6ZWRSZXNpemUgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL3Jlc2l6ZSc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcbi8qKlxuICogVGhlIHN0cnVjdHVyZSBmb3IgdGhlIHBvc2l0aW9uIG9mIGZsb2F0aW5nIG1lbnUuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGbG9hdGluZ01lbnV+cG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0IFRoZSBsZWZ0IHBvc2l0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCBUaGUgdG9wIHBvc2l0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJpZ2h0IFRoZSByaWdodCBwb3NpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3R0b20gVGhlIGJvdHRvbSBwb3NpdGlvbi5cbiAqL1xuXG4vKipcbiAqIFRoZSBzdHJ1Y3R1cmUgZm9yIHRoZSBzaXplIG9mIGZsb2F0aW5nIG1lbnUuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGbG9hdGluZ01lbnV+c2l6ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodC5cbiAqL1xuXG4vKipcbiAqIFRoZSBzdHJ1Y3R1cmUgZm9yIHRoZSBwb3NpdGlvbiBvZmZzZXQgb2YgZmxvYXRpbmcgbWVudS5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZsb2F0aW5nTWVudX5vZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3AgVGhlIHRvcCBwb3NpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0IFRoZSBsZWZ0IHBvc2l0aW9uLlxuICovXG5cbmV4cG9ydCB2YXIgRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIERJUkVDVElPTl9UT1AgPSAndG9wJztcbmV4cG9ydCB2YXIgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgRElSRUNUSU9OX0JPVFRPTSA9ICdib3R0b20nO1xuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtGbG9hdGluZ01lbnV+c2l6ZX0gcGFyYW1zLm1lbnVTaXplIFRoZSBzaXplIG9mIHRoZSBtZW51LlxuICogQHBhcmFtIHtGbG9hdGluZ01lbnV+cG9zaXRpb259IHBhcmFtcy5yZWZQb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXJpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7RmxvYXRpbmdNZW51fm9mZnNldH0gW3BhcmFtcy5vZmZzZXQ9eyBsZWZ0OiAwLCB0b3A6IDAgfV0gVGhlIHBvc2l0aW9uIG9mZnNldCBvZiB0aGUgbWVudS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmRpcmVjdGlvbj1ib3R0b21dIFRoZSBtZW51IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnNjcm9sbFg9MF0gVGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5zY3JvbGxZPTBdIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0LlxuICogQHJldHVybnMge0Zsb2F0aW5nTWVudX5vZmZzZXR9IFRoZSBwb3NpdGlvbiBvZiB0aGUgbWVudSwgcmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCB2YXIgZ2V0RmxvYXRpbmdQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEZsb2F0aW5nUG9zaXRpb24oX3JlZikge1xuICB2YXIgX0RJUkVDVElPTl9MRUZUJERJUkVDO1xuXG4gIHZhciBtZW51U2l6ZSA9IF9yZWYubWVudVNpemUsXG4gICAgICByZWZQb3NpdGlvbiA9IF9yZWYucmVmUG9zaXRpb24sXG4gICAgICBfcmVmJG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX3JlZiRvZmZzZXQgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvZmZzZXQsXG4gICAgICBfcmVmJGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgICAgZGlyZWN0aW9uID0gX3JlZiRkaXJlY3Rpb24gPT09IHZvaWQgMCA/IERJUkVDVElPTl9CT1RUT00gOiBfcmVmJGRpcmVjdGlvbixcbiAgICAgIF9yZWYkc2Nyb2xsWCA9IF9yZWYuc2Nyb2xsWCxcbiAgICAgIHNjcm9sbFggPSBfcmVmJHNjcm9sbFggPT09IHZvaWQgMCA/IDAgOiBfcmVmJHNjcm9sbFgsXG4gICAgICBfcmVmJHNjcm9sbFkgPSBfcmVmLnNjcm9sbFksXG4gICAgICBzY3JvbGxZID0gX3JlZiRzY3JvbGxZID09PSB2b2lkIDAgPyAwIDogX3JlZiRzY3JvbGxZO1xuICB2YXIgX3JlZlBvc2l0aW9uJGxlZnQgPSByZWZQb3NpdGlvbi5sZWZ0LFxuICAgICAgcmVmTGVmdCA9IF9yZWZQb3NpdGlvbiRsZWZ0ID09PSB2b2lkIDAgPyAwIDogX3JlZlBvc2l0aW9uJGxlZnQsXG4gICAgICBfcmVmUG9zaXRpb24kdG9wID0gcmVmUG9zaXRpb24udG9wLFxuICAgICAgcmVmVG9wID0gX3JlZlBvc2l0aW9uJHRvcCA9PT0gdm9pZCAwID8gMCA6IF9yZWZQb3NpdGlvbiR0b3AsXG4gICAgICBfcmVmUG9zaXRpb24kcmlnaHQgPSByZWZQb3NpdGlvbi5yaWdodCxcbiAgICAgIHJlZlJpZ2h0ID0gX3JlZlBvc2l0aW9uJHJpZ2h0ID09PSB2b2lkIDAgPyAwIDogX3JlZlBvc2l0aW9uJHJpZ2h0LFxuICAgICAgX3JlZlBvc2l0aW9uJGJvdHRvbSA9IHJlZlBvc2l0aW9uLmJvdHRvbSxcbiAgICAgIHJlZkJvdHRvbSA9IF9yZWZQb3NpdGlvbiRib3R0b20gPT09IHZvaWQgMCA/IDAgOiBfcmVmUG9zaXRpb24kYm90dG9tO1xuICB2YXIgd2lkdGggPSBtZW51U2l6ZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IG1lbnVTaXplLmhlaWdodDtcbiAgdmFyIF9vZmZzZXQkdG9wID0gb2Zmc2V0LnRvcCxcbiAgICAgIHRvcCA9IF9vZmZzZXQkdG9wID09PSB2b2lkIDAgPyAwIDogX29mZnNldCR0b3AsXG4gICAgICBfb2Zmc2V0JGxlZnQgPSBvZmZzZXQubGVmdCxcbiAgICAgIGxlZnQgPSBfb2Zmc2V0JGxlZnQgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0JGxlZnQ7XG4gIHZhciByZWZDZW50ZXJIb3Jpem9udGFsID0gKHJlZkxlZnQgKyByZWZSaWdodCkgLyAyO1xuICB2YXIgcmVmQ2VudGVyVmVydGljYWwgPSAocmVmVG9wICsgcmVmQm90dG9tKSAvIDI7XG4gIHJldHVybiAoX0RJUkVDVElPTl9MRUZUJERJUkVDID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfRElSRUNUSU9OX0xFRlQkRElSRUMsIERJUkVDVElPTl9MRUZULCB7XG4gICAgbGVmdDogcmVmTGVmdCAtIHdpZHRoICsgc2Nyb2xsWCAtIGxlZnQsXG4gICAgdG9wOiByZWZDZW50ZXJWZXJ0aWNhbCAtIGhlaWdodCAvIDIgKyBzY3JvbGxZICsgdG9wXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX0RJUkVDVElPTl9MRUZUJERJUkVDLCBESVJFQ1RJT05fVE9QLCB7XG4gICAgbGVmdDogcmVmQ2VudGVySG9yaXpvbnRhbCAtIHdpZHRoIC8gMiArIHNjcm9sbFggKyBsZWZ0LFxuICAgIHRvcDogcmVmVG9wIC0gaGVpZ2h0ICsgc2Nyb2xsWSAtIHRvcFxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9ESVJFQ1RJT05fTEVGVCRESVJFQywgRElSRUNUSU9OX1JJR0hULCB7XG4gICAgbGVmdDogcmVmUmlnaHQgKyBzY3JvbGxYICsgbGVmdCxcbiAgICB0b3A6IHJlZkNlbnRlclZlcnRpY2FsIC0gaGVpZ2h0IC8gMiArIHNjcm9sbFkgKyB0b3BcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfRElSRUNUSU9OX0xFRlQkRElSRUMsIERJUkVDVElPTl9CT1RUT00sIHtcbiAgICBsZWZ0OiByZWZDZW50ZXJIb3Jpem9udGFsIC0gd2lkdGggLyAyICsgc2Nyb2xsWCArIGxlZnQsXG4gICAgdG9wOiByZWZCb3R0b20gKyBzY3JvbGxZICsgdG9wXG4gIH0pLCBfRElSRUNUSU9OX0xFRlQkRElSRUMpW2RpcmVjdGlvbl07XG59O1xuXG52YXIgRmxvYXRpbmdNZW51ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKEZsb2F0aW5nTWVudSwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEZsb2F0aW5nTWVudSk7XG4gIC8qKlxuICAgKiBGbG9hdGluZyBtZW51LlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgRXZlbnRlZFNob3dIaWRlU3RhdGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGEgbW9kYWwgZGlhbG9nLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yQ29udGFpbmVyXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGNvbnRhaW5lciB0byBwdXQgdGhpcyBtZW51IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXR0cmliRGlyZWN0aW9uXSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gc3BlY2lmeSBtZW51IHBsYWNlbWVudCBkaXJlY3Rpb24gKHRvcC9yaWdodC9ib3R0b20vbGVmdCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc1Nob3duXSBUaGUgQ1NTIGNsYXNzIGZvciBzaG93biBzdGF0ZSwgZm9yIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NSZWZTaG93bl0gVGhlIENTUyBjbGFzcyBmb3Igc2hvd24gc3RhdGUsIGZvciB0aGUgdHJpZ2dlciBidXR0b24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEJlZm9yZVNob3duXVxuICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgYmVmb3JlIHRoaXMgbWVudSBpcyBzaG93bi5cbiAgICogICBDYW5jZWxsYXRpb24gb2YgdGhpcyBldmVudCBzdG9wcyBoaWRpbmcgdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEFmdGVyU2hvd25dXG4gICAqICAgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCB0ZWxsaW5nIHRoYXQgbWVudSBpcyBzdXJlIHNob3duXG4gICAqICAgd2l0aG91dCBiZWluZyBjYW5jZWxlZCBieSB0aGUgZXZlbnQgaGFuZGxlciBuYW1lZCBieSBgZXZlbnRCZWZvcmVTaG93bmAgb3B0aW9uIChgZmxvYXRpbmctbWVudS1iZWluZ3Nob3duYCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEJlZm9yZUhpZGRlbl1cbiAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIGJlZm9yZSB0aGlzIG1lbnUgaXMgaGlkZGVuLlxuICAgKiAgIENhbmNlbGxhdGlvbiBvZiB0aGlzIGV2ZW50IHN0b3BzIGhpZGluZyB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmV2ZW50QWZ0ZXJIaWRkZW5dXG4gICAqICAgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCB0ZWxsaW5nIHRoYXQgbWVudSBpcyBzdXJlIGhpZGRlblxuICAgKiAgIHdpdGhvdXQgYmVpbmcgY2FuY2VsZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXIgbmFtZWQgYnkgYGV2ZW50QmVmb3JlSGlkZGVuYCBvcHRpb24gKGBmbG9hdGluZy1tZW51LWJlaW5naGlkZGVuYCkuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW29wdGlvbnMucmVmTm9kZV0gVGhlIGxhdW5jaGluZyBlbGVtZW50IG9mIHRoZSBtZW51LiBVc2VkIGZvciBjYWxjdWxhdGluZyB0aGUgZ2VvbWV0cnkgb2YgdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5vZmZzZXRdIFRoZSBvZmZzZXQgdG8gYWRqdXN0IHRoZSBnZW9tZXRyeSBvZiB0aGUgbWVudS4gU2hvdWxkIGhhdmUgYHRvcGAvYGxlZnRgIHByb3BlcnRpZXMuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gRmxvYXRpbmdNZW51KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxvYXRpbmdNZW51KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICB2YXIgYXR0cmliRGlyZWN0aW9uVmFsdWUgPSBfdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkRpcmVjdGlvbik7XG5cbiAgICBpZiAoIV90aGlzLm9wdGlvbnMuZGlyZWN0aW9uKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9IGF0dHJpYkRpcmVjdGlvblZhbHVlIHx8ICdib3R0b20nO1xuICAgIH1cblxuICAgIGlmICghYXR0cmliRGlyZWN0aW9uVmFsdWUpIHtcbiAgICAgIC8vIFVwZGF0ZSBhdHRyaWJ1dGUgZm9yIHN0eWxpbmdcbiAgICAgIF90aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKF90aGlzLm9wdGlvbnMuYXR0cmliRGlyZWN0aW9uLCBfdGhpcy5vcHRpb25zLmRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVLZXlkb3duKGV2ZW50KTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5IHByZXNzIG9uIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgdHJpZ2dlcmluZyBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRmxvYXRpbmdNZW51LCBbe1xuICAgIGtleTogXCJfaGFuZGxlS2V5ZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgICAgdmFyIGtleSA9IGV2ZW50LndoaWNoO1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgdHJpZ2dlck5vZGUgPSBfdGhpcyRvcHRpb25zLnRyaWdnZXJOb2RlLFxuICAgICAgICAgIHJlZk5vZGUgPSBfdGhpcyRvcHRpb25zLnJlZk5vZGU7XG4gICAgICB2YXIgaXNPZk1lbnUgPSB0aGlzLmVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KTtcblxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgLy8gRXNjXG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnaGlkZGVuJywgZ2V0TGF1bmNoaW5nRGV0YWlscyhldmVudCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc09mTWVudSkge1xuICAgICAgICAgICAgICAodHJpZ2dlck5vZGUgfHwgcmVmTm9kZSkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIGJhY2sgb24gdGhlIHRyaWdnZXIgYnV0dG9uIGlmIHRoaXMgY29tcG9uZW50IGxvc2VzIGZvY3VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQmx1clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NTaG93bikpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnaGlkZGVuJywgZ2V0TGF1bmNoaW5nRGV0YWlscyhldmVudCkpO1xuICAgICAgICB2YXIgX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICByZWZOb2RlID0gX3RoaXMkb3B0aW9uczIucmVmTm9kZSxcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlID0gX3RoaXMkb3B0aW9uczIudHJpZ2dlck5vZGU7XG5cbiAgICAgICAgaWYgKChldmVudC5yZWxhdGVkVGFyZ2V0ID09PSBudWxsIHx8IHRoaXMuZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkgJiYgcmVmTm9kZSAmJiBldmVudC50YXJnZXQgIT09IHJlZk5vZGUpIHtcbiAgICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXMuY2FsbCh0cmlnZ2VyTm9kZSB8fCByZWZOb2RlKTsgLy8gU1ZHRWxlbWVudCBpbiBJRTExIGRvZXMgbm90IGhhdmUgYC5mb2N1cygpYCBtZXRob2RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgZWxlbWVudCB0aGF0IHRoaXMgbWVudSBzaG91bGQgYmUgcGxhY2VkIHRvLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbnRhaW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbG9zZXN0KHRoaXMub3B0aW9ucy5zZWxlY3RvckNvbnRhaW5lcikgfHwgdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgbWVudSBwb3NpdGlvbiwgd2l0aCBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQb3MoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zMyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICByZWZOb2RlID0gX3RoaXMkb3B0aW9uczMucmVmTm9kZSxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRvcHRpb25zMy5vZmZzZXQsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX3RoaXMkb3B0aW9uczMuZGlyZWN0aW9uO1xuXG4gICAgICBpZiAoIXJlZk5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCB0aGUgcmVmZXJlbmNlIG5vZGUgZm9yIHBvc2l0aW9uaW5nIGZsb2F0aW5nIG1lbnUuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRGbG9hdGluZ1Bvc2l0aW9uKHtcbiAgICAgICAgbWVudVNpemU6IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHJlZlBvc2l0aW9uOiByZWZOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBvZmZzZXQ6IHR5cGVvZiBvZmZzZXQgIT09ICdmdW5jdGlvbicgPyBvZmZzZXQgOiBvZmZzZXQoZWxlbWVudCwgZGlyZWN0aW9uLCByZWZOb2RlKSxcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgIHNjcm9sbFg6IHJlZk5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWE9mZnNldCxcbiAgICAgICAgc2Nyb2xsWTogcmVmTm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LnBhZ2VZT2Zmc2V0XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlcyBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgd2hhdCB0aGlzIGZsb2F0aW5nIG1lbnUgZXhwZWN0cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Rlc3RTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Rlc3RTdHlsZXMoKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWJ1Z1N0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgIG1hcmdpbjogMFxuICAgICAgfTtcbiAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBleHBlY3RlZCA9IHR5cGVvZiBzdHlsZXNba2V5XSA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHN0eWxlc1trZXldKSA6IHN0eWxlc1trZXldO1xuICAgICAgICB2YXIgYWN0dWFsID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSk7XG5cbiAgICAgICAgaWYgKGV4cGVjdGVkICE9PSBhY3R1YWwpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybihcIkZsb2F0aW5nIG1lbnUgY29tcG9uZW50IGV4cGVjdHMgXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQoc3R5bGVzW2tleV0sIFwiIHN0eWxlLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgdGhlIG1lbnUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2UoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgICAgdmFyIF90aGlzJF9nZXRQb3MgPSB0aGlzLl9nZXRQb3MoKSxcbiAgICAgICAgICBsZWZ0ID0gX3RoaXMkX2dldFBvcy5sZWZ0LFxuICAgICAgICAgIHRvcCA9IF90aGlzJF9nZXRQb3MudG9wO1xuXG4gICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChsZWZ0LCBcInB4XCIpO1xuICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG5cbiAgICAgIHRoaXMuX3Rlc3RTdHlsZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlIFRoZSBuZXcgc3RhdGUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBvZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZ2l2ZW4gbmV3IHN0YXRlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvdWxkU3RhdGVCZUNoYW5nZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkU3RhdGVCZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgIHJldHVybiAoc3RhdGUgPT09ICdzaG93bicgfHwgc3RhdGUgPT09ICdoaWRkZW4nKSAmJiBzdGF0ZSAhPT0gKHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzU2hvd24pID8gJ3Nob3duJyA6ICdoaWRkZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc2hvd24vaGlkZGVuIHN0YXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlIFRoZSBuZXcgc3RhdGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbCBUaGUgZGV0YWlsIG9mIHRoZSBldmVudCB0cmlnZ2luZyB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBjYWxsZWQgd2hlbiBjaGFuZ2UgaW4gc3RhdGUgY29tcGxldGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoYW5nZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGFuZ2VTdGF0ZShzdGF0ZSwgZGV0YWlsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzaG93biA9IHN0YXRlID09PSAnc2hvd24nO1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnM0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHJlZk5vZGUgPSBfdGhpcyRvcHRpb25zNC5yZWZOb2RlLFxuICAgICAgICAgIGNsYXNzU2hvd24gPSBfdGhpcyRvcHRpb25zNC5jbGFzc1Nob3duLFxuICAgICAgICAgIGNsYXNzUmVmU2hvd24gPSBfdGhpcyRvcHRpb25zNC5jbGFzc1JlZlNob3duLFxuICAgICAgICAgIHRyaWdnZXJOb2RlID0gX3RoaXMkb3B0aW9uczQudHJpZ2dlck5vZGU7XG5cbiAgICAgIGlmICghcmVmTm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZmluZCB0aGUgcmVmZXJlbmNlIG5vZGUgZm9yIGNoYW5naW5nIHRoZSBzdHlsZS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSAnc2hvd24nKSB7XG4gICAgICAgIGlmICghdGhpcy5oUmVzaXplKSB7XG4gICAgICAgICAgdGhpcy5oUmVzaXplID0gb3B0aW1pemVkUmVzaXplLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuX3BsYWNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICghc2hvd24pLnRvU3RyaW5nKCkpO1xuICAgICAgKHRyaWdnZXJOb2RlIHx8IHJlZk5vZGUpLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHNob3duLnRvU3RyaW5nKCkpO1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NTaG93biwgc2hvd24pO1xuXG4gICAgICBpZiAoY2xhc3NSZWZTaG93bikge1xuICAgICAgICByZWZOb2RlLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NSZWZTaG93biwgc2hvd24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09ICdzaG93bicpIHtcbiAgICAgICAgdGhpcy5fcGxhY2UoKTsgLy8gSUUxMSBwdXRzIGZvY3VzIG9uIGVsZW1lbnRzIHdpdGggYC5mb2N1cygpYCwgZXZlbiBvbmVzIHdpdGhvdXQgYHRhYmluZGV4YCBhdHRyaWJ1dGVcblxuXG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmliQXZvaWRGb2N1c09uT3BlbikpIHtcbiAgICAgICAgICB2YXIgcHJpbWFyeUZvY3VzTm9kZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvclByaW1hcnlGb2N1cyk7XG4gICAgICAgICAgdmFyIGNvbnRlbnROb2RlID0gdGhpcy5vcHRpb25zLmNvbnRlbnROb2RlIHx8IHRoaXMuZWxlbWVudDtcbiAgICAgICAgICB2YXIgdGFiYmFibGVOb2RlID0gY29udGVudE5vZGUucXVlcnlTZWxlY3RvcihzZXR0aW5ncy5zZWxlY3RvclRhYmJhYmxlKTsgLy8gVGhlIHByb2dyYW1tYXRpY2FsbHkgZm9jdXNhYmxlIGVsZW1lbnQgbWF5IGJlIChhbmQgdHlwaWNhbGx5IHdpbGwgYmUpIHRoZSBjb250ZW50IG5vZGUgaXRzZWxmO1xuXG4gICAgICAgICAgdmFyIGZvY3VzYWJsZU5vZGUgPSBjb250ZW50Tm9kZS5tYXRjaGVzKHNldHRpbmdzLnNlbGVjdG9yRm9jdXNhYmxlKSA/IGNvbnRlbnROb2RlIDogY29udGVudE5vZGUucXVlcnlTZWxlY3RvcihzZXR0aW5ncy5zZWxlY3RvckZvY3VzYWJsZSk7XG5cbiAgICAgICAgICBpZiAocHJpbWFyeUZvY3VzTm9kZSkge1xuICAgICAgICAgICAgLy8gVXNlciBkZWZpbmVkIGZvY3VzYWJsZSBub2RlXG4gICAgICAgICAgICBwcmltYXJ5Rm9jdXNOb2RlLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0YWJiYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHNlcXVlbnRpYWxseSBmb2N1c2FibGUgbm9kZVxuICAgICAgICAgICAgdGFiYmFibGVOb2RlLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb2N1c2FibGVOb2RlKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBwcm9ncmFtbWF0aWMgZm9jdXNhYmxlIG5vZGVcbiAgICAgICAgICAgIGZvY3VzYWJsZU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmb2N1c2FibGVOb2RlID09PSBudWxsLCAnRmxvYXRpbmcgTWVudXMgbXVzdCBoYXZlIGF0IGxlYXN0IGEgcHJvZ3JhbW1hdGljYWxseSBmb2N1c2FibGUgY2hpbGQuICcgKyAnVGhpcyBjYW4gYmUgYWNjb21wbGlzaGVkIGJ5IGFkZGluZyB0YWJpbmRleD1cIi0xXCIgdG8gdGhlIGNvbnRlbnQgZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSAnaGlkZGVuJyAmJiB0aGlzLmhSZXNpemUpIHtcbiAgICAgICAgdGhpcy5oUmVzaXplLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5oUmVzaXplID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICAgaWYgKHRoaXMuaFJlc2l6ZSkge1xuICAgICAgICB0aGlzLmhSZXNpemUucmVsZWFzZSgpO1xuICAgICAgICB0aGlzLmhSZXNpemUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihGbG9hdGluZ01lbnUucHJvdG90eXBlKSwgXCJyZWxlYXNlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgRmxvYXRpbmdNZW51Lm9wdGlvbnMgPSB7XG4gICAgc2VsZWN0b3JDb250YWluZXI6ICdbZGF0YS1mbG9hdGluZy1tZW51LWNvbnRhaW5lcl0nLFxuICAgIHNlbGVjdG9yUHJpbWFyeUZvY3VzOiAnW2RhdGEtZmxvYXRpbmctbWVudS1wcmltYXJ5LWZvY3VzXScsXG4gICAgYXR0cmliRGlyZWN0aW9uOiAnZGF0YS1mbG9hdGluZy1tZW51LWRpcmVjdGlvbicsXG4gICAgYXR0cmliQXZvaWRGb2N1c09uT3BlbjogJ2RhdGEtYXZvaWQtZm9jdXMtb24tb3BlbicsXG4gICAgY2xhc3NTaG93bjogJycsXG4gICAgLy8gU2hvdWxkIGJlIHByb3ZpZGVkIGZyb20gb3B0aW9ucyBhcmcgaW4gY29uc3RydWN0b3JcbiAgICBjbGFzc1JlZlNob3duOiAnJyxcbiAgICAvLyBTaG91bGQgYmUgcHJvdmlkZWQgZnJvbSBvcHRpb25zIGFyZyBpbiBjb25zdHJ1Y3RvclxuICAgIGV2ZW50QmVmb3JlU2hvd246ICdmbG9hdGluZy1tZW51LWJlaW5nc2hvd24nLFxuICAgIGV2ZW50QWZ0ZXJTaG93bjogJ2Zsb2F0aW5nLW1lbnUtc2hvd24nLFxuICAgIGV2ZW50QmVmb3JlSGlkZGVuOiAnZmxvYXRpbmctbWVudS1iZWluZ2hpZGRlbicsXG4gICAgZXZlbnRBZnRlckhpZGRlbjogJ2Zsb2F0aW5nLW1lbnUtaGlkZGVuJyxcbiAgICByZWZOb2RlOiBudWxsLFxuICAgIC8vIFNob3VsZCBiZSBwcm92aWRlZCBmcm9tIG9wdGlvbnMgYXJnIGluIGNvbnN0cnVjdG9yXG4gICAgb2Zmc2V0OiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfVxuICB9O1xuICBGbG9hdGluZ01lbnUuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBGbG9hdGluZ01lbnU7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgZXZlbnRlZFNob3dIaWRlU3RhdGUsIHRyYWNrQmx1ciwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBGbG9hdGluZ01lbnU7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCB0b2dnbGVBdHRyaWJ1dGUgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL3RvZ2dsZS1hdHRyaWJ1dGUnO1xuXG52YXIgSW5saW5lTG9hZGluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhJbmxpbmVMb2FkaW5nLCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSW5saW5lTG9hZGluZyk7XG4gIC8qKlxuICAgKiBTcGlubmVyIGluZGljYXRpbmcgbG9hZGluZyBzdGF0ZS5cbiAgICogQGV4dGVuZHMgQ3JlYXRlQ29tcG9uZW50XG4gICAqIEBleHRlbmRzIEluaXRDb21wb25lbnRCeVNlYXJjaFxuICAgKiBAZXh0ZW5kcyBIYW5kbGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhIHNwaW5uZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5pdGlhbFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZSwgc2hvdWxkIGJlIGBpbmFjdGl2ZWAsIGBhY3RpdmVgIG9yIGBmaW5pc2hlZGAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gSW5saW5lTG9hZGluZyhlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZUxvYWRpbmcpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTsgLy8gU2V0cyB0aGUgaW5pdGlhbCBzdGF0ZVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IF90aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYWN0aXZlL2luYWN0aXZlIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGUgVGhlIG5ldyBzdGF0ZSwgc2hvdWxkIGJlIGBpbmFjdGl2ZWAsIGBhY3RpdmVgIG9yIGBmaW5pc2hlZGAuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKElubGluZUxvYWRpbmcsIFt7XG4gICAga2V5OiBcInNldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICB2YXIgc3RhdGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0ZXM7XG4gICAgICB2YXIgdmFsdWVzID0gT2JqZWN0LmtleXMoc3RhdGVzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gc3RhdGVzW2tleV07XG4gICAgICB9KTtcblxuICAgICAgaWYgKHZhbHVlcy5pbmRleE9mKHN0YXRlKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWUgc2hvdWxkIGJlIGdpdmVuIGFzIHRoZSBzdGF0ZTogXCIuY29uY2F0KHZhbHVlcy5qb2luKCcsICcpKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtID0gdGhpcy5lbGVtZW50O1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgc2VsZWN0b3JTcGlubmVyID0gX3RoaXMkb3B0aW9ucy5zZWxlY3RvclNwaW5uZXIsXG4gICAgICAgICAgc2VsZWN0b3JGaW5pc2hlZCA9IF90aGlzJG9wdGlvbnMuc2VsZWN0b3JGaW5pc2hlZCxcbiAgICAgICAgICBzZWxlY3RvckVycm9yID0gX3RoaXMkb3B0aW9ucy5zZWxlY3RvckVycm9yLFxuICAgICAgICAgIHNlbGVjdG9yVGV4dEFjdGl2ZSA9IF90aGlzJG9wdGlvbnMuc2VsZWN0b3JUZXh0QWN0aXZlLFxuICAgICAgICAgIHNlbGVjdG9yVGV4dEZpbmlzaGVkID0gX3RoaXMkb3B0aW9ucy5zZWxlY3RvclRleHRGaW5pc2hlZCxcbiAgICAgICAgICBzZWxlY3RvclRleHRFcnJvciA9IF90aGlzJG9wdGlvbnMuc2VsZWN0b3JUZXh0RXJyb3I7XG4gICAgICB2YXIgc3Bpbm5lciA9IGVsZW0ucXVlcnlTZWxlY3RvcihzZWxlY3RvclNwaW5uZXIpO1xuICAgICAgdmFyIGZpbmlzaGVkID0gZWxlbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yRmluaXNoZWQpO1xuICAgICAgdmFyIGVycm9yID0gZWxlbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yRXJyb3IpO1xuICAgICAgdmFyIHRleHRBY3RpdmUgPSBlbGVtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JUZXh0QWN0aXZlKTtcbiAgICAgIHZhciB0ZXh0RmluaXNoZWQgPSBlbGVtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JUZXh0RmluaXNoZWQpO1xuICAgICAgdmFyIHRleHRFcnJvciA9IGVsZW0ucXVlcnlTZWxlY3RvcihzZWxlY3RvclRleHRFcnJvcik7XG5cbiAgICAgIGlmIChzcGlubmVyKSB7XG4gICAgICAgIHNwaW5uZXIuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wdGlvbnMuY2xhc3NMb2FkaW5nU3RvcCwgc3RhdGUgIT09IHN0YXRlcy5BQ1RJVkUpO1xuICAgICAgICB0b2dnbGVBdHRyaWJ1dGUoc3Bpbm5lciwgJ2hpZGRlbicsIHN0YXRlICE9PSBzdGF0ZXMuSU5BQ1RJVkUgJiYgc3RhdGUgIT09IHN0YXRlcy5BQ1RJVkUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgdG9nZ2xlQXR0cmlidXRlKGZpbmlzaGVkLCAnaGlkZGVuJywgc3RhdGUgIT09IHN0YXRlcy5GSU5JU0hFRCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0b2dnbGVBdHRyaWJ1dGUoZXJyb3IsICdoaWRkZW4nLCBzdGF0ZSAhPT0gc3RhdGVzLkVSUk9SKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRBY3RpdmUpIHtcbiAgICAgICAgdG9nZ2xlQXR0cmlidXRlKHRleHRBY3RpdmUsICdoaWRkZW4nLCBzdGF0ZSAhPT0gc3RhdGVzLkFDVElWRSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RmluaXNoZWQpIHtcbiAgICAgICAgdG9nZ2xlQXR0cmlidXRlKHRleHRGaW5pc2hlZCwgJ2hpZGRlbicsIHN0YXRlICE9PSBzdGF0ZXMuRklOSVNIRUQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVycm9yKSB7XG4gICAgICAgIHRvZ2dsZUF0dHJpYnV0ZSh0ZXh0RXJyb3IsICdoaWRkZW4nLCBzdGF0ZSAhPT0gc3RhdGVzLkVSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7b2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsIHtAbGlua2NvZGUgSW5saW5lTG9hZGluZy5jcmVhdGUgLmNyZWF0ZSgpfSxcbiAgICAgKiBvciB7QGxpbmtjb2RlIElubGluZUxvYWRpbmcuaW5pdCAuaW5pdCgpfSxcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBvdmVycmlkZW4gZm9yIHRoZSBpbnN0YW5jZSBiZWluZyBjcmVhdGUgYW5kIGhvdyB7QGxpbmtjb2RlIElubGluZUxvYWRpbmcuaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAbWVtYmVyIElubGluZUxvYWRpbmcub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgaW5saW5lIGxvYWRpbmcgY29tcG9uZW50cy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JTcGlubmVyIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgc3Bpbm5lci5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JGaW5pc2hlZCBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIFwiZmluaXNoZWRcIiBpY29uLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckVycm9yIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgXCJlcnJvclwiIGljb24uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9yVGV4dEFjdGl2ZSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHRleHQgZGVzY3JpYmluZyB0aGUgYWN0aXZlIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvclRleHRGaW5pc2hlZCBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHRleHQgZGVzY3JpYmluZyB0aGUgZmluaXNoZWQgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9yVGV4dEVycm9yIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgdGV4dCBkZXNjcmliaW5nIHRoZSBlcnJvciBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY2xhc3NMb2FkaW5nU3RvcCBUaGUgQ1NTIGNsYXNzIGZvciBzcGlubmVyJ3Mgc3RvcHBlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtaW5saW5lLWxvYWRpbmddJyxcbiAgICAgICAgc2VsZWN0b3JTcGlubmVyOiAnW2RhdGEtaW5saW5lLWxvYWRpbmctc3Bpbm5lcl0nLFxuICAgICAgICBzZWxlY3RvckZpbmlzaGVkOiAnW2RhdGEtaW5saW5lLWxvYWRpbmctZmluaXNoZWRdJyxcbiAgICAgICAgc2VsZWN0b3JFcnJvcjogJ1tkYXRhLWlubGluZS1sb2FkaW5nLWVycm9yXScsXG4gICAgICAgIHNlbGVjdG9yVGV4dEFjdGl2ZTogJ1tkYXRhLWlubGluZS1sb2FkaW5nLXRleHQtYWN0aXZlXScsXG4gICAgICAgIHNlbGVjdG9yVGV4dEZpbmlzaGVkOiAnW2RhdGEtaW5saW5lLWxvYWRpbmctdGV4dC1maW5pc2hlZF0nLFxuICAgICAgICBzZWxlY3RvclRleHRFcnJvcjogJ1tkYXRhLWlubGluZS1sb2FkaW5nLXRleHQtZXJyb3JdJyxcbiAgICAgICAgY2xhc3NMb2FkaW5nU3RvcDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tbG9hZGluZy0tc3RvcFwiKVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBJbmxpbmVMb2FkaW5nLnN0YXRlcyA9IHtcbiAgICBJTkFDVElWRTogJ2luYWN0aXZlJyxcbiAgICBBQ1RJVkU6ICdhY3RpdmUnLFxuICAgIEZJTklTSEVEOiAnZmluaXNoZWQnLFxuICAgIEVSUk9SOiAnZXJyb3InXG4gIH07XG4gIElubGluZUxvYWRpbmcuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBJbmxpbmVMb2FkaW5nO1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeVNlYXJjaCwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBJbmxpbmVMb2FkaW5nOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIExvYWRpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoTG9hZGluZywgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKExvYWRpbmcpO1xuICAvKipcbiAgICogU3Bpbm5lciBpbmRpY2F0aW5nIGxvYWRpbmcgc3RhdGUuXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYSBzcGlubmVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hY3RpdmVdIGB0cnVlYCBpZiB0aGlzIHNwaW5uZXIgc2hvdWxkIHJvbGwuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gTG9hZGluZyhlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRpbmcpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcbiAgICBfdGhpcy5hY3RpdmUgPSBfdGhpcy5vcHRpb25zLmFjdGl2ZTsgLy8gSW5pdGlhbGl6ZSBzcGlubmVyXG5cbiAgICBfdGhpcy5zZXQoX3RoaXMuYWN0aXZlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyBhY3RpdmUvaW5hY3RpdmUgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlIGB0cnVlYCBpZiB0aGlzIHNwaW5uZXIgc2hvdWxkIHJvbGwuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExvYWRpbmcsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoYWN0aXZlKSB7XG4gICAgICBpZiAodHlwZW9mIGFjdGl2ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NldCBleHBlY3RzIGEgYm9vbGVhbi4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wdGlvbnMuY2xhc3NMb2FkaW5nU3RvcCwgIXRoaXMuYWN0aXZlKTtcbiAgICAgIC8qKlxuICAgICAgICogSWYgb3ZlcmxheSBpcyB0aGUgcGFyZW50Tm9kZSB0aGVuIHRvZ2dsZSBpdCB0b28uXG4gICAgICAgKi9cblxuICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzTG9hZGluZ092ZXJsYXkpKSB7XG4gICAgICAgIHBhcmVudE5vZGUuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wdGlvbnMuY2xhc3NMb2FkaW5nT3ZlcmxheVN0b3AsICF0aGlzLmFjdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFjdGl2ZS9pbmFjdGl2ZSBzdGF0ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoIXRoaXMuYWN0aXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGlzIHNwaW5uZXIgaXMgcm9sbGluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQWN0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHN0YXRlIHRvIGluYWN0aXZlIGFuZCBkZWxldGVzIHRoZSBsb2FkaW5nIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2V0KGZhbHNlKTtcbiAgICAgIHZhciBoYW5kbGVBbmltYXRpb25FbmQgPSB0aGlzLm1hbmFnZShvbih0aGlzLmVsZW1lbnQsICdhbmltYXRpb25lbmQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChoYW5kbGVBbmltYXRpb25FbmQpIHtcbiAgICAgICAgICBoYW5kbGVBbmltYXRpb25FbmQgPSBfdGhpczIudW5tYW5hZ2UoaGFuZGxlQW5pbWF0aW9uRW5kKS5yZWxlYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZ0LmFuaW1hdGlvbk5hbWUgPT09ICdyb3RhdGUtZW5kLXAyJykge1xuICAgICAgICAgIF90aGlzMi5fZGVsZXRlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlbGV0ZUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZUVsZW1lbnQoKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICBpZiAocGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLnNlbGVjdG9yTG9hZGluZ092ZXJsYXkpKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIHNwaW5uZXIgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlciBMb2FkaW5nLmNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsIHtAbGlua2NvZGUgTG9hZGluZy5jcmVhdGUgLmNyZWF0ZSgpfSwgb3Ige0BsaW5rY29kZSBMb2FkaW5nLmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlIGFuZCBob3cge0BsaW5rY29kZSBMb2FkaW5nLmluaXQgLmluaXQoKX0gd29ya3MuXG4gICAgICogQG1lbWJlciBMb2FkaW5nLm9wdGlvbnNcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHNwaW5uZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS1sb2FkaW5nXScsXG4gICAgICAgIHNlbGVjdG9yTG9hZGluZ092ZXJsYXk6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1sb2FkaW5nLW92ZXJsYXlcIiksXG4gICAgICAgIGNsYXNzTG9hZGluZ092ZXJsYXk6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWxvYWRpbmctb3ZlcmxheVwiKSxcbiAgICAgICAgY2xhc3NMb2FkaW5nU3RvcDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tbG9hZGluZy0tc3RvcFwiKSxcbiAgICAgICAgY2xhc3NMb2FkaW5nT3ZlcmxheVN0b3A6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWxvYWRpbmctb3ZlcmxheS0tc3RvcFwiKSxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIExvYWRpbmcuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBMb2FkaW5nO1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeVNlYXJjaCwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBMb2FkaW5nOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5TGF1bmNoZXIgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktbGF1bmNoZXInO1xuaW1wb3J0IGV2ZW50ZWRTaG93SGlkZVN0YXRlIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2V2ZW50ZWQtc2hvdy1oaWRlLXN0YXRlJztcbmltcG9ydCBoYW5kbGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2hhbmRsZXMnO1xuaW1wb3J0IGV2ZW50TWF0Y2hlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZXZlbnQtbWF0Y2hlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIE1vZGFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKE1vZGFsLCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTW9kYWwpO1xuICAvKipcbiAgICogTW9kYWwgZGlhbG9nLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5TGF1bmNoZXJcbiAgICogQGV4dGVuZHMgRXZlbnRlZFNob3dIaWRlU3RhdGVcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYSBtb2RhbCBkaWFsb2cuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NWaXNpYmxlXSBUaGUgQ1NTIGNsYXNzIGZvciB0aGUgdmlzaWJsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzQm9keV0gVGhlIENTUyBjbGFzcyBmb3IgYDxib2R5PmAgd2l0aCBvcGVuIG1vZGFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZXZlbnRCZWZvcmVTaG93bl1cbiAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIGJlZm9yZSB0aGlzIG1vZGFsIGlzIHNob3duLlxuICAgKiAgIENhbmNlbGxhdGlvbiBvZiB0aGlzIGV2ZW50IHN0b3BzIHNob3dpbmcgdGhlIG1vZGFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZXZlbnRBZnRlclNob3duXVxuICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgdGVsbGluZyB0aGF0IG1vZGFsIGlzIHN1cmUgc2hvd25cbiAgICogICB3aXRob3V0IGJlaW5nIGNhbmNlbGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyIG5hbWVkIGJ5IGBldmVudEJlZm9yZVNob3duYCBvcHRpb24gKGBtb2RhbC1iZWluZ3Nob3duYCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEJlZm9yZUhpZGRlbl1cbiAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIGJlZm9yZSB0aGlzIG1vZGFsIGlzIGhpZGRlbi5cbiAgICogICBDYW5jZWxsYXRpb24gb2YgdGhpcyBldmVudCBzdG9wcyBoaWRpbmcgdGhlIG1vZGFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZXZlbnRBZnRlckhpZGRlbl1cbiAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IHRlbGxpbmcgdGhhdCBtb2RhbCBpcyBzdXJlIGhpZGRlblxuICAgKiAgIHdpdGhvdXQgYmVpbmcgY2FuY2VsZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXIgbmFtZWQgYnkgYGV2ZW50QmVmb3JlSGlkZGVuYCBvcHRpb24gKGBtb2RhbC1iZWluZ2hpZGRlbmApLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIE1vZGFsKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWwpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcbiAgICBfdGhpcy5faGFuZGxlRm9jdXNpbkxpc3RlbmVyID0gdm9pZCAwO1xuICAgIF90aGlzLl9oYW5kbGVLZXlkb3duTGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgICBfdGhpcy5faGFuZGxlRm9jdXNpbiA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHZhciBmb2N1c1dyYXBOb2RlID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JNb2RhbENvbnRhaW5lcikgfHwgX3RoaXMuZWxlbWVudDtcblxuICAgICAgaWYgKF90aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKF90aGlzLm9wdGlvbnMuY2xhc3NWaXNpYmxlKSAmJiAhZm9jdXNXcmFwTm9kZS5jb250YWlucyhldnQudGFyZ2V0KSAmJiBfdGhpcy5vcHRpb25zLnNlbGVjdG9yc0Zsb2F0aW5nTWVudXMuZXZlcnkoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiAhZXZlbnRNYXRjaGVzKGV2dCwgc2VsZWN0b3IpO1xuICAgICAgfSkpIHtcbiAgICAgICAgX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNldHRpbmdzLnNlbGVjdG9yVGFiYmFibGUpLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLl9ob29rQ2xvc2VBY3Rpb25zKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBoYW5kbGUgZm9yIGBmb2N1c2luYCBldmVudCBsaXN0ZW5lci5cbiAgICogVXNlZCBmb3IgXCJmb2N1cy13cmFwXCIgZmVhdHVyZS5cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTW9kYWwsIFt7XG4gICAga2V5OiBcImNyZWF0ZWRCeUxhdW5jaGVyXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdGhhdCBydW5zIHdoZW4gYC5pbml0KClgIGlzIGNhbGxlZCBmcm9tIGBpbml0Q29tcG9uZW50QnlMYXVuY2hlcmAuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZ0IFRoZSBldmVudCBmaXJlZCBvbiB0aGUgbGF1bmNoZXIgYnV0dG9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZWRCeUxhdW5jaGVyKGV2dCkge1xuICAgICAgdGhpcy5zaG93KGV2dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZW1pdCBldmVudHMgYW5kIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYC5jaGFuZ2VTdGF0ZSgpYCBpcyBjYWxsZWQgZnJvbSBgZXZlbnRlZFN0YXRlYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGUgVGhlIG5ldyBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnaXZlbiBgc3RhdGVgIGlzIGRpZmZlcmVudCBmcm9tIGN1cnJlbnQgc3RhdGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG91bGRTdGF0ZUJlQ2hhbmdlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRTdGF0ZUJlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlID09PSAnc2hvd24nKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NWaXNpYmxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzVmlzaWJsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNob3duL2hpZGRlbiBzdGF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZSBUaGUgbmV3IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWwgVGhlIGRldGFpbCBkYXRhIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBldmVudCB0aGF0IHdpbGwgYmUgZmlyZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgY2FsbGVkIHdoZW4gY2hhbmdlIGluIHN0YXRlIGNvbXBsZXRlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGFuZ2VTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hhbmdlU3RhdGUoc3RhdGUsIGRldGFpbCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgaGFuZGxlVHJhbnNpdGlvbkVuZDtcblxuICAgICAgdmFyIHRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xuICAgICAgICBpZiAoaGFuZGxlVHJhbnNpdGlvbkVuZCkge1xuICAgICAgICAgIGhhbmRsZVRyYW5zaXRpb25FbmQgPSBfdGhpczIudW5tYW5hZ2UoaGFuZGxlVHJhbnNpdGlvbkVuZCkucmVsZWFzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSAnc2hvd24nICYmIF90aGlzMi5lbGVtZW50Lm9mZnNldFdpZHRoID4gMCAmJiBfdGhpczIuZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgX3RoaXMyLnByZXZpb3VzbHlGb2N1c2VkTm9kZSA9IF90aGlzMi5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIHZhciBmb2N1c2FibGVJdGVtID0gX3RoaXMyLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpczIub3B0aW9ucy5zZWxlY3RvclByaW1hcnlGb2N1cykgfHwgX3RoaXMyLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZXR0aW5ncy5zZWxlY3RvclRhYmJhYmxlKTtcblxuICAgICAgICAgIGZvY3VzYWJsZUl0ZW0uZm9jdXMoKTtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZm9jdXNhYmxlSXRlbSwgXCJNb2RhbHMgbmVlZCB0byBjb250YWluIGEgZm9jdXNhYmxlIGVsZW1lbnQgYnkgZWl0aGVyIHVzaW5nIFwiICsgXCJgXCIuY29uY2F0KF90aGlzMi5vcHRpb25zLnNlbGVjdG9yUHJpbWFyeUZvY3VzLCBcImAgb3Igc2V0dGluZ3Muc2VsZWN0b3JUYWJiYWJsZS5cIikpIDogdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5faGFuZGxlRm9jdXNpbkxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUZvY3VzaW5MaXN0ZW5lciA9IHRoaXMudW5tYW5hZ2UodGhpcy5faGFuZGxlRm9jdXNpbkxpc3RlbmVyKS5yZWxlYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gJ3Nob3duJykge1xuICAgICAgICB2YXIgaGFzRm9jdXNpbiA9ICgnb25mb2N1c2luJyBpbiB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgICAgIHZhciBmb2N1c2luRXZlbnROYW1lID0gaGFzRm9jdXNpbiA/ICdmb2N1c2luJyA6ICdmb2N1cyc7XG4gICAgICAgIHRoaXMuX2hhbmRsZUZvY3VzaW5MaXN0ZW5lciA9IHRoaXMubWFuYWdlKG9uKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LCBmb2N1c2luRXZlbnROYW1lLCB0aGlzLl9oYW5kbGVGb2N1c2luLCAhaGFzRm9jdXNpbikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMub3B0aW9ucy5jbGFzc1Zpc2libGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keS5jbGFzc0xpc3QudG9nZ2xlKHRoaXMub3B0aW9ucy5jbGFzc0JvZHksIGZhbHNlKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdG9yRm9jdXNPbkNsb3NlIHx8IHRoaXMucHJldmlvdXNseUZvY3VzZWROb2RlKSB7XG4gICAgICAgICAgKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yRm9jdXNPbkNsb3NlKSB8fCB0aGlzLnByZXZpb3VzbHlGb2N1c2VkTm9kZSkuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ3Nob3duJykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wdGlvbnMuY2xhc3NWaXNpYmxlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keS5jbGFzc0xpc3QudG9nZ2xlKHRoaXMub3B0aW9ucy5jbGFzc0JvZHksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVUcmFuc2l0aW9uRW5kID0gdGhpcy5tYW5hZ2Uob24odGhpcy5lbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIHRyYW5zaXRpb25FbmQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hvb2tDbG9zZUFjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hvb2tDbG9zZUFjdGlvbnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5tYW5hZ2Uob24odGhpcy5lbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciBjbG9zZUJ1dHRvbiA9IGV2ZW50TWF0Y2hlcyhldnQsIF90aGlzMy5vcHRpb25zLnNlbGVjdG9yTW9kYWxDbG9zZSk7XG5cbiAgICAgICAgaWYgKGNsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgZXZ0LmRlbGVnYXRlVGFyZ2V0ID0gY2xvc2VCdXR0b247IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZUJ1dHRvbiB8fCBldnQudGFyZ2V0ID09PSBfdGhpczMuZWxlbWVudCkge1xuICAgICAgICAgIF90aGlzMy5oaWRlKGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgaWYgKHRoaXMuX2hhbmRsZUtleWRvd25MaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9oYW5kbGVLZXlkb3duTGlzdGVuZXIgPSB0aGlzLnVubWFuYWdlKHRoaXMuX2hhbmRsZUtleWRvd25MaXN0ZW5lcikucmVsZWFzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9oYW5kbGVLZXlkb3duTGlzdGVuZXIgPSB0aGlzLm1hbmFnZShvbih0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5LCAna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgLy8gQXZvaWQgcnVubmluZyBgZXZ0LnN0b3BQcm9wYWdhdGlvbigpYCBvbmx5IHdoZW4gbW9kYWwgaXMgc2hvd25cbiAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gMjcgJiYgX3RoaXMzLnNob3VsZFN0YXRlQmVDaGFuZ2VkKCdoaWRkZW4nKSkge1xuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgIF90aGlzMy5oaWRlKGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBgZm9jdXNpbmAgKG9yIGBmb2N1c2AgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydCBvZiBgZm9jdXNpbmApIGV2ZW50IHRvIGRvIHdyYXAtZm9jdXMgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZ0IFRoZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvciwge0BsaW5rY29kZSBNb2RhbC5jcmVhdGUgLmNyZWF0ZSgpfSwgb3Ige0BsaW5rY29kZSBNb2RhbC5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZSBhbmQgaG93IHtAbGlua2NvZGUgTW9kYWwuaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAbWVtYmVyIE1vZGFsLm9wdGlvbnNcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIENTUyBjbGFzcyB0byBmaW5kIG1vZGFsIGRpYWxvZ3MuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3Rvck1vZGFsQ2xvc2VdIFRoZSBzZWxlY3RvciB0byBmaW5kIGVsZW1lbnRzIHRoYXQgY2xvc2UgdGhlIG1vZGFsLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JQcmltYXJ5Rm9jdXNdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZGV0ZXJtaW5lIHRoZSBlbGVtZW50IHRvIHB1dCBmb2N1cyB3aGVuIG1vZGFsIGdldHMgb3Blbi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yRm9jdXNPbkNsb3NlXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGRldGVybWluZSB0aGUgZWxlbWVudCB0byBwdXQgZm9jdXMgd2hlbiBtb2RhbCBjbG9zZXMuXG4gICAgICogICBJZiB1bmRlZmluZWQsIGZvY3VzIHJldHVybnMgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IHByaW9yIHRvIHRoZSBtb2RhbCBvcGVuaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JNb2RhbENvbnRhaW5lcl0gVGhlIENTUyBzZWxlY3RvciBmb3IgdGhlIGNvbnRlbnQgY29udGFpbmVyIG9mIHRoZSBtb2RhbCBmb3IgZm9jdXMgd3JhcCBmZWF0dXJlLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyaWJJbml0VGFyZ2V0IFRoZSBhdHRyaWJ1dGUgbmFtZSBpbiB0aGUgbGF1bmNoZXIgYnV0dG9ucyB0byBmaW5kIHRhcmdldCBtb2RhbCBkaWFsb2dzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtzZWxlY3RvcnNGbG9hdGluZ01lbnVdXG4gICAgICogICBUaGUgQ1NTIHNlbGVjdG9ycyBvZiBmbG9hdGluZyBtZW51cy5cbiAgICAgKiAgIFVzZWQgZm9yIGRldGVjdGluZyBpZiBmb2N1cy13cmFwIGJlaGF2aW9yIHNob3VsZCBiZSBkaXNhYmxlZCB0ZW1wb3JhcmlseS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzVmlzaWJsZV0gVGhlIENTUyBjbGFzcyBmb3IgdGhlIHZpc2libGUgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc0JvZHldIFRoZSBDU1MgY2xhc3MgZm9yIGA8Ym9keT5gIHdpdGggb3BlbiBtb2RhbC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTm9TY3JvbGxdIFRoZSBDU1MgY2xhc3MgZm9yIGhpZGluZyBzY3JvbGwgYmFyIGluIGJvZHkgZWxlbWVudCB3aGlsZSBtb2RhbCBpcyBzaG93bi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50QmVmb3JlU2hvd25dXG4gICAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIGJlZm9yZSB0aGlzIG1vZGFsIGlzIHNob3duLlxuICAgICAqICAgQ2FuY2VsbGF0aW9uIG9mIHRoaXMgZXZlbnQgc3RvcHMgc2hvd2luZyB0aGUgbW9kYWwuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtldmVudEFmdGVyU2hvd25dXG4gICAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IHRlbGxpbmcgdGhhdCBtb2RhbCBpcyBzdXJlIHNob3duXG4gICAgICogICB3aXRob3V0IGJlaW5nIGNhbmNlbGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyIG5hbWVkIGJ5IGBldmVudEJlZm9yZVNob3duYCBvcHRpb24gKGBtb2RhbC1iZWluZ3Nob3duYCkuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtldmVudEJlZm9yZUhpZGRlbl1cbiAgICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgYmVmb3JlIHRoaXMgbW9kYWwgaXMgaGlkZGVuLlxuICAgICAqICAgQ2FuY2VsbGF0aW9uIG9mIHRoaXMgZXZlbnQgc3RvcHMgaGlkaW5nIHRoZSBtb2RhbC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50QWZ0ZXJIaWRkZW5dXG4gICAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IHRlbGxpbmcgdGhhdCBtb2RhbCBpcyBzdXJlIGhpZGRlblxuICAgICAqICAgd2l0aG91dCBiZWluZyBjYW5jZWxlZCBieSB0aGUgZXZlbnQgaGFuZGxlciBuYW1lZCBieSBgZXZlbnRCZWZvcmVIaWRkZW5gIG9wdGlvbiAoYG1vZGFsLWJlaW5naGlkZGVuYCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLW1vZGFsXScsXG4gICAgICAgIHNlbGVjdG9yTW9kYWxDbG9zZTogJ1tkYXRhLW1vZGFsLWNsb3NlXScsXG4gICAgICAgIHNlbGVjdG9yUHJpbWFyeUZvY3VzOiAnW2RhdGEtbW9kYWwtcHJpbWFyeS1mb2N1c10nLFxuICAgICAgICBzZWxlY3RvcnNGbG9hdGluZ01lbnVzOiBbXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLW92ZXJmbG93LW1lbnUtb3B0aW9uc1wiKSwgXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXRvb2x0aXBcIiksICcuZmxhdHBpY2tyLWNhbGVuZGFyJ10sXG4gICAgICAgIHNlbGVjdG9yTW9kYWxDb250YWluZXI6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1tb2RhbC1jb250YWluZXJcIiksXG4gICAgICAgIGNsYXNzVmlzaWJsZTogJ2lzLXZpc2libGUnLFxuICAgICAgICBjbGFzc0JvZHk6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWJvZHktLXdpdGgtbW9kYWwtb3BlblwiKSxcbiAgICAgICAgYXR0cmliSW5pdFRhcmdldDogJ2RhdGEtbW9kYWwtdGFyZ2V0JyxcbiAgICAgICAgaW5pdEV2ZW50TmFtZXM6IFsnY2xpY2snXSxcbiAgICAgICAgZXZlbnRCZWZvcmVTaG93bjogJ21vZGFsLWJlaW5nc2hvd24nLFxuICAgICAgICBldmVudEFmdGVyU2hvd246ICdtb2RhbC1zaG93bicsXG4gICAgICAgIGV2ZW50QmVmb3JlSGlkZGVuOiAnbW9kYWwtYmVpbmdoaWRkZW4nLFxuICAgICAgICBldmVudEFmdGVySGlkZGVuOiAnbW9kYWwtaGlkZGVuJ1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBNb2RhbC5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIE1vZGFsO1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeUxhdW5jaGVyLCBldmVudGVkU2hvd0hpZGVTdGF0ZSwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBNb2RhbDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBldmVudGVkU3RhdGUgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvZXZlbnRlZC1zdGF0ZSc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBvbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2Mvb24nO1xuXG52YXIgTm90aWZpY2F0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKE5vdGlmaWNhdGlvbiwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vdGlmaWNhdGlvbik7XG4gIC8qKlxuICAgKiBJbmxpbmVOb3RpZmljYXRpb24uXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYSBJbmxpbmVOb3RpZmljYXRpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gTm90aWZpY2F0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm90aWZpY2F0aW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoc3RhdGUgPT09ICdkZWxldGUtbm90aWZpY2F0aW9uJykge1xuICAgICAgICBfdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3RoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgX3RoaXMucmVsZWFzZSgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBfdGhpcy5idXR0b24gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckJ1dHRvbik7XG5cbiAgICBpZiAoX3RoaXMuYnV0dG9uKSB7XG4gICAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQuY3VycmVudFRhcmdldCA9PT0gX3RoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgX3RoaXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm90aWZpY2F0aW9uLCBbe1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnZGVsZXRlLW5vdGlmaWNhdGlvbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBhY2NvcmRpb24gVUkgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge1dlYWtNYXB9XG4gICAgICovXG5cbiAgfV0pO1xuXG4gIE5vdGlmaWNhdGlvbi5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgTm90aWZpY2F0aW9uLm9wdGlvbnMgPSB7XG4gICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtbm90aWZpY2F0aW9uXScsXG4gICAgc2VsZWN0b3JCdXR0b246ICdbZGF0YS1ub3RpZmljYXRpb24tYnRuXScsXG4gICAgZXZlbnRCZWZvcmVEZWxldGVOb3RpZmljYXRpb246ICdub3RpZmljYXRpb24tYmVmb3JlLWRlbGV0ZScsXG4gICAgZXZlbnRBZnRlckRlbGV0ZU5vdGlmaWNhdGlvbjogJ25vdGlmaWNhdGlvbi1hZnRlci1kZWxldGUnXG4gIH07XG4gIHJldHVybiBOb3RpZmljYXRpb247XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBldmVudGVkU3RhdGUsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgTm90aWZpY2F0aW9uOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIE51bWJlcklucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKE51bWJlcklucHV0LCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTnVtYmVySW5wdXQpO1xuICAvKipcbiAgICogTnVtYmVyIGlucHV0IFVJLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGEgbnVtYmVyIGlucHV0IFVJLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIE51bWJlcklucHV0KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVySW5wdXQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTsgLy8gQnJva2VuIERPTSB0cmVlIGlzIHNlZW4gd2l0aCB1cC9kb3duIGFycm93cyA8c3ZnPiBpbiBJRSwgd2hpY2ggYnJlYWtzIGV2ZW50IGRlbGVnYXRpb24uXG4gICAgLy8gPHN2Zz4gZG9lcyBub3QgaGF2ZSBgRWxlbWVudC5jbGFzc0xpc3RgIGluIElFMTFcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy51cC1pY29uJyksICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMuX2hhbmRsZUNsaWNrKGV2ZW50KTtcbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG93bi1pY29uJyksICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMuX2hhbmRsZUNsaWNrKGV2ZW50KTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluY3JlYXNlL2RlY3JlYXNlIG51bWJlciBieSBjbGlja2luZyBvbiB1cC9kb3duIGljb25zLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdHJpZ2dlcmluZyB0aGlzIG1ldGhvZC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTnVtYmVySW5wdXQsIFt7XG4gICAga2V5OiBcIl9oYW5kbGVDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgIHZhciBudW1iZXJJbnB1dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvcklucHV0KTtcbiAgICAgIHZhciB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5zcGxpdCgnICcpO1xuICAgICAgdmFyIG1pbiA9IE51bWJlcihudW1iZXJJbnB1dC5taW4pO1xuICAgICAgdmFyIG1heCA9IE51bWJlcihudW1iZXJJbnB1dC5tYXgpO1xuICAgICAgdmFyIHN0ZXAgPSBOdW1iZXIobnVtYmVySW5wdXQuc3RlcCkgfHwgMTtcblxuICAgICAgaWYgKHRhcmdldC5pbmRleE9mKCd1cC1pY29uJykgPj0gMCkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gTnVtYmVyKG51bWJlcklucHV0LnZhbHVlKSArIHN0ZXA7XG5cbiAgICAgICAgaWYgKG51bWJlcklucHV0Lm1heCA9PT0gJycpIHtcbiAgICAgICAgICBudW1iZXJJbnB1dC52YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXJJbnB1dC52YWx1ZSA8IG1heCkge1xuICAgICAgICAgIGlmIChuZXh0VmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG51bWJlcklucHV0LnZhbHVlID0gbWF4O1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICBudW1iZXJJbnB1dC52YWx1ZSA9IG1pbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnVtYmVySW5wdXQudmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5pbmRleE9mKCdkb3duLWljb24nKSA+PSAwKSB7XG4gICAgICAgIHZhciBfbmV4dFZhbHVlID0gTnVtYmVyKG51bWJlcklucHV0LnZhbHVlKSAtIHN0ZXA7XG5cbiAgICAgICAgaWYgKG51bWJlcklucHV0Lm1pbiA9PT0gJycpIHtcbiAgICAgICAgICBudW1iZXJJbnB1dC52YWx1ZSA9IF9uZXh0VmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVySW5wdXQudmFsdWUgPiBtaW4pIHtcbiAgICAgICAgICBpZiAoX25leHRWYWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgbnVtYmVySW5wdXQudmFsdWUgPSBtaW47XG4gICAgICAgICAgfSBlbHNlIGlmIChfbmV4dFZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBudW1iZXJJbnB1dC52YWx1ZSA9IG1heDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnVtYmVySW5wdXQudmFsdWUgPSBfbmV4dFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBQcm9ncmFtbWF0aWMgY2hhbmdlIGluIHZhbHVlIChpbmNsdWRpbmcgYHN0ZXBVcCgpYC9gc3RlcERvd24oKWApIHdvbid0IGZpcmUgY2hhbmdlIGV2ZW50XG5cblxuICAgICAgbnVtYmVySW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZScsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBhc3NvY2lhdGluZyBET00gZWxlbWVudCBhbmQgbnVtYmVyIGlucHV0IFVJIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXIgTnVtYmVySW5wdXQuY29tcG9uZW50c1xuICAgICAqIEB0eXBlIHtXZWFrTWFwfVxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgKiB7QGxpbmtjb2RlIE51bWJlcklucHV0LmNyZWF0ZSAuY3JlYXRlKCl9LCBvciB7QGxpbmtjb2RlIE51bWJlcklucHV0LmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlIGFuZCBob3cge0BsaW5rY29kZSBOdW1iZXJJbnB1dC5pbml0IC5pbml0KCl9IHdvcmtzLlxuICAgICAqIEBtZW1iZXIgTnVtYmVySW5wdXQub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgbnVtYmVyIGlucHV0IFVJcy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9ySW5wdXRdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgYDxpbnB1dD5gIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLW51bWJlcmlucHV0XScsXG4gICAgICAgIHNlbGVjdG9ySW5wdXQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1udW1iZXIgaW5wdXRcIilcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgTnVtYmVySW5wdXQuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBOdW1iZXJJbnB1dDtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgTnVtYmVySW5wdXQ7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgZXZlbnRNYXRjaGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9ldmVudC1tYXRjaGVzJztcbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBldmVudGVkU2hvd0hpZGVTdGF0ZSBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9ldmVudGVkLXNob3ctaGlkZS1zdGF0ZSc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBGbG9hdGluZ01lbnUsIHsgRElSRUNUSU9OX1RPUCwgRElSRUNUSU9OX0JPVFRPTSwgRElSRUNUSU9OX0xFRlQsIERJUkVDVElPTl9SSUdIVCB9IGZyb20gJy4uL2Zsb2F0aW5nLW1lbnUvZmxvYXRpbmctbWVudSc7XG5pbXBvcnQgZ2V0TGF1bmNoaW5nRGV0YWlscyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZ2V0LWxhdW5jaGluZy1kZXRhaWxzJztcbmltcG9ydCBvbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2Mvb24nO1xuLyoqXG4gKiBUaGUgQ1NTIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJvdyBrZXllZCBieSB0aGUgZmxvYXRpbmcgbWVudSBkaXJlY3Rpb24uXG4gKiBAdHlwZSB7b2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xuXG52YXIgdHJpZ2dlckJ1dHRvblBvc2l0aW9uUHJvcHMgPSAvKiAjX19QVVJFX18gKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiBfcmVmID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCBESVJFQ1RJT05fVE9QLCAnYm90dG9tJyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCBESVJFQ1RJT05fQk9UVE9NLCAndG9wJyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCBESVJFQ1RJT05fTEVGVCwgJ2xlZnQnKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIERJUkVDVElPTl9SSUdIVCwgJ3JpZ2h0JyksIF9yZWY7XG59KCk7XG4vKipcbiAqIERldGVybWluZXMgaG93IHRoZSBwb3NpdGlvbiBvZiBhcnJvdyBzaG91bGQgYWZmZWN0IHRoZSBmbG9hdGluZyBtZW51IHBvc2l0aW9uLlxuICogQHR5cGUge29iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gKi9cblxuXG52YXIgdHJpZ2dlckJ1dHRvblBvc2l0aW9uRmFjdG9ycyA9IC8qICNfX1BVUkVfXyAqL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIHJldHVybiBfcmVmMiA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX3JlZjIsIERJUkVDVElPTl9UT1AsIC0yKSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCBESVJFQ1RJT05fQk9UVE9NLCAtMSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgRElSRUNUSU9OX0xFRlQsIC0yKSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCBESVJFQ1RJT05fUklHSFQsIC0xKSwgX3JlZjI7XG59KCk7XG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbWVudUJvZHkgVGhlIG1lbnUgYm9keSB3aXRoIHRoZSBtZW51IGFycm93LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBUaGUgZmxvYXRpbmcgbWVudSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRyaWdnZXIgVGhlIHRyaWdnZXIgYnV0dG9uLlxuICogQHJldHVybnMge0Zsb2F0aW5nTWVudX5vZmZzZXR9IFRoZSBhZGp1c3RtZW50IG9mIHRoZSBmbG9hdGluZyBtZW51IHBvc2l0aW9uLCB1cG9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWVudSBhcnJvdy5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5leHBvcnQgdmFyIGdldE1lbnVPZmZzZXQgPSBmdW5jdGlvbiBnZXRNZW51T2Zmc2V0KG1lbnVCb2R5LCBkaXJlY3Rpb24sIHRyaWdnZXIpIHtcbiAgdmFyIHRyaWdnZXJCdXR0b25Qb3NpdGlvblByb3AgPSB0cmlnZ2VyQnV0dG9uUG9zaXRpb25Qcm9wc1tkaXJlY3Rpb25dO1xuICB2YXIgdHJpZ2dlckJ1dHRvblBvc2l0aW9uRmFjdG9yID0gdHJpZ2dlckJ1dHRvblBvc2l0aW9uRmFjdG9yc1tkaXJlY3Rpb25dO1xuXG4gIGlmICghdHJpZ2dlckJ1dHRvblBvc2l0aW9uUHJvcCB8fCAhdHJpZ2dlckJ1dHRvblBvc2l0aW9uRmFjdG9yKSB7XG4gICAgY29uc29sZS53YXJuKCdXcm9uZyBmbG9hdGluZyBtZW51IGRpcmVjdGlvbjonLCBkaXJlY3Rpb24pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfVxuXG4gIHZhciBtZW51V2lkdGggPSBtZW51Qm9keS5vZmZzZXRXaWR0aDtcbiAgdmFyIG1lbnVIZWlnaHQgPSBtZW51Qm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuXG4gIHZhciBtZW51ID0gT3ZlcmZsb3dNZW51LmNvbXBvbmVudHMuZ2V0KHRyaWdnZXIpO1xuXG4gIGlmICghbWVudSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ092ZXJmbG93IG1lbnUgaW5zdGFuY2UgY2Fubm90IGJlIGZvdW5kLicpO1xuICB9XG5cbiAgdmFyIGZsaXAgPSBtZW51Qm9keS5jbGFzc0xpc3QuY29udGFpbnMobWVudS5vcHRpb25zLmNsYXNzTWVudUZsaXApO1xuXG4gIGlmICh0cmlnZ2VyQnV0dG9uUG9zaXRpb25Qcm9wID09PSAndG9wJyB8fCB0cmlnZ2VyQnV0dG9uUG9zaXRpb25Qcm9wID09PSAnYm90dG9tJykge1xuICAgIHZhciB0cmlnZ2VyV2lkdGggPSB0cmlnZ2VyLm9mZnNldFdpZHRoO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAoIWZsaXAgPyAxIDogLTEpICogKG1lbnVXaWR0aCAvIDIgLSB0cmlnZ2VyV2lkdGggLyAyKSxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gIH1cblxuICBpZiAodHJpZ2dlckJ1dHRvblBvc2l0aW9uUHJvcCA9PT0gJ2xlZnQnIHx8IHRyaWdnZXJCdXR0b25Qb3NpdGlvblByb3AgPT09ICdyaWdodCcpIHtcbiAgICB2YXIgdHJpZ2dlckhlaWdodCA9IHRyaWdnZXIub2Zmc2V0SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAoIWZsaXAgPyAxIDogLTEpICogKG1lbnVIZWlnaHQgLyAyIC0gdHJpZ2dlckhlaWdodCAvIDIpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG52YXIgT3ZlcmZsb3dNZW51ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKE92ZXJmbG93TWVudSwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE92ZXJmbG93TWVudSk7XG4gIC8qKlxuICAgKiBPdmVyZmxvdyBtZW51LlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGEgbW9kYWwgZGlhbG9nLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yT3B0aW9uTWVudV0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JUcmlnZ2VyXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHRyaWdnZXIgYnV0dG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NTaG93bl0gVGhlIENTUyBjbGFzcyBmb3IgdGhlIHNob3duIHN0YXRlLCBmb3IgdGhlIHRyaWdnZXIgVUkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc01lbnVTaG93bl0gVGhlIENTUyBjbGFzcyBmb3IgdGhlIHNob3duIHN0YXRlLCBmb3IgdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc01lbnVGbGlwXSBUaGUgQ1NTIGNsYXNzIGZvciB0aGUgZmxpcHBlZCBzdGF0ZSBvZiB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm9iak1lbnVPZmZzZXRdIFRoZSBvZmZzZXQgbG9jYXRpbmcgdGhlIG1lbnUgZm9yIHRoZSBub24tZmxpcHBlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm9iak1lbnVPZmZzZXRGbGlwXSBUaGUgb2Zmc2V0IGxvY2F0aW5nIHRoZSBtZW51IGZvciB0aGUgZmxpcHBlZCBzdGF0ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBPdmVyZmxvd01lbnUoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPdmVyZmxvd01lbnUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLmdldEN1cnJlbnROYXZpZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZvY3VzZWQgPSBfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIHJldHVybiBmb2N1c2VkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBmb2N1c2VkLm1hdGNoZXMoX3RoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW0pID8gZm9jdXNlZCA6IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLm5hdmlnYXRlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgdmFyIGl0ZW1zID0gX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtKSk7XG5cbiAgICAgIHZhciBzdGFydCA9IF90aGlzLmdldEN1cnJlbnROYXZpZ2F0aW9uKCkgfHwgX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtU2VsZWN0ZWQpO1xuXG4gICAgICB2YXIgZ2V0TmV4dEl0ZW0gPSBmdW5jdGlvbiBnZXROZXh0SXRlbShvbGQpIHtcbiAgICAgICAgdmFyIGhhbmRsZVVuZGVyZmxvdyA9IGZ1bmN0aW9uIGhhbmRsZVVuZGVyZmxvdyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICsgKGluZGV4ID49IDAgPyAwIDogbGVuZ3RoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlT3ZlcmZsb3cgPSBmdW5jdGlvbiBoYW5kbGVPdmVyZmxvdyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4IC0gKGluZGV4IDwgbGVuZ3RoID8gMCA6IGxlbmd0aCk7XG4gICAgICAgIH07IC8vIGBpdGVtcy5pbmRleE9mKG9sZClgIG1heSBiZSAtMSAoU2NlbmFyaW8gb2Ygbm8gcHJldmlvdXMgZm9jdXMpXG5cblxuICAgICAgICB2YXIgaW5kZXggPSBNYXRoLm1heChpdGVtcy5pbmRleE9mKG9sZCkgKyBkaXJlY3Rpb24sIC0xKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zW2hhbmRsZVVuZGVyZmxvdyhoYW5kbGVPdmVyZmxvdyhpbmRleCwgaXRlbXMubGVuZ3RoKSwgaXRlbXMubGVuZ3RoKV07XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBjdXJyZW50ID0gZ2V0TmV4dEl0ZW0oc3RhcnQpOyBjdXJyZW50ICYmIGN1cnJlbnQgIT09IHN0YXJ0OyBjdXJyZW50ID0gZ2V0TmV4dEl0ZW0oY3VycmVudCkpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50Lm1hdGNoZXMoX3RoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW1IaWRkZW4pICYmICFjdXJyZW50LnBhcmVudE5vZGUubWF0Y2hlcyhfdGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbUhpZGRlbikgJiYgIWN1cnJlbnQubWF0Y2hlcyhfdGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbVNlbGVjdGVkKSkge1xuICAgICAgICAgIGN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoX3RoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ2J1dHRvbicpIHtcbiAgICAgIC8vIFdvdWxkIHByZWZlciB0byB1c2UgdGhlIGFyaWEtY29udHJvbHMgd2l0aCBhIHNwZWNpZmljIElEIGJ1dCB3ZVxuICAgICAgLy8gZG9uJ3QgaGF2ZSB0aGUgbWVudU9wdGlvbnMgbGlzdCBhdCB0aGlzIHBvaW50IHRvIHB1bGwgdGhlIElEIGZyb21cbiAgICAgIF90aGlzLnRyaWdnZXJOb2RlID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUcmlnZ2VyKTtcbiAgICB9XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrKGV2ZW50KTtcblxuICAgICAgX3RoaXMud2FzT3BlbkJlZm9yZUNsaWNrID0gdW5kZWZpbmVkO1xuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy5faGFuZGxlS2V5UHJlc3MoZXZlbnQpO1xuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMud2FzT3BlbkJlZm9yZUNsaWNrID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoX3RoaXMub3B0aW9ucy5jbGFzc1Nob3duKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIHNob3duL2hpZGRlbiBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlIFRoZSBuZXcgc3RhdGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgZXZlbnQgdHJpZ2dpbmcgdGhpcyBhY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGNhbGxlZCB3aGVuIGNoYW5nZSBpbiBzdGF0ZSBjb21wbGV0ZXMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE92ZXJmbG93TWVudSwgW3tcbiAgICBrZXk6IFwiY2hhbmdlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlU3RhdGUoc3RhdGUsIGRldGFpbCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25NZW51KSB7XG4gICAgICAgIHZhciBvcHRpb25NZW51ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yT3B0aW9uTWVudSk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25NZW51KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCB0aGUgdGFyZ2V0IG1lbnUuJyk7XG4gICAgICAgIH0gLy8gTGF6aWx5IGNyZWF0ZSBhIGNvbXBvbmVudCBpbnN0YW5jZSBmb3IgbWVudVxuXG5cbiAgICAgICAgdGhpcy5vcHRpb25NZW51ID0gRmxvYXRpbmdNZW51LmNyZWF0ZShvcHRpb25NZW51LCB7XG4gICAgICAgICAgcmVmTm9kZTogdGhpcy5lbGVtZW50LFxuICAgICAgICAgIGNsYXNzU2hvd246IHRoaXMub3B0aW9ucy5jbGFzc01lbnVTaG93bixcbiAgICAgICAgICBjbGFzc1JlZlNob3duOiB0aGlzLm9wdGlvbnMuY2xhc3NTaG93bixcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMub3B0aW9ucy5vYmpNZW51T2Zmc2V0LFxuICAgICAgICAgIHRyaWdnZXJOb2RlOiB0aGlzLnRyaWdnZXJOb2RlLFxuICAgICAgICAgIGNvbnRlbnROb2RlOiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuc2VsZWN0b3JDb250ZW50KVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKHRoaXMub3B0aW9uTWVudSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbk1lbnUuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzTWVudUZsaXApKSB7XG4gICAgICAgIHRoaXMub3B0aW9uTWVudS5vcHRpb25zLm9mZnNldCA9IHRoaXMub3B0aW9ucy5vYmpNZW51T2Zmc2V0RmxpcDtcbiAgICAgIH0gLy8gRGVsZWdhdGVzIHRoZSBhY3Rpb24gb2YgY2hhbmdpbmcgc3RhdGUgdG8gdGhlIG1lbnUuXG4gICAgICAvLyAoQW5kIHRodXMgdGhlIGJlZm9yZS9hZnRlciBzaG93bi9oaWRkZW4gZXZlbnRzIGFyZSBmaXJlZCBmcm9tIHRoZSBtZW51KVxuXG5cbiAgICAgIHRoaXMub3B0aW9uTWVudS5jaGFuZ2VTdGF0ZShzdGF0ZSwgT2JqZWN0LmFzc2lnbihkZXRhaWwsIHtcbiAgICAgICAgZGVsZWdhdG9yTm9kZTogdGhpcy5lbGVtZW50XG4gICAgICB9KSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNsaWNrIG9uIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSB0cmlnZ2VyaW5nIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlRG9jdW1lbnRDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRG9jdW1lbnRDbGljayhldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgIG9wdGlvbk1lbnUgPSB0aGlzLm9wdGlvbk1lbnUsXG4gICAgICAgICAgd2FzT3BlbkJlZm9yZUNsaWNrID0gdGhpcy53YXNPcGVuQmVmb3JlQ2xpY2ssXG4gICAgICAgICAgdHJpZ2dlck5vZGUgPSB0aGlzLnRyaWdnZXJOb2RlO1xuICAgICAgdmFyIGlzT2ZTZWxmID0gZWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgICAgdmFyIGlzT2ZNZW51ID0gb3B0aW9uTWVudSAmJiBvcHRpb25NZW51LmVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KTtcbiAgICAgIHZhciBzaG91bGRCZU9wZW4gPSBpc09mU2VsZiAmJiAhd2FzT3BlbkJlZm9yZUNsaWNrO1xuICAgICAgdmFyIHN0YXRlID0gc2hvdWxkQmVPcGVuID8gJ3Nob3duJyA6ICdoaWRkZW4nO1xuXG4gICAgICBpZiAoaXNPZlNlbGYpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gZWxlbWVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzT2ZNZW51IHx8IGV2ZW50TWF0Y2hlcyhldmVudCwgdGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbSkpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShzdGF0ZSwgZ2V0TGF1bmNoaW5nRGV0YWlscyhldmVudCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09ICdoaWRkZW4nICYmIGlzT2ZNZW51KSB7XG4gICAgICAgICAgICAvLyBAdG9kbyBDYW4gY2xlYW4gdXAgdG8gdXNlIGB0aGlzLnRyaWdnZXJOb2RlYCBvbmNlIG5vbi1jb21wbGlhbnQgY29kZSBpcyBkZXByZWNhdGVkXG4gICAgICAgICAgICBfdGhpczJbdHJpZ2dlck5vZGUgPyAndHJpZ2dlck5vZGUnIDogJ2VsZW1lbnQnXS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBlbGVtZW50IHRvIG1vdmUgZm9jdXMgZnJvbVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBDdXJyZW50bHkgaGlnaGxpZ2h0ZWQgZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVLZXlQcmVzc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMga2V5IHByZXNzIG9uIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSB0cmlnZ2VyaW5nIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGtleSA9IGV2ZW50LndoaWNoO1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgb3B0aW9uTWVudSA9IHRoaXMub3B0aW9uTWVudSxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHRyaWdnZXJOb2RlID0gdGhpcy50cmlnZ2VyTm9kZTtcbiAgICAgIHZhciBpc09mTWVudSA9IG9wdGlvbk1lbnUgJiYgb3B0aW9uTWVudS5lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgICB2YXIgaXNFeHBhbmRlZCA9IHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmNsYXNzU2hvd24pOyAvLyBAdG9kbyBDYW4gY2xlYW4gdXAgdG8gdXNlIGB0aGlzLnRyaWdnZXJOb2RlYCBvbmNlIG5vbi1jb21wbGlhbnQgY29kZSBpcyBkZXByZWNhdGVkXG5cbiAgICAgIHZhciB0cmlnZ2VyRWxlbWVudCA9IHRyaWdnZXJOb2RlID8gJ3RyaWdnZXJOb2RlJyA6ICdlbGVtZW50JztcblxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgLy8gRW50ZXIgfHwgU3BhY2UgYmFyXG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0V4cGFuZGVkICYmIHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc09mU2VsZiA9IGVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBzaG91bGRCZU9wZW4gPSBpc09mU2VsZiAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMob3B0aW9ucy5jbGFzc1Nob3duKTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNob3VsZEJlT3BlbiA/ICdzaG93bicgOiAnaGlkZGVuJztcblxuICAgICAgICAgICAgaWYgKGlzT2ZTZWxmKSB7XG4gICAgICAgICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gZWxlbWVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgc2Nyb2xsaW5nXG5cbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShzdGF0ZSwgZ2V0TGF1bmNoaW5nRGV0YWlscyhldmVudCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdoaWRkZW4nICYmIGlzT2ZNZW51KSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczNbdHJpZ2dlckVsZW1lbnRdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMzg6IC8vIHVwIGFycm93XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAvLyBkb3duIGFycm93XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0V4cGFuZGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBzY3JvbGxpbmdcblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgMzg6IC0xLFxuICAgICAgICAgICAgICA0MDogMVxuICAgICAgICAgICAgfVtldmVudC53aGljaF07XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlKGRpcmVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLW92ZXJmbG93LW1lbnVdJyxcbiAgICAgICAgc2VsZWN0b3JPcHRpb25NZW51OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tb3ZlcmZsb3ctbWVudS1vcHRpb25zXCIpLFxuICAgICAgICBzZWxlY3RvclRyaWdnZXI6ICdidXR0b25bYXJpYS1oYXNwb3B1cF0nLFxuICAgICAgICBzZWxlY3RvckNvbnRlbnQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1vdmVyZmxvdy1tZW51LW9wdGlvbnNfX2NvbnRlbnRcIiksXG4gICAgICAgIHNlbGVjdG9ySXRlbTogXCJcXG4gICAgICAgIC5cIi5jb25jYXQocHJlZml4LCBcIi0tb3ZlcmZsb3ctbWVudS1vcHRpb25zLS1vcGVuXFxuICAgICAgICAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1vdmVyZmxvdy1tZW51LW9wdGlvbnNfX29wdGlvbjpub3QoLlwiKS5jb25jYXQocHJlZml4LCBcIi0tb3ZlcmZsb3ctbWVudS1vcHRpb25zX19vcHRpb24tLWRpc2FibGVkKSA+XFxuICAgICAgICAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1vdmVyZmxvdy1tZW51LW9wdGlvbnNfX2J0blxcbiAgICAgIFwiKSxcbiAgICAgICAgY2xhc3NTaG93bjogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tb3ZlcmZsb3ctbWVudS0tb3BlblwiKSxcbiAgICAgICAgY2xhc3NNZW51U2hvd246IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLW92ZXJmbG93LW1lbnUtb3B0aW9ucy0tb3BlblwiKSxcbiAgICAgICAgY2xhc3NNZW51RmxpcDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tb3ZlcmZsb3ctbWVudS0tZmxpcFwiKSxcbiAgICAgICAgb2JqTWVudU9mZnNldDogZ2V0TWVudU9mZnNldCxcbiAgICAgICAgb2JqTWVudU9mZnNldEZsaXA6IGdldE1lbnVPZmZzZXRcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgT3ZlcmZsb3dNZW51LmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gT3ZlcmZsb3dNZW51O1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeVNlYXJjaCwgZXZlbnRlZFNob3dIaWRlU3RhdGUsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgT3ZlcmZsb3dNZW51OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIFBhZ2luYXRpb25OYXYgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoUGFnaW5hdGlvbk5hdiwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBhZ2luYXRpb25OYXYpO1xuICAvKipcbiAgICogUGFnaW5hdGlvbiBOYXYgY29tcG9uZW50XG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYSBwYWdpbmF0aW9uIG5hdi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBQYWdpbmF0aW9uTmF2KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFnaW5hdGlvbk5hdik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMuZ2V0QWN0aXZlUGFnZU51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYWdlTnVtO1xuXG4gICAgICB2YXIgYWN0aXZlUGFnZUVsZW1lbnQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VBY3RpdmUpO1xuXG4gICAgICBpZiAoYWN0aXZlUGFnZUVsZW1lbnQpIHtcbiAgICAgICAgcGFnZU51bSA9IE51bWJlcihhY3RpdmVQYWdlRWxlbWVudC5nZXRBdHRyaWJ1dGUoX3RoaXMub3B0aW9ucy5hdHRyaWJQYWdlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYWdlTnVtO1xuICAgIH07XG5cbiAgICBfdGhpcy5jbGVhckFjdGl2ZVBhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICB2YXIgcGFnZUJ1dHRvbk5vZGVMaXN0ID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlQnV0dG9uKTtcblxuICAgICAgdmFyIHBhZ2VTZWxlY3RFbGVtZW50ID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlU2VsZWN0KTtcblxuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChwYWdlQnV0dG9uTm9kZUxpc3QsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKF90aGlzLm9wdGlvbnMuY2xhc3NBY3RpdmUsIF90aGlzLm9wdGlvbnMuY2xhc3NEaXNhYmxlZCk7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkFjdGl2ZSk7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpO1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwYWdlU2VsZWN0RWxlbWVudCkge1xuICAgICAgICBwYWdlU2VsZWN0RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpO1xuICAgICAgICB2YXIgcGFnZVNlbGVjdEVsZW1lbnRPcHRpb25zID0gcGFnZVNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChwYWdlU2VsZWN0RWxlbWVudE9wdGlvbnMsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkFjdGl2ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZXZ0LnRhcmdldC5tYXRjaGVzKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlU2VsZWN0KSkge1xuICAgICAgICAgIHBhZ2VTZWxlY3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc0FjdGl2ZSk7XG4gICAgICAgICAgcGFnZVNlbGVjdEVsZW1lbnQudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmICghZXZ0LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbmV4dEFjdGl2ZVBhZ2VOdW1iZXIgPSBfdGhpcy5nZXRBY3RpdmVQYWdlTnVtYmVyKCk7XG5cbiAgICAgICAgdmFyIHBhZ2VFbGVtZW50Tm9kZUxpc3QgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VFbGVtZW50KTtcblxuICAgICAgICB2YXIgcGFnZVNlbGVjdEVsZW1lbnQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VTZWxlY3QpO1xuXG4gICAgICAgIF90aGlzLmNsZWFyQWN0aXZlUGFnZShldnQpO1xuXG4gICAgICAgIGlmIChldnQudGFyZ2V0Lm1hdGNoZXMoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VCdXR0b24pKSB7XG4gICAgICAgICAgbmV4dEFjdGl2ZVBhZ2VOdW1iZXIgPSBOdW1iZXIoZXZ0LnRhcmdldC5nZXRBdHRyaWJ1dGUoX3RoaXMub3B0aW9ucy5hdHRyaWJQYWdlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZ0LnRhcmdldC5tYXRjaGVzKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlUHJldmlvdXMpKSB7XG4gICAgICAgICAgbmV4dEFjdGl2ZVBhZ2VOdW1iZXIgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldnQudGFyZ2V0Lm1hdGNoZXMoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VOZXh0KSkge1xuICAgICAgICAgIG5leHRBY3RpdmVQYWdlTnVtYmVyICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFnZVRhcmdldEVsZW1lbnQgPSBwYWdlRWxlbWVudE5vZGVMaXN0W25leHRBY3RpdmVQYWdlTnVtYmVyIC0gMV07XG4gICAgICAgIHBhZ2VUYXJnZXRFbGVtZW50LnNldEF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkFjdGl2ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHBhZ2VUYXJnZXRFbGVtZW50LnRhZ05hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgcGFnZVNlbGVjdEVsZW1lbnQudmFsdWUgPSBfdGhpcy5nZXRBY3RpdmVQYWdlTnVtYmVyKCk7XG4gICAgICAgICAgcGFnZVNlbGVjdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzQWN0aXZlKTtcbiAgICAgICAgICBwYWdlU2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICdwYWdlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFnZVRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzQWN0aXZlLCBfdGhpcy5vcHRpb25zLmNsYXNzRGlzYWJsZWQpO1xuICAgICAgICAgIHBhZ2VUYXJnZXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgIHBhZ2VUYXJnZXRFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3BhZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldFByZXZOZXh0U3RhdGVzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVNlbGVjdENoYW5nZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIF90aGlzLmNsZWFyQWN0aXZlUGFnZShldnQpO1xuXG4gICAgICB2YXIgcGFnZVNlbGVjdEVsZW1lbnQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VTZWxlY3QpO1xuXG4gICAgICB2YXIgcGFnZVNlbGVjdEVsZW1lbnRPcHRpb25zID0gcGFnZVNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgIHBhZ2VTZWxlY3RFbGVtZW50T3B0aW9uc1twYWdlU2VsZWN0RWxlbWVudE9wdGlvbnMuc2VsZWN0ZWRJbmRleF0uc2V0QXR0cmlidXRlKF90aGlzLm9wdGlvbnMuYXR0cmliQWN0aXZlLCB0cnVlKTtcbiAgICAgIGV2dC50YXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAncGFnZScpO1xuICAgICAgZXZ0LnRhcmdldC5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NBY3RpdmUpO1xuXG4gICAgICBfdGhpcy5zZXRQcmV2TmV4dFN0YXRlcygpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRQcmV2TmV4dFN0YXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYWdlRWxlbWVudE5vZGVMaXN0ID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlRWxlbWVudCk7XG5cbiAgICAgIHZhciB0b3RhbFBhZ2VzID0gcGFnZUVsZW1lbnROb2RlTGlzdC5sZW5ndGg7XG5cbiAgICAgIHZhciBwYWdlRGlyZWN0aW9uRWxlbWVudFByZXZpb3VzID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlUHJldmlvdXMpO1xuXG4gICAgICB2YXIgcGFnZURpcmVjdGlvbkVsZW1lbnROZXh0ID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlTmV4dCk7XG5cbiAgICAgIGlmIChwYWdlRGlyZWN0aW9uRWxlbWVudFByZXZpb3VzKSB7XG4gICAgICAgIGlmIChfdGhpcy5nZXRBY3RpdmVQYWdlTnVtYmVyKCkgPD0gMSkge1xuICAgICAgICAgIHBhZ2VEaXJlY3Rpb25FbGVtZW50UHJldmlvdXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgcGFnZURpcmVjdGlvbkVsZW1lbnRQcmV2aW91cy5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NEaXNhYmxlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFnZURpcmVjdGlvbkVsZW1lbnRQcmV2aW91cy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKTtcbiAgICAgICAgICBwYWdlRGlyZWN0aW9uRWxlbWVudFByZXZpb3VzLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc0Rpc2FibGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFnZURpcmVjdGlvbkVsZW1lbnROZXh0KSB7XG4gICAgICAgIGlmIChfdGhpcy5nZXRBY3RpdmVQYWdlTnVtYmVyKCkgPj0gdG90YWxQYWdlcykge1xuICAgICAgICAgIHBhZ2VEaXJlY3Rpb25FbGVtZW50TmV4dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICBwYWdlRGlyZWN0aW9uRWxlbWVudE5leHQuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzRGlzYWJsZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZ2VEaXJlY3Rpb25FbGVtZW50TmV4dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKTtcbiAgICAgICAgICBwYWdlRGlyZWN0aW9uRWxlbWVudE5leHQuY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5vcHRpb25zLmNsYXNzRGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlQ2xpY2soZXZ0KTtcbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2NoYW5nZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChldnQudGFyZ2V0Lm1hdGNoZXMoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VTZWxlY3QpKSB7XG4gICAgICAgIF90aGlzLmhhbmRsZVNlbGVjdENoYW5nZShldnQpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IGFjdGl2ZSBwYWdlIG51bWJlclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQYWdpbmF0aW9uTmF2LCBudWxsLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvciwge0BsaW5rY29kZSBQYWdpbmF0aW9uTmF2LmNyZWF0ZSAuY3JlYXRlKCl9LFxuICAgICAqIG9yIHtAbGlua2NvZGUgUGFnaW5hdGlvbk5hdi5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZSBhbmQgaG93IHtAbGlua2NvZGUgUGFnaW5hdGlvbk5hdi5pbml0IC5pbml0KCl9IHdvcmtzLlxuICAgICAqIEBtZW1iZXIgUGFnaW5hdGlvbk5hdi5vcHRpb25zXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JJbml0IFRoZSBkYXRhIGF0dHJpYnV0ZSB0byBmaW5kIHBhZ2luYXRpb24gbmF2LlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvclBhZ2VFbGVtZW50IFRoZSBkYXRhIGF0dHJpYnV0ZSB0byBmaW5kIHBhZ2UgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JQYWdlQnV0dG9uIFRoZSBkYXRhIGF0dHJpYnV0ZSB0byBmaW5kIHBhZ2UgaW50ZXJhY3RpdmUgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JQYWdlRGlyZWN0aW9uIFRoZSBkYXRhIGF0dHJpYnV0ZSB0byBmaW5kIHBhZ2UgY2hhbmdlIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9yUGFnZVNlbGVjdCBUaGUgZGF0YSBhdHRyaWJ1dGUgdG8gZmluZCBwYWdlIHNlbGVjdCBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvclBhZ2VBY3RpdmUgVGhlIGRhdGEgYXR0cmlidXRlIHRvIGZpbmQgYWN0aXZlIHBhZ2UgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzQWN0aXZlXSBUaGUgQ1NTIGNsYXNzIGZvciBwYWdlJ3Mgc2VsZWN0ZWQgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc0Rpc2FibGVkXSBUaGUgQ1NTIGNsYXNzIGZvciBwYWdlJ3MgZGlzYWJsZWQgc3RhdGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLXBhZ2luYXRpb24tbmF2XScsXG4gICAgICAgIHNlbGVjdG9yUGFnZUVsZW1lbnQ6ICdbZGF0YS1wYWdlXScsXG4gICAgICAgIHNlbGVjdG9yUGFnZUJ1dHRvbjogJ1tkYXRhLXBhZ2UtYnV0dG9uXScsXG4gICAgICAgIHNlbGVjdG9yUGFnZVByZXZpb3VzOiAnW2RhdGEtcGFnZS1wcmV2aW91c10nLFxuICAgICAgICBzZWxlY3RvclBhZ2VOZXh0OiAnW2RhdGEtcGFnZS1uZXh0XScsXG4gICAgICAgIHNlbGVjdG9yUGFnZVNlbGVjdDogJ1tkYXRhLXBhZ2Utc2VsZWN0XScsXG4gICAgICAgIHNlbGVjdG9yUGFnZUFjdGl2ZTogJ1tkYXRhLXBhZ2UtYWN0aXZlPVwidHJ1ZVwiXScsXG4gICAgICAgIGF0dHJpYlBhZ2U6ICdkYXRhLXBhZ2UnLFxuICAgICAgICBhdHRyaWJBY3RpdmU6ICdkYXRhLXBhZ2UtYWN0aXZlJyxcbiAgICAgICAgY2xhc3NBY3RpdmU6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXBhZ2luYXRpb24tbmF2X19wYWdlLS1hY3RpdmVcIiksXG4gICAgICAgIGNsYXNzRGlzYWJsZWQ6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXBhZ2luYXRpb24tbmF2X19wYWdlLS1kaXNhYmxlZFwiKVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBQYWdpbmF0aW9uTmF2LmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gUGFnaW5hdGlvbk5hdjtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgUGFnaW5hdGlvbk5hdjsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL2V2ZW50LW1hdGNoZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciBQYWdpbmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKFBhZ2luYXRpb24sIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQYWdpbmF0aW9uKTtcbiAgLyoqXG4gICAqIFBhZ2luYXRpb24gY29tcG9uZW50LlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhIHBhZ2luYXRpb24gY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvckluaXRdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBwYWdpbmF0aW9uIGNvbXBvbmVudHMuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JJdGVtc1BlclBhZ2VJbnB1dF1cbiAgICogICBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGlucHV0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHBlciBwYWdlLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yUGFnZU51bWJlcklucHV0XSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGlucHV0IHRoYXQgY2hhbmdlcyB0aGUgcGFnZSBkaXNwbGF5ZWQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JQYWdlQmFja3dhcmRdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgYnV0dG9uIHRoYXQgZ29lcyBiYWNrIGEgcGFnZS5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclBhZ2VGb3J3YXJkXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGJ1dHRvbiB0aGF0IGdvZXMgZm9yd2FyZCBhIHBhZ2UuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXZlbnRJdGVtc1BlclBhZ2VdXG4gICAqICAgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCBmaXJlZCB3aGVuIGEgdXNlciBjaGFuZ2VzIHRoZSBudW1iZXIgb2YgaXRlbXMgcGVyIHBhZ2UuXG4gICAqICAgZXZlbnQuZGV0YWlsLnZhbHVlIGNvbnRhaW5zIHRoZSBudW1iZXIgb2YgaXRlbXMgYSB1c2VyIHdpc2hlcyB0byBzZWUuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXZlbnRQYWdlTnVtYmVyXVxuICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgd2hlbiBhIHVzZXIgaW5wdXRzIGEgc3BlY2lmaWMgcGFnZSBudW1iZXIuXG4gICAqICAgZXZlbnQuZGV0YWlsLnZhbHVlIGNvbnRhaW5zIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIGlucHV0LlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50UGFnZUNoYW5nZV1cbiAgICogICBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gYSB1c2VyIGdvZXMgZm9yd2FyZCBvciBiYWNrd2FyZCBhIHBhZ2UuXG4gICAqICAgZXZlbnQuZGV0YWlsLmRpcmVjdGlvbiBjb250YWlucyB0aGUgZGlyZWN0aW9uIGEgdXNlciB3aXNoZXMgdG8gZ28uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gUGFnaW5hdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2luYXRpb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLl9lbWl0RXZlbnQgPSBmdW5jdGlvbiAoZXZ0TmFtZSwgZGV0YWlsKSB7XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJcIi5jb25jYXQoZXZ0TmFtZSksIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKGV2ZW50TWF0Y2hlcyhldnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JQYWdlQmFja3dhcmQpKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgaW5pdGlhbEV2dDogZXZ0LFxuICAgICAgICAgIGVsZW1lbnQ6IGV2dC50YXJnZXQsXG4gICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX2VtaXRFdmVudChfdGhpcy5vcHRpb25zLmV2ZW50UGFnZUNoYW5nZSwgZGV0YWlsKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRNYXRjaGVzKGV2dCwgX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhZ2VGb3J3YXJkKSkge1xuICAgICAgICB2YXIgX2RldGFpbCA9IHtcbiAgICAgICAgICBpbml0aWFsRXZ0OiBldnQsXG4gICAgICAgICAgZWxlbWVudDogZXZ0LnRhcmdldCxcbiAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLl9lbWl0RXZlbnQoX3RoaXMub3B0aW9ucy5ldmVudFBhZ2VDaGFuZ2UsIF9kZXRhaWwpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnaW5wdXQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoZXZlbnRNYXRjaGVzKGV2dCwgX3RoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW1zUGVyUGFnZUlucHV0KSkge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgIGluaXRpYWxFdnQ6IGV2dCxcbiAgICAgICAgICBlbGVtZW50OiBldnQudGFyZ2V0LFxuICAgICAgICAgIHZhbHVlOiBldnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX2VtaXRFdmVudChfdGhpcy5vcHRpb25zLmV2ZW50SXRlbXNQZXJQYWdlLCBkZXRhaWwpO1xuICAgICAgfSBlbHNlIGlmIChldmVudE1hdGNoZXMoZXZ0LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yUGFnZU51bWJlcklucHV0KSkge1xuICAgICAgICB2YXIgX2RldGFpbDIgPSB7XG4gICAgICAgICAgaW5pdGlhbEV2dDogZXZ0LFxuICAgICAgICAgIGVsZW1lbnQ6IGV2dC50YXJnZXQsXG4gICAgICAgICAgdmFsdWU6IGV2dC50YXJnZXQudmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5fZW1pdEV2ZW50KF90aGlzLm9wdGlvbnMuZXZlbnRQYWdlTnVtYmVyLCBfZGV0YWlsMik7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnROYW1lIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWwgY29udGFpbnMgdGhlIG9yaWdpbmFsIGV2ZW50IGFuZCBhbnkgb3RoZXIgbmVjZXNzYXJ5IGRldGFpbHMuXG4gICAqL1xuXG5cbiAgUGFnaW5hdGlvbi5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgUGFnaW5hdGlvbi5vcHRpb25zID0ge1xuICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLXBhZ2luYXRpb25dJyxcbiAgICBzZWxlY3Rvckl0ZW1zUGVyUGFnZUlucHV0OiAnW2RhdGEtaXRlbXMtcGVyLXBhZ2VdJyxcbiAgICBzZWxlY3RvclBhZ2VOdW1iZXJJbnB1dDogJ1tkYXRhLXBhZ2UtbnVtYmVyLWlucHV0XScsXG4gICAgc2VsZWN0b3JQYWdlQmFja3dhcmQ6ICdbZGF0YS1wYWdlLWJhY2t3YXJkXScsXG4gICAgc2VsZWN0b3JQYWdlRm9yd2FyZDogJ1tkYXRhLXBhZ2UtZm9yd2FyZF0nLFxuICAgIGV2ZW50SXRlbXNQZXJQYWdlOiAnaXRlbXNQZXJQYWdlJyxcbiAgICBldmVudFBhZ2VOdW1iZXI6ICdwYWdlTnVtYmVyJyxcbiAgICBldmVudFBhZ2VDaGFuZ2U6ICdwYWdlQ2hhbmdlJ1xuICB9O1xuICByZXR1cm4gUGFnaW5hdGlvbjtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgUGFnaW5hdGlvbjsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcblxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbnZhciBQcm9ncmVzc0luZGljYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhQcm9ncmVzc0luZGljYXRvciwgX21peGluKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFByb2dyZXNzSW5kaWNhdG9yKTtcbiAgLyoqXG4gICAqIFByb2dyZXNzSW5kaWNhdG9yLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBQcm9ncmVzc0luZGljYXRvci5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclN0ZXBFbGVtZW50XSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgc3RlcCBlbGVtZW50cy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yQ3VycmVudF0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBjdXJyZW50IHN0ZXAgZWxlbWVudC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9ySW5jb21wbGV0ZV0gVGhlIENTUyBjbGFzcyB0byBmaW5kIGluY29tcGxldGUgc3RlcCBlbGVtZW50cy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yQ29tcGxldGVdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBjb21wbGV0ZWQgc3RlcCBlbGVtZW50cy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzU3RlcF0gVGhlIGNsYXNzTmFtZSBmb3IgYSBzdGVwIGVsZW1lbnQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0NvbXBsZXRlXSBUaGUgY2xhc3NOYW1lIGZvciBhIGNvbXBsZXRlZCBzdGVwIGVsZW1lbnQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0N1cnJlbnRdIFRoZSBjbGFzc05hbWUgZm9yIHRoZSBjdXJyZW50IHN0ZXAgZWxlbWVudC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzSW5jb21wbGV0ZV0gVGhlIGNsYXNzTmFtZSBmb3IgYSBpbmNvbXBsZXRlIHN0ZXAgZWxlbWVudC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBQcm9ncmVzc0luZGljYXRvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2dyZXNzSW5kaWNhdG9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjdXJyZW50IHN0ZXAgaW5kZXguXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBjdXJyZW50SW5kZXg6IF90aGlzLmdldEN1cnJlbnQoKS5pbmRleCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUb3RhbCBudW1iZXIgb2Ygc3RlcHMuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0b3RhbFN0ZXBzOiBfdGhpcy5nZXRTdGVwcygpLmxlbmd0aFxuICAgIH07XG5cbiAgICBfdGhpcy5hZGRPdmVyZmxvd1Rvb2x0aXAoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgc3RlcHMgd2l0aCBkZXRhaWxzIGFib3V0IGVsZW1lbnQgYW5kIGluZGV4LlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQcm9ncmVzc0luZGljYXRvciwgW3tcbiAgICBrZXk6IFwiZ2V0U3RlcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RlcHMoKSB7XG4gICAgICByZXR1cm4gdG9BcnJheSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JTdGVwRWxlbWVudCkpLm1hcChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBzdGVwOyBnaXZlcyBkZXRhaWwgYWJvdXQgZWxlbWVudCBhbmQgaW5kZXguXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgICB2YXIgY3VycmVudEVsID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yQ3VycmVudCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdGVwcygpLmZpbHRlcihmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICByZXR1cm4gc3RlcC5lbGVtZW50ID09PSBjdXJyZW50RWw7XG4gICAgICB9KVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBzdGVwLlxuICAgICAqICogQHBhcmFtIHtOdW1iZXJ9IG5ldyBzdGVwIGluZGV4IG9yIHVzZSBkZWZhdWx0IGluIGB0aGlzLnN0YXRlLmN1cnJlbnRJbmRleGAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG5ld0N1cnJlbnRTdGVwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnN0YXRlLmN1cnJlbnRJbmRleDtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChuZXdDdXJyZW50U3RlcCAhPT0gdGhpcy5zdGF0ZS5jdXJyZW50SW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50SW5kZXggPSBuZXdDdXJyZW50U3RlcDtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuZ2V0U3RlcHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgaWYgKHN0ZXAuaW5kZXggPCBuZXdDdXJyZW50U3RlcCkge1xuICAgICAgICAgICAgX3RoaXMyLl91cGRhdGVTdGVwKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogc3RlcC5lbGVtZW50LFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IF90aGlzMi5vcHRpb25zLmNsYXNzQ29tcGxldGUsXG4gICAgICAgICAgICAgIGh0bWw6IF90aGlzMi5fZ2V0U1ZHQ29tcGxldGUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0ZXAuaW5kZXggPT09IG5ld0N1cnJlbnRTdGVwKSB7XG4gICAgICAgICAgICBfdGhpczIuX3VwZGF0ZVN0ZXAoe1xuICAgICAgICAgICAgICBlbGVtZW50OiBzdGVwLmVsZW1lbnQsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogX3RoaXMyLm9wdGlvbnMuY2xhc3NDdXJyZW50LFxuICAgICAgICAgICAgICBodG1sOiBfdGhpczIuX2dldEN1cnJlbnRTVkcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0ZXAuaW5kZXggPiBuZXdDdXJyZW50U3RlcCkge1xuICAgICAgICAgICAgX3RoaXMyLl91cGRhdGVTdGVwKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogc3RlcC5lbGVtZW50LFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IF90aGlzMi5vcHRpb25zLmNsYXNzSW5jb21wbGV0ZSxcbiAgICAgICAgICAgICAgaHRtbDogX3RoaXMyLl9nZXRJbmNvbXBsZXRlU1ZHKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzdGVwIHdpdGggY29ycmVjdCBpbmxpbmUgU1ZHIGFuZCBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5lbGVtZW50XSB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jbGFzc05hbWVdIG5ldyBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuaHRtbF0gbmV3IGlubGluZSBTVkcgdG8gaW5zZXJ0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RlcChhcmdzKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGFyZ3MuZWxlbWVudCxcbiAgICAgICAgICBjbGFzc05hbWUgPSBhcmdzLmNsYXNzTmFtZSxcbiAgICAgICAgICBodG1sID0gYXJncy5odG1sO1xuXG4gICAgICBpZiAoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzU3RlcCk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIGh0bWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEhUTUwgc3RyaW5nIGZvciBhbiBTVkcgdXNlZCB0byByZXByZXNlbnQgYSBjb21wZWx0ZWQgc3RlcCAoY2hlY2ttYXJrKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFNWR0NvbXBsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTVkdDb21wbGV0ZSgpIHtcbiAgICAgIHJldHVybiBcIjxzdmcgd2lkdGg9XFxcIjI0cHhcXFwiIGhlaWdodD1cXFwiMjRweFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG4gICAgICAgIDxjaXJjbGUgY3g9XFxcIjEyXFxcIiBjeT1cXFwiMTJcXFwiIHI9XFxcIjEyXFxcIj48L2NpcmNsZT5cXG4gICAgICAgIDxwb2x5Z29uIHBvaW50cz1cXFwiMTAuMyAxMy42IDcuNyAxMSA2LjMgMTIuNCAxMC4zIDE2LjQgMTcuOCA5IDE2LjQgNy42XFxcIj48L3BvbHlnb24+XFxuICAgICAgPC9zdmc+XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSFRNTCBzdHJpbmcgZm9yIGFuIFNWRyB1c2VkIHRvIHJlcHJlc2VudCBjdXJyZW50IHN0ZXAgKGNpcmNsZXMsIGxpa2UgYSByYWRpbyBidXR0b24sIGJ1dCBub3QuKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEN1cnJlbnRTVkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEN1cnJlbnRTVkcoKSB7XG4gICAgICByZXR1cm4gXCI8c3ZnPlxcbiAgICAgICAgPGNpcmNsZSBjeD1cXFwiMTJcXFwiIGN5PVxcXCIxMlxcXCIgcj1cXFwiMTJcXFwiPjwvY2lyY2xlPlxcbiAgICAgICAgPGNpcmNsZSBjeD1cXFwiMTJcXFwiIGN5PVxcXCIxMlxcXCIgcj1cXFwiNlxcXCI+PC9jaXJjbGU+XFxuICAgICAgPC9zdmc+XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSFRNTCBzdHJpbmcgZm9yIGFuIFNWRyB1c2VkIHRvIHJlcHJlc2VudCBpbmNvbXBsZSBzdGVwIChncmV5IGVtcHR5IGNpcmNsZSlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRJbmNvbXBsZXRlU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRJbmNvbXBsZXRlU1ZHKCkge1xuICAgICAgcmV0dXJuIFwiPHN2Zz5cXG4gICAgICAgIDxjaXJjbGUgY3g9XFxcIjEyXFxcIiBjeT1cXFwiMTJcXFwiIHI9XFxcIjEyXFxcIj48L2NpcmNsZT5cXG4gICAgICA8L3N2Zz5cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkT3ZlcmZsb3dUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE92ZXJmbG93VG9vbHRpcCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RlcExhYmVscyA9IHRvQXJyYXkodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNlbGVjdG9yTGFiZWwpKTtcbiAgICAgIHZhciB0b29sdGlwcyA9IHRvQXJyYXkodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNlbGVjdG9yVG9vbHRpcCkpO1xuICAgICAgc3RlcExhYmVscy5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwLnNjcm9sbFdpZHRoID4gX3RoaXMzLm9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICBzdGVwLmNsYXNzTGlzdC5hZGQoX3RoaXMzLm9wdGlvbnMuY2xhc3NPdmVyZmxvd0xhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gICAgICAgIHZhciBjaGlsZFRleHQgPSB0b29sdGlwLnF1ZXJ5U2VsZWN0b3IoX3RoaXMzLm9wdGlvbnMuc2VsZWN0b3JUb29sdGlwVGV4dCk7XG5cbiAgICAgICAgaWYgKGNoaWxkVGV4dC5zY3JvbGxIZWlnaHQgPiBfdGhpczMub3B0aW9ucy50b29sdGlwTWF4SGVpZ2h0KSB7XG4gICAgICAgICAgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKF90aGlzMy5vcHRpb25zLmNsYXNzVG9vbHRpcE11bHRpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBQcm9ncmVzc0luZGljYXRvci5jcmVhdGUgLmNyZWF0ZSgpfSwgb3Ige0BsaW5rY29kZSBQcm9ncmVzc0luZGljYXRvci5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZWQuXG4gICAgICogQG1lbWJlciBQcm9ncmVzc0luZGljYXRvci5vcHRpb25zXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JJbml0IFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBjb250ZW50IHN3aXRjaGVyIGJ1dHRvbiBzZXQuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclN0ZXBFbGVtZW50XSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgc3RlcCBlbGVtZW50cy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yQ3VycmVudF0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBjdXJyZW50IHN0ZXAgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9ySW5jb21wbGV0ZV0gVGhlIENTUyBjbGFzcyB0byBmaW5kIGluY29tcGxldGUgc3RlcCBlbGVtZW50cy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yQ29tcGxldGVdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBjb21wbGV0ZWQgc3RlcCBlbGVtZW50cy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzU3RlcF0gVGhlIGNsYXNzTmFtZSBmb3IgYSBzdGVwIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc0NvbXBsZXRlXSBUaGUgY2xhc3NOYW1lIGZvciBhIGNvbXBsZXRlZCBzdGVwIGVsZW1lbnQuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc0N1cnJlbnRdIFRoZSBjbGFzc05hbWUgZm9yIHRoZSBjdXJyZW50IHN0ZXAgZWxlbWVudC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzSW5jb21wbGV0ZV0gVGhlIGNsYXNzTmFtZSBmb3IgYSBpbmNvbXBsZXRlIHN0ZXAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtcHJvZ3Jlc3NdJyxcbiAgICAgICAgc2VsZWN0b3JTdGVwRWxlbWVudDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXByb2dyZXNzLXN0ZXBcIiksXG4gICAgICAgIHNlbGVjdG9yQ3VycmVudDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXByb2dyZXNzLXN0ZXAtLWN1cnJlbnRcIiksXG4gICAgICAgIHNlbGVjdG9ySW5jb21wbGV0ZTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXByb2dyZXNzLXN0ZXAtLWluY29tcGxldGVcIiksXG4gICAgICAgIHNlbGVjdG9yQ29tcGxldGU6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1wcm9ncmVzcy1zdGVwLS1jb21wbGV0ZVwiKSxcbiAgICAgICAgc2VsZWN0b3JMYWJlbDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXByb2dyZXNzLWxhYmVsXCIpLFxuICAgICAgICBzZWxlY3RvclRvb2x0aXA6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS10b29sdGlwXCIpLFxuICAgICAgICBzZWxlY3RvclRvb2x0aXBUZXh0OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tdG9vbHRpcF9fdGV4dFwiKSxcbiAgICAgICAgY2xhc3NTdGVwOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1wcm9ncmVzcy1zdGVwXCIpLFxuICAgICAgICBjbGFzc0NvbXBsZXRlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1wcm9ncmVzcy1zdGVwLS1jb21wbGV0ZVwiKSxcbiAgICAgICAgY2xhc3NDdXJyZW50OiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1wcm9ncmVzcy1zdGVwLS1jdXJyZW50XCIpLFxuICAgICAgICBjbGFzc0luY29tcGxldGU6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXByb2dyZXNzLXN0ZXAtLWluY29tcGxldGVcIiksXG4gICAgICAgIGNsYXNzT3ZlcmZsb3dMYWJlbDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tcHJvZ3Jlc3MtbGFiZWwtb3ZlcmZsb3dcIiksXG4gICAgICAgIGNsYXNzVG9vbHRpcE11bHRpOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10b29sdGlwX211bHRpXCIpLFxuICAgICAgICBtYXhXaWR0aDogODcsXG4gICAgICAgIHRvb2x0aXBNYXhIZWlnaHQ6IDIxXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIFByb2dyZXNzSW5kaWNhdG9yLmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gUHJvZ3Jlc3NJbmRpY2F0b3I7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzSW5kaWNhdG9yOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgZXZlbnRNYXRjaGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9ldmVudC1tYXRjaGVzJztcbmltcG9ydCBvbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2Mvb24nO1xuaW1wb3J0IHN2Z1RvZ2dsZUNsYXNzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9zdmctdG9nZ2xlLWNsYXNzJztcblxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbnZhciBTZWFyY2ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoU2VhcmNoLCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2VhcmNoKTtcbiAgLyoqXG4gICAqIFNlYXJjaCB3aXRoIE9wdGlvbnMuXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgdGhlIHNlYXJjaCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvckluaXRdXG4gICAqICAgVGhlIHNlbGVjdG9yIHRvIGZpbmQgc2VhcmNoIFVJcyB3aXRoIG9wdGlvbnMuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclNlYXJjaFZpZXddXG4gICAqICAgVGhlIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHNlYXJjaCB2aWV3IGljb24gY29udGFpbmVycy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yU2VhcmNoSW5wdXRdXG4gICAqICAgVGhlIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHNlYXJjaCBpbnB1dC5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yQ2xlYXJJY29uXVxuICAgKiAgIFRoZSBzZWxlY3RvciBmb3IgdGhlIGNsZWFyIGljb24gdGhhdCBjbGVhcnMgdGhlIHNlYXJjaCBib3guXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3Rvckljb25Db250YWluZXJdIFRoZSBkYXRhIGF0dHJpYnV0ZSBzZWxlY3RvciBmb3IgdGhlIGljb24gbGF5b3V0IGNvbnRhaW5lci5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzQ2xlYXJIaWRkZW5dIFRoZSBjbGFzcyB1c2VkIHRvIGhpZGUgdGhlIGNsZWFyIGljb24uXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0xheW91dEhpZGRlbl0gVGhlIGNsYXNzIHVzZWQgdG8gaGlkZSBub25zZWxlY3RlZCBsYXlvdXQgdmlldy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBTZWFyY2goZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWFyY2gpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIHZhciBjbG9zZUljb24gPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckNsZWFySWNvbik7XG5cbiAgICB2YXIgaW5wdXQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclNlYXJjaElucHV0KTtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgdGhlIHNlYXJjaCBpbnB1dC4nKTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VJY29uKSB7XG4gICAgICBfdGhpcy5tYW5hZ2Uob24oY2xvc2VJY29uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN2Z1RvZ2dsZUNsYXNzKGNsb3NlSWNvbiwgX3RoaXMub3B0aW9ucy5jbGFzc0NsZWFySGlkZGVuLCB0cnVlKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyIHRvZ2dsZUl0ZW0gPSBldmVudE1hdGNoZXMoZXZ0LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9ySWNvbkNvbnRhaW5lcik7XG4gICAgICBpZiAodG9nZ2xlSXRlbSkgX3RoaXMudG9nZ2xlTGF5b3V0KHRvZ2dsZUl0ZW0pO1xuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihpbnB1dCwgJ2lucHV0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKGNsb3NlSWNvbikgX3RoaXMuc2hvd0NsZWFyKGV2dC50YXJnZXQudmFsdWUsIGNsb3NlSWNvbik7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIGJldHdlZW4gdGhlIGdyaWQgYW5kIGxpc3QgbGF5b3V0LlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGNvbnRpbmluZyB0aGUgbGF5b3V0IHRvZ2dsZS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU2VhcmNoLCBbe1xuICAgIGtleTogXCJ0b2dnbGVMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTGF5b3V0KGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0b0FycmF5KGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JTZWFyY2hWaWV3KSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC50b2dnbGUoX3RoaXMyLm9wdGlvbnMuY2xhc3NMYXlvdXRIaWRkZW4pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGNsZWFyIGljb24gdmlzaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHZhbHVlIFRoZSBlbGVtZW50IHNlcnZpbmcgYXMgdGhlIHNlYXJjaCBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uIFRoZSBlbGVtZW50IHNlcnZpbmcgYXMgY2xvc2UgaWNvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNob3dDbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93Q2xlYXIodmFsdWUsIGljb24pIHtcbiAgICAgIHN2Z1RvZ2dsZUNsYXNzKGljb24sIHRoaXMub3B0aW9ucy5jbGFzc0NsZWFySGlkZGVuLCB2YWx1ZS5sZW5ndGggPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBTZWFyY2guY3JlYXRlIC5jcmVhdGUoKX0sIG9yIHtAbGlua2NvZGUgU2VhcmNoLmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlZFxuICAgICAqIGFuZCBob3cge0BsaW5rY29kZSBTZWFyY2guaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAbWVtYmVyIFNlYXJjaC5vcHRpb25zXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JJbml0XVxuICAgICAqICAgVGhlIHNlbGVjdG9yIHRvIGZpbmQgc2VhcmNoIFVJcyB3aXRoIG9wdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yU2VhcmNoVmlld11cbiAgICAgKiAgIFRoZSBzZWxlY3RvciB0byBmaW5kIHRoZSBzZWFyY2ggdmlldyBpY29uIGNvbnRhaW5lcnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yU2VhcmNoSW5wdXRdXG4gICAgICogICBUaGUgc2VsZWN0b3IgdG8gZmluZCB0aGUgc2VhcmNoIGlucHV0LlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvckNsZWFySWNvbl1cbiAgICAgKiAgIFRoZSBzZWxlY3RvciBmb3IgdGhlIGNsZWFyIGljb24gdGhhdCBjbGVhcnMgdGhlIHNlYXJjaCBib3guXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9ySWNvbkNvbnRhaW5lcl0gVGhlIGRhdGEgYXR0cmlidXRlIHNlbGVjdG9yIGZvciB0aGUgaWNvbiBsYXlvdXQgY29udGFpbmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0NsZWFySGlkZGVuXSBUaGUgY2xhc3MgdXNlZCB0byBoaWRlIHRoZSBjbGVhciBpY29uLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0xheW91dEhpZGRlbl0gVGhlIGNsYXNzIHVzZWQgdG8gaGlkZSBub25zZWxlY3RlZCBsYXlvdXQgdmlldy5cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLXNlYXJjaF0nLFxuICAgICAgICBzZWxlY3RvclNlYXJjaFZpZXc6ICdbZGF0YS1zZWFyY2gtdmlld10nLFxuICAgICAgICBzZWxlY3RvclNlYXJjaElucHV0OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tc2VhcmNoLWlucHV0XCIpLFxuICAgICAgICBzZWxlY3RvckNsZWFySWNvbjogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXNlYXJjaC1jbG9zZVwiKSxcbiAgICAgICAgc2VsZWN0b3JJY29uQ29udGFpbmVyOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tc2VhcmNoLWJ1dHRvbltkYXRhLXNlYXJjaC10b2dnbGVdXCIpLFxuICAgICAgICBjbGFzc0NsZWFySGlkZGVuOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zZWFyY2gtY2xvc2UtLWhpZGRlblwiKSxcbiAgICAgICAgY2xhc3NMYXlvdXRIaWRkZW46IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXNlYXJjaC12aWV3LS1oaWRkZW5cIilcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIHNlYXJjaCBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIFNlYXJjaC5jb21wb25lbnRzXG4gICAgICogQHR5cGUge1dlYWtNYXB9XG4gICAgICovXG5cbiAgfV0pO1xuXG4gIFNlYXJjaC5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIFNlYXJjaDtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gsIGhhbmRsZXMpKTtcblxuZXhwb3J0IGRlZmF1bHQgU2VhcmNoOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGV2ZW50ZWRTdGF0ZSBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9ldmVudGVkLXN0YXRlJztcbmltcG9ydCBoYW5kbGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2hhbmRsZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciBTbGlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoU2xpZGVyLCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2xpZGVyKTtcbiAgLyoqXG4gICAqIFNsaWRlci5cbiAgICogQGV4dGVuZHMgQ3JlYXRlQ29tcG9uZW50XG4gICAqIEBleHRlbmRzIEluaXRDb21wb25lbnRCeVNlYXJjaFxuICAgKiBAZXh0ZW5kcyBIYW5kbGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhbiBzbGlkZXIuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gU2xpZGVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRldGFpbCwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIF90aGlzLnNsaWRlckFjdGl2ZSA9IGZhbHNlO1xuICAgIF90aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgX3RoaXMudHJhY2sgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRyYWNrKTtcbiAgICBfdGhpcy5maWxsZWRUcmFjayA9IF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yRmlsbGVkVHJhY2spO1xuICAgIF90aGlzLnRodW1iID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUaHVtYik7XG4gICAgX3RoaXMuaW5wdXQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvcklucHV0KTtcblxuICAgIGlmIChfdGhpcy5lbGVtZW50LmRhdGFzZXQuc2xpZGVySW5wdXRCb3gpIHtcbiAgICAgIF90aGlzLmJvdW5kSW5wdXQgPSBfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5lbGVtZW50LmRhdGFzZXQuc2xpZGVySW5wdXRCb3gpO1xuXG4gICAgICBfdGhpcy5fdXBkYXRlSW5wdXQoKTtcblxuICAgICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmJvdW5kSW5wdXQsICdjaGFuZ2UnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKGV2dC50YXJnZXQudmFsdWUpO1xuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuYm91bmRJbnB1dCwgJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBldnQudGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgfSkpOyAvLyB3b3JrYXJvdW5kIGZvciBzYWZhcmlcblxuXG4gICAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuYm91bmRJbnB1dCwgJ21vdXNldXAnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIF90aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLnRodW1iLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2xpZGVyQWN0aXZlID0gdHJ1ZTtcbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LCAnbW91c2V1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNsaWRlckFjdGl2ZSA9IGZhbHNlO1xuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhfdGhpcy5vcHRpb25zLmNsYXNzRGlzYWJsZWQpO1xuXG4gICAgICBpZiAoX3RoaXMuc2xpZGVyQWN0aXZlID09PSB0cnVlICYmICFkaXNhYmxlZCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlUG9zaXRpb24oZXZ0KTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMudGh1bWIsICdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoX3RoaXMub3B0aW9ucy5jbGFzc0Rpc2FibGVkKTtcblxuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlUG9zaXRpb24oZXZ0KTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMudHJhY2ssICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKF90aGlzLm9wdGlvbnMuY2xhc3NEaXNhYmxlZCk7XG5cbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZVBvc2l0aW9uKGV2dCk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNsaWRlciwgW3tcbiAgICBrZXk6IFwiX3VwZGF0ZVBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQb3NpdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkX2NhbGNWYWx1ZSA9IHRoaXMuX2NhbGNWYWx1ZShldnQpLFxuICAgICAgICAgIGxlZnQgPSBfdGhpcyRfY2FsY1ZhbHVlLmxlZnQsXG4gICAgICAgICAgbmV3VmFsdWUgPSBfdGhpcyRfY2FsY1ZhbHVlLm5ld1ZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzMi50aHVtYi5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQobGVmdCwgXCIlXCIpO1xuICAgICAgICBfdGhpczIuZmlsbGVkVHJhY2suc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoMCUsIC01MCUpIHNjYWxlWChcIi5jb25jYXQobGVmdCAvIDEwMCwgXCIpXCIpO1xuICAgICAgICBfdGhpczIuaW5wdXQudmFsdWUgPSBuZXdWYWx1ZTtcblxuICAgICAgICBfdGhpczIuX3VwZGF0ZUlucHV0KCk7XG5cbiAgICAgICAgX3RoaXMyLmNoYW5nZVN0YXRlKCdzbGlkZXItdmFsdWUtY2hhbmdlJywge1xuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjVmFsdWUoZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0SW5wdXRQcm9wcyA9IHRoaXMuZ2V0SW5wdXRQcm9wcygpLFxuICAgICAgICAgIHZhbHVlID0gX3RoaXMkZ2V0SW5wdXRQcm9wcy52YWx1ZSxcbiAgICAgICAgICBtaW4gPSBfdGhpcyRnZXRJbnB1dFByb3BzLm1pbixcbiAgICAgICAgICBtYXggPSBfdGhpcyRnZXRJbnB1dFByb3BzLm1heCxcbiAgICAgICAgICBzdGVwID0gX3RoaXMkZ2V0SW5wdXRQcm9wcy5zdGVwO1xuXG4gICAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICB2YXIgdmFsdWVQZXJjZW50YWdlID0gKHZhbHVlIC0gbWluKSAvIHJhbmdlICogMTAwO1xuICAgICAgdmFyIGxlZnQ7XG4gICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICBsZWZ0ID0gdmFsdWVQZXJjZW50YWdlO1xuICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKGV2dCkge1xuICAgICAgICB2YXIgdHlwZSA9IGV2dC50eXBlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0ge1xuICAgICAgICAgICAgNDA6IC0xLFxuICAgICAgICAgICAgLy8gZGVjcmVhc2luZ1xuICAgICAgICAgICAgMzc6IC0xLFxuICAgICAgICAgICAgLy8gZGVjcmVhc2luZ1xuICAgICAgICAgICAgMzg6IDEsXG4gICAgICAgICAgICAvLyBpbmNyZWFzaW5nXG4gICAgICAgICAgICAzOTogMSAvLyBpbmNyZWFzaW5nXG5cbiAgICAgICAgICB9W2V2dC53aGljaF07XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZXZ0LnNoaWZ0S2V5ID09PSB0cnVlID8gcmFuZ2UgLyBzdGVwIC8gdGhpcy5vcHRpb25zLnN0ZXBNdWx0aXBsaWVyIDogMTtcbiAgICAgICAgICAgIHZhciBzdGVwTXVsdGlwbGllZCA9IHN0ZXAgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgdmFyIHN0ZXBTaXplID0gc3RlcE11bHRpcGxpZWQgLyByYW5nZSAqIDEwMDtcbiAgICAgICAgICAgIGxlZnQgPSB2YWx1ZVBlcmNlbnRhZ2UgKyBzdGVwU2l6ZSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gTnVtYmVyKHZhbHVlKSArIHN0ZXBNdWx0aXBsaWVkICogZGlyZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJyB8fCB0eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvclRodW1iKS5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc1RodW1iQ2xpY2tlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvclRodW1iKS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc1RodW1iQ2xpY2tlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFjay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgdW5yb3VuZGVkID0gKGV2dC5jbGllbnRYIC0gdHJhY2subGVmdCkgLyB0cmFjay53aWR0aDtcbiAgICAgICAgICB2YXIgcm91bmRlZCA9IE1hdGgucm91bmQocmFuZ2UgKiB1bnJvdW5kZWQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgICAgbGVmdCA9IHJvdW5kZWQgLyByYW5nZSAqIDEwMDtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHJvdW5kZWQgKyBtaW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1ZhbHVlIDw9IE51bWJlcihtaW4pKSB7XG4gICAgICAgIGxlZnQgPSAwO1xuICAgICAgICBuZXdWYWx1ZSA9IG1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1ZhbHVlID49IE51bWJlcihtYXgpKSB7XG4gICAgICAgIGxlZnQgPSAxMDA7XG4gICAgICAgIG5ld1ZhbHVlID0gbWF4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVJbnB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSW5wdXQoKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZElucHV0KSB7XG4gICAgICAgIHRoaXMuYm91bmRJbnB1dC52YWx1ZSA9IHRoaXMuaW5wdXQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElucHV0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5wdXRQcm9wcygpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIHZhbHVlOiBOdW1iZXIodGhpcy5pbnB1dC52YWx1ZSksXG4gICAgICAgIG1pbjogTnVtYmVyKHRoaXMuaW5wdXQubWluKSxcbiAgICAgICAgbWF4OiBOdW1iZXIodGhpcy5pbnB1dC5tYXgpLFxuICAgICAgICBzdGVwOiB0aGlzLmlucHV0LnN0ZXAgPyBOdW1iZXIodGhpcy5pbnB1dC5zdGVwKSA6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGVwVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcFVwKCkge1xuICAgICAgdGhpcy5pbnB1dC5zdGVwVXAoKTtcblxuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RlcERvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcERvd24oKSB7XG4gICAgICB0aGlzLmlucHV0LnN0ZXBEb3duKCk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIFNsaWRlciBVSSBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlZC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JJbml0IFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBzbGlkZXIgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS1zbGlkZXJdJyxcbiAgICAgICAgc2VsZWN0b3JUcmFjazogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXNsaWRlcl9fdHJhY2tcIiksXG4gICAgICAgIHNlbGVjdG9yRmlsbGVkVHJhY2s6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zbGlkZXJfX2ZpbGxlZC10cmFja1wiKSxcbiAgICAgICAgc2VsZWN0b3JUaHVtYjogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXNsaWRlcl9fdGh1bWJcIiksXG4gICAgICAgIHNlbGVjdG9ySW5wdXQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zbGlkZXJfX2lucHV0XCIpLFxuICAgICAgICBjbGFzc0Rpc2FibGVkOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zbGlkZXItLWRpc2FibGVkXCIpLFxuICAgICAgICBjbGFzc1RodW1iQ2xpY2tlZDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tc2xpZGVyX190aHVtYi0tY2xpY2tlZFwiKSxcbiAgICAgICAgZXZlbnRCZWZvcmVTbGlkZXJWYWx1ZUNoYW5nZTogJ3NsaWRlci1iZWZvcmUtdmFsdWUtY2hhbmdlJyxcbiAgICAgICAgZXZlbnRBZnRlclNsaWRlclZhbHVlQ2hhbmdlOiAnc2xpZGVyLWFmdGVyLXZhbHVlLWNoYW5nZScsXG4gICAgICAgIHN0ZXBNdWx0aXBsaWVyOiA0XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIFNsaWRlci5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIFNsaWRlcjtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gsIGV2ZW50ZWRTdGF0ZSwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBTbGlkZXI7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL2V2ZW50LW1hdGNoZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59O1xuXG52YXIgU3RydWN0dXJlZExpc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoU3RydWN0dXJlZExpc3QsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTdHJ1Y3R1cmVkTGlzdCk7XG4gIC8qKlxuICAgKiBTdHJ1Y3R1cmVkTGlzdFxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgcm9vdCBlbGVtZW50IG9mIHRhYmxlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIHRoZS4uLiBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvckluaXRdIHNlbGVjdG9yIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclJvd10gY3NzIHNlbGVjdG9yIGZvciBzZWxlY3RlZCByb3dcbiAgICovXG5cblxuICBmdW5jdGlvbiBTdHJ1Y3R1cmVkTGlzdChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cnVjdHVyZWRMaXN0KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LndoaWNoID09PSAzNyB8fCBldnQud2hpY2ggPT09IDM4IHx8IGV2dC53aGljaCA9PT0gMzkgfHwgZXZ0LndoaWNoID09PSA0MCkge1xuICAgICAgICBfdGhpcy5faGFuZGxlS2V5ZG93bkFycm93KGV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldnQud2hpY2ggPT09IDEzIHx8IGV2dC53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgX3RoaXMuX2hhbmRsZUtleWRvd25DaGVja2VkKGV2dCk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVDbGljayhldnQpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHJ1Y3R1cmVkTGlzdCwgW3tcbiAgICBrZXk6IFwiX2RpcmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlyZWN0aW9uKGV2dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgMzc6IC0xLFxuICAgICAgICAvLyBiYWNrd2FyZFxuICAgICAgICAzODogLTEsXG4gICAgICAgIC8vIGJhY2t3YXJkXG4gICAgICAgIDM5OiAxLFxuICAgICAgICAvLyBmb3J3YXJkXG4gICAgICAgIDQwOiAxIC8vIGZvcndhcmRcblxuICAgICAgfVtldnQud2hpY2hdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbmV4dEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXh0SW5kZXgoYXJyYXksIGFycmF5SXRlbSwgZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihhcnJheUl0ZW0pICsgZGlyZWN0aW9uOyAvLyByZXR1cm5zIC0xLCAwLCAxLCAyLCAzLCA0Li4uXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRJbnB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5wdXQoaW5kZXgpIHtcbiAgICAgIHZhciByb3dzID0gdG9BcnJheSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JSb3cpKTtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvckxpc3RJbnB1dChyb3dzW2luZGV4XS5nZXRBdHRyaWJ1dGUoJ2ZvcicpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVJbnB1dENoZWNrZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUlucHV0Q2hlY2tlZChpbmRleCkge1xuICAgICAgdmFyIHJvd3MgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JSb3cpO1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dChpbmRleCkgfHwgcm93c1tpbmRleF0ucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNsaWNrKGV2dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzZWxlY3RlZFJvdyA9IGV2ZW50TWF0Y2hlcyhldnQsIHRoaXMub3B0aW9ucy5zZWxlY3RvclJvdyk7XG4gICAgICB0b0FycmF5KHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5zZWxlY3RvclJvdykpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gcm93LmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMyLm9wdGlvbnMuY2xhc3NBY3RpdmUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZFJvdykge1xuICAgICAgICBzZWxlY3RlZFJvdy5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc0FjdGl2ZSk7XG4gICAgICB9XG4gICAgfSAvLyBIYW5kbGUgRW50ZXIgb3IgU3BhY2Uga2V5ZG93biBldmVudHMgZm9yIHNlbGVjdGluZyA8bGFiZWw+IHJvd3NcblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVLZXlkb3duQ2hlY2tlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5ZG93bkNoZWNrZWQoZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgc3BhY2ViYXIgZnJvbSBzY3JvbGxpbmcgcGFnZVxuXG4gICAgICB2YXIgc2VsZWN0ZWRSb3cgPSBldmVudE1hdGNoZXMoZXZ0LCB0aGlzLm9wdGlvbnMuc2VsZWN0b3JSb3cpO1xuICAgICAgdG9BcnJheSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JSb3cpKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5jbGFzc0xpc3QucmVtb3ZlKF90aGlzMy5vcHRpb25zLmNsYXNzQWN0aXZlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZWN0ZWRSb3cpIHtcbiAgICAgICAgc2VsZWN0ZWRSb3cuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY2xhc3NBY3RpdmUpO1xuICAgICAgICB2YXIgaW5wdXQgPSBzZWxlY3RlZFJvdy5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvckxpc3RJbnB1dChzZWxlY3RlZFJvdy5nZXRBdHRyaWJ1dGUoJ2ZvcicpKSkgfHwgc2VsZWN0ZWRSb3cucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBIYW5kbGUgdXAgYW5kIGRvd24ga2V5ZG93biBldmVudHMgZm9yIHNlbGVjdGluZyA8bGFiZWw+IHJvd3NcblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVLZXlkb3duQXJyb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtleWRvd25BcnJvdyhldnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBhcnJvdyBrZXlzIGZyb20gc2Nyb2xsaW5nXG5cbiAgICAgIHZhciBzZWxlY3RlZFJvdyA9IGV2ZW50TWF0Y2hlcyhldnQsIHRoaXMub3B0aW9ucy5zZWxlY3RvclJvdyk7XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb24oZXZ0KTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiAmJiBzZWxlY3RlZFJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciByb3dzID0gdG9BcnJheSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JSb3cpKTtcbiAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93LmNsYXNzTGlzdC5yZW1vdmUoX3RoaXM0Lm9wdGlvbnMuY2xhc3NBY3RpdmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpcnN0SW5kZXggPSAwO1xuXG4gICAgICAgIHZhciBuZXh0SW5kZXggPSB0aGlzLl9uZXh0SW5kZXgocm93cywgc2VsZWN0ZWRSb3csIGRpcmVjdGlvbik7XG5cbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHJvd3MubGVuZ3RoIC0gMTtcblxuICAgICAgICB2YXIgZ2V0U2VsZWN0ZWRJbmRleCA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXh0SW5kZXgpIHtcbiAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgIHJldHVybiBsYXN0SW5kZXg7XG5cbiAgICAgICAgICAgIGNhc2Ugcm93cy5sZW5ndGg6XG4gICAgICAgICAgICAgIHJldHVybiBmaXJzdEluZGV4O1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IGdldFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgcm93c1tzZWxlY3RlZEluZGV4XS5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc0FjdGl2ZSk7XG4gICAgICAgIHJvd3Nbc2VsZWN0ZWRJbmRleF0uZm9jdXMoKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVJbnB1dENoZWNrZWQoc2VsZWN0ZWRJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLXN0cnVjdHVyZWQtbGlzdF0nLFxuICAgICAgICBzZWxlY3RvclJvdzogXCJbZGF0YS1zdHJ1Y3R1cmVkLWxpc3RdIC5cIi5jb25jYXQocHJlZml4LCBcIi0tc3RydWN0dXJlZC1saXN0LXRib2R5ID4gbGFiZWwuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1zdHJ1Y3R1cmVkLWxpc3Qtcm93XCIpLFxuICAgICAgICBzZWxlY3Rvckxpc3RJbnB1dDogZnVuY3Rpb24gc2VsZWN0b3JMaXN0SW5wdXQoaWQpIHtcbiAgICAgICAgICByZXR1cm4gXCIjXCIuY29uY2F0KGlkLCBcIi5cIikuY29uY2F0KHByZWZpeCwgXCItLXN0cnVjdHVyZWQtbGlzdC1pbnB1dFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NBY3RpdmU6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXN0cnVjdHVyZWQtbGlzdC1yb3ctLXNlbGVjdGVkXCIpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIFN0cnVjdHVyZWRMaXN0LmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gU3RydWN0dXJlZExpc3Q7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBoYW5kbGVzKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN0cnVjdHVyZWRMaXN0OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL2V2ZW50LW1hdGNoZXMnO1xuaW1wb3J0IENvbnRlbnRTd2l0Y2hlciBmcm9tICcuLi9jb250ZW50LXN3aXRjaGVyL2NvbnRlbnQtc3dpdGNoZXInO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59O1xuXG52YXIgVGFiID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udGVudFN3aXRjaGVyKSB7XG4gIF9pbmhlcml0cyhUYWIsIF9Db250ZW50U3dpdGNoZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGFiKTtcbiAgLyoqXG4gICAqIENvbnRhaW5lciBvZiB0YWJzLlxuICAgKiBAZXh0ZW5kcyBDb250ZW50U3dpdGNoZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGEgY29udGFpbmVyIG9mIHRhYnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JNZW51XSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGRyb3AgZG93biBtZW51IHVzZWQgaW4gbmFycm93IG1vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclRyaWdnZXJdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgYnV0dG9uIHRvIG9wZW4gdGhlIGRyb3AgZG93biBtZW51IHVzZWQgaW4gbmFycm93IG1vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclRyaWdnZXJUZXh0XVxuICAgKiAgIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgZWxlbWVudCB1c2VkIGluIG5hcnJvdyBtb2RlIHNob3dpbmcgdGhlIHNlbGVjdGVkIHRhYiBpdGVtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JCdXR0b25dIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0YWIgY29udGFpbmVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yQnV0dG9uU2VsZWN0ZWRdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgc2VsZWN0ZWQgdGFiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JMaW5rXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGxpbmtzIGluIHRhYnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0FjdGl2ZV0gVGhlIENTUyBjbGFzcyBmb3IgdGFiJ3Mgc2VsZWN0ZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc0hpZGRlbl0gVGhlIENTUyBjbGFzcyBmb3IgdGhlIGRyb3AgZG93biBtZW51J3MgaGlkZGVuIHN0YXRlIHVzZWQgaW4gbmFycm93IG1vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEJlZm9yZVNlbGVjdGVkXVxuICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgYmVmb3JlIGEgdGFiIGlzIHNlbGVjdGVkLlxuICAgKiAgIENhbmNlbGxhdGlvbiBvZiB0aGlzIGV2ZW50IHN0b3BzIHNlbGVjdGlvbiBvZiB0YWIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldmVudEFmdGVyU2VsZWN0ZWRdIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgYWZ0ZXIgYSB0YWIgaXMgc2VsZWN0ZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gVGFiKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFiKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVLZXlEb3duKGV2ZW50KTtcbiAgICB9KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrKGV2ZW50KTtcbiAgICB9KSk7XG5cbiAgICB2YXIgc2VsZWN0ZWQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckJ1dHRvblNlbGVjdGVkKTtcblxuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgX3RoaXMuX3VwZGF0ZVRyaWdnZXJUZXh0KHNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBvZiB7QGxpbmtjb2RlIFRhYiNzZXRBY3RpdmUgLnNldEFjdGl2ZSgpfSwgdG8gc2VsZWN0IGEgdGFiIGl0ZW0uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgZXZlbnQgdHJpZ2dpbmcgdGhpcyBhY3Rpb24uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRldGFpbC5pdGVtIFRoZSB0YWIgaXRlbSB0byBiZSBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgY2FsbGVkIHdoZW4gY2hhbmdlIGluIHN0YXRlIGNvbXBsZXRlcy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVGFiLCBbe1xuICAgIGtleTogXCJfY2hhbmdlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoYW5nZVN0YXRlKGRldGFpbCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUYWIucHJvdG90eXBlKSwgXCJfY2hhbmdlU3RhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCBkZXRhaWwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgX3RoaXMyLl91cGRhdGVUcmlnZ2VyVGV4dChkZXRhaWwuaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGF0YSA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgZGF0YVtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIFtlcnJvcl0uY29uY2F0KGRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNsaWNrIG9uIHRhYiBjb250YWluZXIuXG4gICAgICogKiBJZiB0aGUgY2xpY2sgaXMgb24gYSB0YWIsIGFjdGl2YXRlcyBpdC5cbiAgICAgKiAqIElmIHRoZSBjbGljayBpcyBvbiB0aGUgYnV0dG9uIHRvIG9wZW4gdGhlIGRyb3AgZG93biBtZW51LCBkb2VzIHNvLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDbGljayhldmVudCkge1xuICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50TWF0Y2hlcyhldmVudCwgdGhpcy5vcHRpb25zLnNlbGVjdG9yQnV0dG9uKTtcbiAgICAgIHZhciB0cmlnZ2VyID0gZXZlbnRNYXRjaGVzKGV2ZW50LCB0aGlzLm9wdGlvbnMuc2VsZWN0b3JUcmlnZ2VyKTtcblxuICAgICAgaWYgKGJ1dHRvbiAmJiAhYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NCdXR0b25EaXNhYmxlZCkpIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVGFiLnByb3RvdHlwZSksIFwiX2hhbmRsZUNsaWNrXCIsIHRoaXMpLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1lbnVTdGF0ZShmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1lbnVTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNsaWNrIG9uIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSB0cmlnZ2VyaW5nIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlRG9jdW1lbnRDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRG9jdW1lbnRDbGljayhldmVudCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICB2YXIgaXNPZlNlbGYgPSBlbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG5cbiAgICAgIGlmIChpc09mU2VsZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VwZGF0ZU1lbnVTdGF0ZShmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYXJyb3cga2V5cyBvbiB0YWIgY29udGFpbmVyLlxuICAgICAqICogTGVmdCBrZXlzIGFyZSB1c2VkIHRvIGdvIHRvIHByZXZpb3VzIHRhYi5cbiAgICAgKiAqIFJpZ2h0IGtleXMgYXJlIHVzZWQgdG8gZ28gdG8gbmV4dCB0YWIuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRyaWdnZXJpbmcgdGhpcyBtZXRob2QuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlS2V5RG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0cmlnZ2VyTm9kZSA9IGV2ZW50TWF0Y2hlcyhldmVudCwgdGhpcy5vcHRpb25zLnNlbGVjdG9yVHJpZ2dlcik7XG5cbiAgICAgIGlmICh0cmlnZ2VyTm9kZSkge1xuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTWVudVN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB7XG4gICAgICAgIDM3OiB0aGlzLmNvbnN0cnVjdG9yLk5BVklHQVRFLkJBQ0tXQVJELFxuICAgICAgICAzOTogdGhpcy5jb25zdHJ1Y3Rvci5OQVZJR0FURS5GT1JXQVJEXG4gICAgICB9W2V2ZW50LndoaWNoXTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgYnV0dG9ucyA9IHRvQXJyYXkodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNlbGVjdG9yQnV0dG9uRW5hYmxlZCkpO1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yQnV0dG9uU2VsZWN0ZWQpO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gTWF0aC5tYXgoYnV0dG9ucy5pbmRleE9mKGJ1dHRvbikgKyBkaXJlY3Rpb24sIC0xXG4gICAgICAgIC8qIEZvciBgYnV0dG9uYCBub3QgZm91bmQgaW4gYGJ1dHRvbnNgICovXG4gICAgICAgICk7XG4gICAgICAgIHZhciBuZXh0SW5kZXhMb29wZWQgPSBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBidXR0b25zLmxlbmd0aCA/IG5leHRJbmRleCA6IG5leHRJbmRleCAtIE1hdGguc2lnbihuZXh0SW5kZXgpICogYnV0dG9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKGJ1dHRvbnNbbmV4dEluZGV4TG9vcGVkXSwgZnVuY3Rpb24gKGVycm9yLCBpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBsaW5rID0gaXRlbS5xdWVyeVNlbGVjdG9yKF90aGlzMy5vcHRpb25zLnNlbGVjdG9yTGluayk7XG5cbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgIGxpbmsuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cy9oaWRlcyB0aGUgZHJvcCBkb3duIG1lbnUgdXNlZCBpbiBuYXJyb3cgbW9kZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZV0gYHRydWVgIHRvIHNob3cgdGhlIG1lbnUsIGBmYWxzZWAgdG8gaGlkZSB0aGUgbWVudSwgb3RoZXJ3aXNlIHRvZ2dsZXMgdGhlIG1lbnUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlTWVudVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVNZW51U3RhdGUoZm9yY2UpIHtcbiAgICAgIHZhciBtZW51ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yTWVudSk7XG4gICAgICB2YXIgdHJpZ2dlciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvclRyaWdnZXIpO1xuXG4gICAgICBpZiAobWVudSkge1xuICAgICAgICBtZW51LmNsYXNzTGlzdC50b2dnbGUodGhpcy5vcHRpb25zLmNsYXNzSGlkZGVuLCB0eXBlb2YgZm9yY2UgPT09ICd1bmRlZmluZWQnID8gZm9yY2UgOiAhZm9yY2UpO1xuXG4gICAgICAgIGlmIChtZW51LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NIaWRkZW4pKSB7XG4gICAgICAgICAgdHJpZ2dlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc09wZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY2xhc3NPcGVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0ZXh0IGluZGljYXRpbmcgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YWIgaXRlbS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGhlIG5ld2x5IHNlbGVjdGVkIHRhYiBpdGVtLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVRyaWdnZXJUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVUcmlnZ2VyVGV4dCh0YXJnZXQpIHtcbiAgICAgIHZhciB0cmlnZ2VyVGV4dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvclRyaWdnZXJUZXh0KTtcblxuICAgICAgaWYgKHRyaWdnZXJUZXh0KSB7XG4gICAgICAgIHRyaWdnZXJUZXh0LnRleHRDb250ZW50ID0gdGFyZ2V0LnRleHRDb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCB0YWIgY29udGFpbmVyIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXIgVGFiLmNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsIHtAbGlua2NvZGUgQ29udGVudFN3aXRjaGVyLmNyZWF0ZSAuY3JlYXRlKCl9LCBvciB7QGxpbmtjb2RlIFRhYi5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZSBhbmQgaG93IHtAbGlua2NvZGUgVGFiLmluaXQgLmluaXQoKX0gd29ya3MuXG4gICAgICogQG1lbWJlciBUYWIub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGFiIGNvbnRhaW5lcnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3Rvck1lbnVdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgZHJvcCBkb3duIG1lbnUgdXNlZCBpbiBuYXJyb3cgbW9kZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yVHJpZ2dlcl0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBidXR0b24gdG8gb3BlbiB0aGUgZHJvcCBkb3duIG1lbnUgdXNlZCBpbiBuYXJyb3cgbW9kZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yVHJpZ2dlclRleHRdXG4gICAgICogICBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGVsZW1lbnQgdXNlZCBpbiBuYXJyb3cgbW9kZSBzaG93aW5nIHRoZSBzZWxlY3RlZCB0YWIgaXRlbS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yQnV0dG9uXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGFiIGNvbnRhaW5lcnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvckJ1dHRvblNlbGVjdGVkXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHNlbGVjdGVkIHRhYi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yTGlua10gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBsaW5rcyBpbiB0YWJzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NBY3RpdmVdIFRoZSBDU1MgY2xhc3MgZm9yIHRhYidzIHNlbGVjdGVkIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NIaWRkZW5dIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBkcm9wIGRvd24gbWVudSdzIGhpZGRlbiBzdGF0ZSB1c2VkIGluIG5hcnJvdyBtb2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXZlbnRCZWZvcmVTZWxlY3RlZF1cbiAgICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgZmlyZWQgYmVmb3JlIGEgdGFiIGlzIHNlbGVjdGVkLlxuICAgICAqICAgQ2FuY2VsbGF0aW9uIG9mIHRoaXMgZXZlbnQgc3RvcHMgc2VsZWN0aW9uIG9mIHRhYi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50QWZ0ZXJTZWxlY3RlZF0gVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCBmaXJlZCBhZnRlciBhIHRhYiBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShDb250ZW50U3dpdGNoZXIub3B0aW9ucyksIHtcbiAgICAgICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtdGFic10nLFxuICAgICAgICBzZWxlY3Rvck1lbnU6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS10YWJzX19uYXZcIiksXG4gICAgICAgIHNlbGVjdG9yVHJpZ2dlcjogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXRhYnMtdHJpZ2dlclwiKSxcbiAgICAgICAgc2VsZWN0b3JUcmlnZ2VyVGV4dDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXRhYnMtdHJpZ2dlci10ZXh0XCIpLFxuICAgICAgICBzZWxlY3RvckJ1dHRvbjogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXRhYnNfX25hdi1pdGVtXCIpLFxuICAgICAgICBzZWxlY3RvckJ1dHRvbkVuYWJsZWQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS10YWJzX19uYXYtaXRlbTpub3QoLlwiKS5jb25jYXQocHJlZml4LCBcIi0tdGFic19fbmF2LWl0ZW0tLWRpc2FibGVkKVwiKSxcbiAgICAgICAgc2VsZWN0b3JCdXR0b25TZWxlY3RlZDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXRhYnNfX25hdi1pdGVtLS1zZWxlY3RlZFwiKSxcbiAgICAgICAgc2VsZWN0b3JMaW5rOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tdGFic19fbmF2LWxpbmtcIiksXG4gICAgICAgIGNsYXNzQWN0aXZlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10YWJzX19uYXYtaXRlbS0tc2VsZWN0ZWRcIiksXG4gICAgICAgIGNsYXNzSGlkZGVuOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10YWJzX19uYXYtLWhpZGRlblwiKSxcbiAgICAgICAgY2xhc3NPcGVuOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10YWJzLXRyaWdnZXItLW9wZW5cIiksXG4gICAgICAgIGNsYXNzQnV0dG9uRGlzYWJsZWQ6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXRhYnNfX25hdi1pdGVtLS1kaXNhYmxlZFwiKSxcbiAgICAgICAgZXZlbnRCZWZvcmVTZWxlY3RlZDogJ3RhYi1iZWluZ3NlbGVjdGVkJyxcbiAgICAgICAgZXZlbnRBZnRlclNlbGVjdGVkOiAndGFiLXNlbGVjdGVkJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudW0gZm9yIG5hdmlnYXRpbmcgYmFja3dhcmQvZm9yd2FyZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyIFRhYi5OQVZJR0FURVxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJBQ0tXQVJEIE5hdmlnYXRpbmcgYmFja3dhcmQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZPUldBUkQgTmF2aWdhdGluZyBmb3J3YXJkLlxuICAgICAqL1xuXG4gIH1dKTtcblxuICBUYWIuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIFRhYi5OQVZJR0FURSA9IHtcbiAgICBCQUNLV0FSRDogLTEsXG4gICAgRk9SV0FSRDogMVxuICB9O1xuICByZXR1cm4gVGFiO1xufShDb250ZW50U3dpdGNoZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBUYWI7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL2V2ZW50LW1hdGNoZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciBUZXh0SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoVGV4dElucHV0LCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGV4dElucHV0KTtcbiAgLyoqXG4gICAqIFRleHQgSW5wdXQuXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnVuY3Rpb25pbmcgYXMgYSB0ZXh0IGZpZWxkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFRleHRJbnB1dChfZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0SW5wdXQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5fc2V0SWNvblZpc2liaWxpdHkgPSBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGljb25WaXNpYmlsaXR5T24gPSBfcmVmLmljb25WaXNpYmlsaXR5T24sXG4gICAgICAgICAgaWNvblZpc2liaWxpdHlPZmYgPSBfcmVmLmljb25WaXNpYmlsaXR5T2ZmLFxuICAgICAgICAgIHBhc3N3b3JkSXNWaXNpYmxlID0gX3JlZi5wYXNzd29yZElzVmlzaWJsZSxcbiAgICAgICAgICBzZWxlY3RvclBhc3N3b3JkVmlzaWJpbGl0eVRvb2x0aXAgPSBfcmVmLnNlbGVjdG9yUGFzc3dvcmRWaXNpYmlsaXR5VG9vbHRpcDtcblxuICAgICAgaWYgKHBhc3N3b3JkSXNWaXNpYmxlKSB7XG4gICAgICAgIGljb25WaXNpYmlsaXR5T24uc2V0QXR0cmlidXRlKCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgaWNvblZpc2liaWxpdHlPZmYucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgICAgc2VsZWN0b3JQYXNzd29yZFZpc2liaWxpdHlUb29sdGlwLnRleHRDb250ZW50ID0gJ0hpZGUgcGFzc3dvcmQnO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGljb25WaXNpYmlsaXR5T24ucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgIGljb25WaXNpYmlsaXR5T2ZmLnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgdHJ1ZSk7XG4gICAgICBzZWxlY3RvclBhc3N3b3JkVmlzaWJpbGl0eVRvb2x0aXAudGV4dENvbnRlbnQgPSAnU2hvdyBwYXNzd29yZCc7XG4gICAgfTtcblxuICAgIF90aGlzLl90b2dnbGUgPSBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gX3JlZjIuZWxlbWVudCxcbiAgICAgICAgICBidXR0b24gPSBfcmVmMi5idXR0b247IC8vIHRvZ2dsZSBhY3Rpb24gbXVzdCBjb21lIGJlZm9yZSBxdWVyeWluZyB0aGUgY2xhc3NMaXN0XG5cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShfdGhpcy5vcHRpb25zLnBhc3N3b3JkSXNWaXNpYmxlKTtcbiAgICAgIHZhciBwYXNzd29yZElzVmlzaWJsZSA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKF90aGlzLm9wdGlvbnMucGFzc3dvcmRJc1Zpc2libGUpO1xuICAgICAgdmFyIGljb25WaXNpYmlsaXR5T24gPSBidXR0b24ucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnN2Z0ljb25WaXNpYmlsaXR5T24pO1xuICAgICAgdmFyIGljb25WaXNpYmlsaXR5T2ZmID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zdmdJY29uVmlzaWJpbGl0eU9mZik7XG4gICAgICB2YXIgaW5wdXQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclBhc3N3b3JkRmllbGQpO1xuICAgICAgdmFyIHNlbGVjdG9yUGFzc3dvcmRWaXNpYmlsaXR5VG9vbHRpcCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yUGFzc3dvcmRWaXNpYmlsaXR5VG9vbHRpcCk7XG5cbiAgICAgIF90aGlzLl9zZXRJY29uVmlzaWJpbGl0eSh7XG4gICAgICAgIGljb25WaXNpYmlsaXR5T246IGljb25WaXNpYmlsaXR5T24sXG4gICAgICAgIGljb25WaXNpYmlsaXR5T2ZmOiBpY29uVmlzaWJpbGl0eU9mZixcbiAgICAgICAgcGFzc3dvcmRJc1Zpc2libGU6IHBhc3N3b3JkSXNWaXNpYmxlLFxuICAgICAgICBzZWxlY3RvclBhc3N3b3JkVmlzaWJpbGl0eVRvb2x0aXA6IHNlbGVjdG9yUGFzc3dvcmRWaXNpYmlsaXR5VG9vbHRpcFxuICAgICAgfSk7XG5cbiAgICAgIGlucHV0LnR5cGUgPSBwYXNzd29yZElzVmlzaWJsZSA/ICd0ZXh0JyA6ICdwYXNzd29yZCc7XG4gICAgfTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0b2dnbGVWaXNpYmlsaXR5QnV0dG9uID0gZXZlbnRNYXRjaGVzKGV2ZW50LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yUGFzc3dvcmRWaXNpYmlsaXR5QnV0dG9uKTtcblxuICAgICAgaWYgKHRvZ2dsZVZpc2liaWxpdHlCdXR0b24pIHtcbiAgICAgICAgX3RoaXMuX3RvZ2dsZSh7XG4gICAgICAgICAgZWxlbWVudDogX2VsZW1lbnQsXG4gICAgICAgICAgYnV0dG9uOiB0b2dnbGVWaXNpYmlsaXR5QnV0dG9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIE9iamVjdCBjb250YWluaW5nIHNlbGVjdG9ycyBhbmQgdmlzaWJpbGl0eSBzdGF0dXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqLmljb25WaXNpYmlsaXR5T24gLSBUaGUgZWxlbWVudCBmdW5jdGlvbmluZyBhc1xuICAgKiB0aGUgU1ZHIGljb24gZm9yIHZpc2liaWxpdHkgb25cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqLmljb25WaXNpYmlsaXR5T2ZmIC0gVGhlIGVsZW1lbnQgZnVuY3Rpb25pbmcgYXNcbiAgICogdGhlIFNWRyBpY29uIGZvciB2aXNpYmlsaXR5IG9mZlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9iai5wYXNzd29yZElzVmlzaWJsZSAtIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwYXNzd29yZCBpbiB0aGVcbiAgICogaW5wdXQgZmllbGRcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVGV4dElucHV0LCBudWxsLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIElmIGBvcHRpb25zYCBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLFxuICAgICAqIHtAbGlua2NvZGUgVGV4dElucHV0LmNyZWF0ZSAuY3JlYXRlKCl9LFxuICAgICAqIG9yIHtAbGlua2NvZGUgVGV4dElucHV0LmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmdcbiAgICAgKiBjcmVhdGVkIGFuZCBob3cge0BsaW5rY29kZSBUZXh0SW5wdXQuaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JJbml0IFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0ZXh0IGlucHV0IFVJcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtdGV4dC1pbnB1dF0nLFxuICAgICAgICBzZWxlY3RvclBhc3N3b3JkRmllbGQ6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS10ZXh0LWlucHV0W2RhdGEtdG9nZ2xlLXBhc3N3b3JkLXZpc2liaWxpdHldXCIpLFxuICAgICAgICBzZWxlY3RvclBhc3N3b3JkVmlzaWJpbGl0eUJ1dHRvbjogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXRleHQtaW5wdXQtLXBhc3N3b3JkX192aXNpYmlsaXR5X190b2dnbGVcIiksXG4gICAgICAgIHNlbGVjdG9yUGFzc3dvcmRWaXNpYmlsaXR5VG9vbHRpcDogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXRleHQtaW5wdXQtLXBhc3N3b3JkX192aXNpYmlsaXR5X190b2dnbGUgPiAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1hc3Npc3RpdmUtdGV4dFwiKSxcbiAgICAgICAgcGFzc3dvcmRJc1Zpc2libGU6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXRleHQtaW5wdXQtLXBhc3N3b3JkLXZpc2libGVcIiksXG4gICAgICAgIHN2Z0ljb25WaXNpYmlsaXR5T246IFwic3ZnLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1pY29uLS12aXNpYmlsaXR5LW9uXCIpLFxuICAgICAgICBzdmdJY29uVmlzaWJpbGl0eU9mZjogXCJzdmcuXCIuY29uY2F0KHByZWZpeCwgXCItLWljb24tLXZpc2liaWxpdHktb2ZmXCIpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCB0ZXh0IGlucHV0IFVJIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtXZWFrTWFwfVxuICAgICAqL1xuXG4gIH1dKTtcblxuICBUZXh0SW5wdXQuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBUZXh0SW5wdXQ7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBoYW5kbGVzKSk7XG5cbmV4cG9ydCB7IFRleHRJbnB1dCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGV2ZW50TWF0Y2hlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZXZlbnQtbWF0Y2hlcyc7XG5cbnZhciBUaWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKFRpbGUsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUaWxlKTtcbiAgLyoqXG4gICAqIFRpbGUuXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGFuIFRpbGUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gVGlsZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLl9nZXRDbGFzcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgdHlwZU9iaiA9IHtcbiAgICAgICAgZXhwYW5kYWJsZTogX3RoaXMub3B0aW9ucy5jbGFzc0V4cGFuZGVkVGlsZSxcbiAgICAgICAgY2xpY2thYmxlOiBfdGhpcy5vcHRpb25zLmNsYXNzQ2xpY2thYmxlVGlsZSxcbiAgICAgICAgc2VsZWN0YWJsZTogX3RoaXMub3B0aW9ucy5jbGFzc1NlbGVjdGFibGVUaWxlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHR5cGVPYmpbdHlwZV07XG4gICAgfTtcblxuICAgIF90aGlzLl9ob29rQWN0aW9ucyA9IGZ1bmN0aW9uICh0aWxlQ2xhc3MpIHtcbiAgICAgIHZhciBpc0V4cGFuZGFibGUgPSBfdGhpcy50aWxlVHlwZSA9PT0gJ2V4cGFuZGFibGUnO1xuXG4gICAgICBpZiAoaXNFeHBhbmRhYmxlKSB7XG4gICAgICAgIHZhciBhYm92ZVRoZUZvbGQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvckFib3ZlVGhlRm9sZCk7XG5cbiAgICAgICAgdmFyIGdldFN0eWxlID0gX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoX3RoaXMuZWxlbWVudCwgbnVsbCk7XG5cbiAgICAgICAgdmFyIHRpbGVQYWRkaW5nVG9wID0gcGFyc2VJbnQoZ2V0U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSwgMTApO1xuICAgICAgICB2YXIgdGlsZVBhZGRpbmdCb3R0b20gPSBwYXJzZUludChnZXRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG4gICAgICAgIHZhciB0aWxlUGFkZGluZyA9IHRpbGVQYWRkaW5nVG9wICsgdGlsZVBhZGRpbmdCb3R0b207XG5cbiAgICAgICAgaWYgKGFib3ZlVGhlRm9sZCkge1xuICAgICAgICAgIF90aGlzLnRpbGVIZWlnaHQgPSBfdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICBfdGhpcy5hdGZIZWlnaHQgPSBhYm92ZVRoZUZvbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgdGlsZVBhZGRpbmc7XG4gICAgICAgICAgX3RoaXMuZWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSBcIlwiLmNvbmNhdChfdGhpcy5hdGZIZWlnaHQsIFwicHhcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoX3RoaXMub3B0aW9ucy5jbGFzc0V4cGFuZGVkVGlsZSkpIHtcbiAgICAgICAgICBfdGhpcy5fc2V0VGlsZUhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGV2ZW50TWF0Y2hlcyhldnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUaWxlSW5wdXQpO1xuXG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICBfdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUodGlsZUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4cGFuZGFibGUpIHtcbiAgICAgICAgICBfdGhpcy5fc2V0VGlsZUhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRpbGVJbnB1dCk7XG5cbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gMTMgfHwgZXZ0LndoaWNoID09PSAzMikge1xuICAgICAgICAgICAgaWYgKCFpc0V4cGFuZGFibGUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKHRpbGVDbGFzcyk7XG5cbiAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9ICFpbnB1dC5jaGVja2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLl9zZXRUaWxlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzRXhwYW5kZWQgPSBfdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhfdGhpcy5vcHRpb25zLmNsYXNzRXhwYW5kZWRUaWxlKTtcblxuICAgICAgX3RoaXMuZWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSBpc0V4cGFuZGVkID8gXCJcIi5jb25jYXQoX3RoaXMudGlsZUhlaWdodCwgXCJweFwiKSA6IFwiXCIuY29uY2F0KF90aGlzLmF0ZkhlaWdodCwgXCJweFwiKTtcbiAgICB9O1xuXG4gICAgX3RoaXMudGlsZVR5cGUgPSBfdGhpcy5lbGVtZW50LmRhdGFzZXQudGlsZTtcbiAgICBfdGhpcy50aWxlSGVpZ2h0ID0gMDsgLy8gVHJhY2tzIGV4cGFuZGFibGUgdGlsZSBoZWlnaHRcblxuICAgIF90aGlzLmF0ZkhlaWdodCA9IDA7IC8vIFRyYWNrcyBhYm92ZSB0aGUgZm9sZCBoZWlnaHRcblxuICAgIF90aGlzLl9ob29rQWN0aW9ucyhfdGhpcy5fZ2V0Q2xhc3MoX3RoaXMudGlsZVR5cGUpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaWxlLCBbe1xuICAgIGtleTogXCJyZWxlYXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUaWxlLnByb3RvdHlwZSksIFwicmVsZWFzZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBUaWxlIFVJIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtXZWFrTWFwfVxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBvdmVycmlkZW4gZm9yIHRoZSBpbnN0YW5jZSBiZWluZyBjcmVhdGVkLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIFRpbGUgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS10aWxlXScsXG4gICAgICAgIHNlbGVjdG9yQWJvdmVUaGVGb2xkOiAnW2RhdGEtdGlsZS1hdGZdJyxcbiAgICAgICAgc2VsZWN0b3JUaWxlSW5wdXQ6ICdbZGF0YS10aWxlLWlucHV0XScsXG4gICAgICAgIGNsYXNzRXhwYW5kZWRUaWxlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10aWxlLS1pcy1leHBhbmRlZFwiKSxcbiAgICAgICAgY2xhc3NDbGlja2FibGVUaWxlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10aWxlLS1pcy1jbGlja2VkXCIpLFxuICAgICAgICBjbGFzc1NlbGVjdGFibGVUaWxlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10aWxlLS1pcy1zZWxlY3RlZFwiKVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBUaWxlLmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gVGlsZTtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlTZWFyY2gpKTtcblxuZXhwb3J0IGRlZmF1bHQgVGlsZTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBoYW5kbGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2hhbmRsZXMnO1xuaW1wb3J0IGV2ZW50TWF0Y2hlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZXZlbnQtbWF0Y2hlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcblxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbnZhciBUb29sYmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKFRvb2xiYXIsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUb29sYmFyKTtcbiAgLyoqXG4gICAqIFRvb2xiYXIuXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYW4gdG9vbGJhci5cbiAgICovXG5cblxuICBmdW5jdGlvbiBUb29sYmFyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbGJhcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFfdGhpcy5lbGVtZW50LmRhdGFzZXQudGFibGVUYXJnZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlcmUgaXMgbm8gdGFibGUgYm91bmQgdG8gdGhpcyB0b29sYmFyIScpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJvdW5kVGFibGUgPSBfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5lbGVtZW50LmRhdGFzZXQudGFibGVUYXJnZXQpO1xuXG4gICAgICB2YXIgcm93SGVpZ2h0QnRucyA9IF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yUm93SGVpZ2h0KTtcblxuICAgICAgaWYgKHJvd0hlaWdodEJ0bnMpIHtcbiAgICAgICAgX3RoaXMubWFuYWdlKG9uKHJvd0hlaWdodEJ0bnMsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzLl9oYW5kbGVSb3dIZWlnaHRDaGFuZ2UoZXZlbnQsIGJvdW5kVGFibGUpO1xuICAgICAgICB9KSk7IC8vIHRvQXJyYXkodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNlbGVjdG9yUm93SGVpZ2h0KSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAvLyAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHsgdGhpcy5faGFuZGxlUm93SGVpZ2h0Q2hhbmdlKGV2ZW50LCBib3VuZFRhYmxlKTsgfSk7XG4gICAgICAgIC8vIH0pO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBfdGhpcy5faGFuZGxlS2V5RG93bihldnQpO1xuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrKGV2dCk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRvZ2dsaW5nIG9mIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgdG9vbGJhciBzZWFyY2ggaW5wdXRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRyaWdnZXJpbmcgdGhpcyBtZXRob2QuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2xiYXIsIFt7XG4gICAga2V5OiBcIl9oYW5kbGVEb2N1bWVudENsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVEb2N1bWVudENsaWNrKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHNlYXJjaElucHV0ID0gZXZlbnRNYXRjaGVzKGV2ZW50LCB0aGlzLm9wdGlvbnMuc2VsZWN0b3JTZWFyY2gpO1xuICAgICAgdmFyIGlzT2ZTZWxmU2VhcmNoSW5wdXQgPSBzZWFyY2hJbnB1dCAmJiB0aGlzLmVsZW1lbnQuY29udGFpbnMoc2VhcmNoSW5wdXQpO1xuXG4gICAgICBpZiAoaXNPZlNlbGZTZWFyY2hJbnB1dCkge1xuICAgICAgICB2YXIgc2hvdWxkQmVPcGVuID0gaXNPZlNlbGZTZWFyY2hJbnB1dCAmJiAhdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuY2xhc3NTZWFyY2hBY3RpdmUpO1xuICAgICAgICBzZWFyY2hJbnB1dC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMub3B0aW9ucy5jbGFzc1NlYXJjaEFjdGl2ZSwgc2hvdWxkQmVPcGVuKTtcblxuICAgICAgICBpZiAoc2hvdWxkQmVPcGVuKSB7XG4gICAgICAgICAgc2VhcmNoSW5wdXQucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRDb21wb25lbnRFbGVtZW50ID0gZXZlbnRNYXRjaGVzKGV2ZW50LCB0aGlzLm9wdGlvbnMuc2VsZWN0b3JJbml0KTtcbiAgICAgIHRvQXJyYXkodGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuc2VsZWN0b3JTZWFyY2gpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghdGFyZ2V0Q29tcG9uZW50RWxlbWVudCB8fCAhdGFyZ2V0Q29tcG9uZW50RWxlbWVudC5jb250YWlucyhpdGVtKSkge1xuICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZShfdGhpczIub3B0aW9ucy5jbGFzc1NlYXJjaEFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRvZ2dsaW5nIG9mIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgdG9vbGJhciBzZWFyY2ggaW5wdXQgdmlhIHRoZSBrZXlib2FyZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUtleURvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgIHZhciBzZWFyY2hJbnB1dCA9IGV2ZW50TWF0Y2hlcyhldmVudCwgdGhpcy5vcHRpb25zLnNlbGVjdG9yU2VhcmNoKTtcblxuICAgICAgaWYgKHNlYXJjaElucHV0ICYmIGV2ZW50LndoaWNoID09PSAyNykge1xuICAgICAgICBzZWFyY2hJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jbGFzc1NlYXJjaEFjdGl2ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdG9nZ2xpbmcgb2YgdGhlIHJvdyBoZWlnaHQgb2YgdGhlIGFzc29jaWF0ZWQgdGFibGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdHJpZ2dlcmluZyB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZFRhYmxlIFRoZSB0YWJsZSBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2xiYXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlUm93SGVpZ2h0Q2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVSb3dIZWlnaHRDaGFuZ2UoZXZlbnQsIGJvdW5kVGFibGUpIHtcbiAgICAgIHZhciBfZXZlbnQkY3VycmVudFRhcmdldCQgPSBldmVudC5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0OmNoZWNrZWQnKSxcbiAgICAgICAgICB2YWx1ZSA9IF9ldmVudCRjdXJyZW50VGFyZ2V0JC52YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlID09PSAndGFsbCcpIHtcbiAgICAgICAgYm91bmRUYWJsZS5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jbGFzc1RhbGxSb3dzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kVGFibGUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY2xhc3NUYWxsUm93cyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIFRvb2xiYXIgVUkgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge1dlYWtNYXB9XG4gICAgICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqIElmIGBvcHRpb25zYCBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZWQuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdG9vbGJhciBpbnN0YW5jZXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9yU2VhcmNoIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBzZWFyY2ggaW5wdXRzIGluIGEgdG9vbGJhci5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JSb3dIZWlnaHQgVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSByb3cgaGVpZ2h0IGlucHV0cyBpbiBhIHRvb2xiYXIuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNsYXNzVGFsbFJvd3MgVGhlIENTUyBjbGFzcyBmb3IgbWFraW5nIHRhYmxlIHJvd3MgaW50byB0YWxsIHJvd3MuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNsYXNzU2VhcmNoQWN0aXZlIFRoZSBDU1MgY2xhc3MgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgc2VhcmNoIGlucHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS10b29sYmFyXScsXG4gICAgICAgIHNlbGVjdG9yU2VhcmNoOiAnW2RhdGEtdG9vbGJhci1zZWFyY2hdJyxcbiAgICAgICAgc2VsZWN0b3JSb3dIZWlnaHQ6ICdbZGF0YS1yb3ctaGVpZ2h0XScsXG4gICAgICAgIGNsYXNzVGFsbFJvd3M6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLXJlc3BvbnNpdmUtdGFibGUtLXRhbGxcIiksXG4gICAgICAgIGNsYXNzU2VhcmNoQWN0aXZlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10b29sYmFyLXNlYXJjaC0tYWN0aXZlXCIpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIFRvb2xiYXIuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBUb29sYmFyO1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeVNlYXJjaCwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBUb29sYmFyOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5U2VhcmNoIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LXNlYXJjaCc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL2V2ZW50LW1hdGNoZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5cbnZhciBUb29sdGlwU2ltcGxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKFRvb2x0aXBTaW1wbGUsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUb29sdGlwU2ltcGxlKTtcbiAgLyoqXG4gICAqIFNpbXBsZSBUb29sdGlwLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZ1bmN0aW9uaW5nIGFzIGEgdGV4dCBmaWVsZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBUb29sdGlwU2ltcGxlKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcFNpbXBsZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIF90aGlzLnRvb2x0aXBGYWRlT3V0ID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvb2x0aXBUcmlnZ2VyQnV0dG9uID0gX3RoaXMuZ2V0VG9vbHRpcFRyaWdnZXJCdXR0b24oKTtcblxuICAgICAgaWYgKHRvb2x0aXBUcmlnZ2VyQnV0dG9uKSB7XG4gICAgICAgIHRvb2x0aXBUcmlnZ2VyQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1Rvb2x0aXBWaXNpYmxlKTtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuXG4gICAgX3RoaXMuZ2V0VG9vbHRpcFRyaWdnZXJCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZWxlbWVudC5tYXRjaGVzKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUcmlnZ2VyQnV0dG9uKSA/IF90aGlzLmVsZW1lbnQgOiBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRyaWdnZXJCdXR0b24pO1xuICAgIH07XG5cbiAgICBfdGhpcy5hbGxvd1Rvb2x0aXBWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciB2aXNpYmxlID0gX3JlZi52aXNpYmxlO1xuXG4gICAgICB2YXIgdG9vbHRpcFRyaWdnZXJCdXR0b24gPSBfdGhpcy5nZXRUb29sdGlwVHJpZ2dlckJ1dHRvbigpO1xuXG4gICAgICBpZiAoIXRvb2x0aXBUcmlnZ2VyQnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgdG9vbHRpcFRyaWdnZXJCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5vcHRpb25zLmNsYXNzVG9vbHRpcEhpZGRlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b29sdGlwVHJpZ2dlckJ1dHRvbi5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NUb29sdGlwSGlkZGVuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIEVTQ1xuICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAyNykge1xuICAgICAgICBfdGhpcy5hbGxvd1Rvb2x0aXBWaXNpYmlsaXR5KHtcbiAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdG9vbHRpcFRyaWdnZXJCdXR0b24gPSBfdGhpcy5nZXRUb29sdGlwVHJpZ2dlckJ1dHRvbigpO1xuXG4gICAgICAgIGlmICh0b29sdGlwVHJpZ2dlckJ1dHRvbikge1xuICAgICAgICAgIHRvb2x0aXBUcmlnZ2VyQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1Rvb2x0aXBWaXNpYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnRvb2x0aXBGYWRlT3V0LmNhbmNlbCgpO1xuXG4gICAgICBfdGhpcy5hbGxvd1Rvb2x0aXBWaXNpYmlsaXR5KHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0b29sdGlwVHJpZ2dlckJ1dHRvbiA9IF90aGlzLmdldFRvb2x0aXBUcmlnZ2VyQnV0dG9uKCk7XG5cbiAgICAgIGlmICh0b29sdGlwVHJpZ2dlckJ1dHRvbikge1xuICAgICAgICB0b29sdGlwVHJpZ2dlckJ1dHRvbi5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NUb29sdGlwVmlzaWJsZSk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdtb3VzZWxlYXZlJywgX3RoaXMudG9vbHRpcEZhZGVPdXQpKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnZm9jdXNpbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50TWF0Y2hlcyhldmVudCwgX3RoaXMub3B0aW9ucy5zZWxlY3RvclRyaWdnZXJCdXR0b24pKSB7XG4gICAgICAgIF90aGlzLmFsbG93VG9vbHRpcFZpc2liaWxpdHkoe1xuICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2x0aXBTaW1wbGUsIG51bGwsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBUb29sdGlwU2ltcGxlLmNyZWF0ZSAuY3JlYXRlKCl9LFxuICAgICAqIG9yIHtAbGlua2NvZGUgVG9vbHRpcFNpbXBsZS5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nXG4gICAgICogY3JlYXRlZCBhbmQgaG93IHtAbGlua2NvZGUgVG9vbHRpcFNpbXBsZS5pbml0IC5pbml0KCl9IHdvcmtzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHNpbXBsZSB0b29sdGlwIFVJcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JJbml0OiAnW2RhdGEtdG9vbHRpcC1kZWZpbml0aW9uXSxbZGF0YS10b29sdGlwLWljb25dJyxcbiAgICAgICAgc2VsZWN0b3JUcmlnZ2VyQnV0dG9uOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tdG9vbHRpcF9fdHJpZ2dlci5cIikuY29uY2F0KHByZWZpeCwgXCItLXRvb2x0aXAtLWExMXlcIiksXG4gICAgICAgIGNsYXNzVG9vbHRpcEhpZGRlbjogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tdG9vbHRpcC0taGlkZGVuXCIpLFxuICAgICAgICBjbGFzc1Rvb2x0aXBWaXNpYmxlOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS10b29sdGlwLS12aXNpYmxlXCIpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBzaW1wbGUgdG9vbHRpcCBVSSBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSk7XG5cbiAgVG9vbHRpcFNpbXBsZS5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIFRvb2x0aXBTaW1wbGU7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBoYW5kbGVzKSk7XG5cbmV4cG9ydCB7IFRvb2x0aXBTaW1wbGUgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeUV2ZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2luaXQtY29tcG9uZW50LWJ5LWV2ZW50JztcbmltcG9ydCBldmVudGVkU2hvd0hpZGVTdGF0ZSBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9ldmVudGVkLXNob3ctaGlkZS1zdGF0ZSc7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9oYW5kbGVzJztcbmltcG9ydCBGbG9hdGluZ01lbnUsIHsgRElSRUNUSU9OX0xFRlQsIERJUkVDVElPTl9UT1AsIERJUkVDVElPTl9SSUdIVCwgRElSRUNUSU9OX0JPVFRPTSB9IGZyb20gJy4uL2Zsb2F0aW5nLW1lbnUvZmxvYXRpbmctbWVudSc7XG5pbXBvcnQgZ2V0TGF1bmNoaW5nRGV0YWlscyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvZ2V0LWxhdW5jaGluZy1kZXRhaWxzJztcbmltcG9ydCBvbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2Mvb24nO1xuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG1lbnVCb2R5IFRoZSBtZW51IGJvZHkgd2l0aCB0aGUgbWVudSBhcnJvdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZW51RGlyZWN0aW9uIFdoZXJlIHRoZSBmbG9hdGluZyBtZW51IG1lbnUgc2hvdWxkIGJlIHBsYWNlZCByZWxhdGl2ZSB0byB0aGUgdHJpZ2dlciBidXR0b24uXG4gKiBAcmV0dXJucyB7RmxvYXRpbmdNZW51fm9mZnNldH0gVGhlIGFkanVzdG1lbnQgb2YgdGhlIGZsb2F0aW5nIG1lbnUgcG9zaXRpb24sIHVwb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBtZW51IGFycm93LlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZ2V0TWVudU9mZnNldCA9IGZ1bmN0aW9uIGdldE1lbnVPZmZzZXQobWVudUJvZHksIG1lbnVEaXJlY3Rpb24pIHtcbiAgdmFyIF9ESVJFQ1RJT05fTEVGVCRESVJFQywgX0RJUkVDVElPTl9MRUZUJERJUkVDMjtcblxuICB2YXIgYXJyb3dTdHlsZSA9IG1lbnVCb2R5Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShtZW51Qm9keSwgJzpiZWZvcmUnKTtcbiAgdmFyIGFycm93UG9zaXRpb25Qcm9wID0gKF9ESVJFQ1RJT05fTEVGVCRESVJFQyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX0RJUkVDVElPTl9MRUZUJERJUkVDLCBESVJFQ1RJT05fTEVGVCwgJ3JpZ2h0JyksIF9kZWZpbmVQcm9wZXJ0eShfRElSRUNUSU9OX0xFRlQkRElSRUMsIERJUkVDVElPTl9UT1AsICdib3R0b20nKSwgX2RlZmluZVByb3BlcnR5KF9ESVJFQ1RJT05fTEVGVCRESVJFQywgRElSRUNUSU9OX1JJR0hULCAnbGVmdCcpLCBfZGVmaW5lUHJvcGVydHkoX0RJUkVDVElPTl9MRUZUJERJUkVDLCBESVJFQ1RJT05fQk9UVE9NLCAndG9wJyksIF9ESVJFQ1RJT05fTEVGVCRESVJFQylbbWVudURpcmVjdGlvbl07XG4gIHZhciBtZW51UG9zaXRpb25BZGp1c3RtZW50UHJvcCA9IChfRElSRUNUSU9OX0xFRlQkRElSRUMyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfRElSRUNUSU9OX0xFRlQkRElSRUMyLCBESVJFQ1RJT05fTEVGVCwgJ2xlZnQnKSwgX2RlZmluZVByb3BlcnR5KF9ESVJFQ1RJT05fTEVGVCRESVJFQzIsIERJUkVDVElPTl9UT1AsICd0b3AnKSwgX2RlZmluZVByb3BlcnR5KF9ESVJFQ1RJT05fTEVGVCRESVJFQzIsIERJUkVDVElPTl9SSUdIVCwgJ2xlZnQnKSwgX2RlZmluZVByb3BlcnR5KF9ESVJFQ1RJT05fTEVGVCRESVJFQzIsIERJUkVDVElPTl9CT1RUT00sICd0b3AnKSwgX0RJUkVDVElPTl9MRUZUJERJUkVDMilbbWVudURpcmVjdGlvbl07XG4gIHZhciB2YWx1ZXMgPSBbYXJyb3dQb3NpdGlvblByb3AsICdib3JkZXItYm90dG9tLXdpZHRoJ10ucmVkdWNlKGZ1bmN0aW9uIChvLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIE51bWJlcigoL14oW1xcZC0uXSspcHgkLy5leGVjKGFycm93U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSkgfHwgW10pWzFdKSkpO1xuICB9LCB7fSk7XG4gIHZhciBtYXJnaW4gPSAwO1xuXG4gIGlmIChtZW51RGlyZWN0aW9uICE9PSBESVJFQ1RJT05fQk9UVE9NKSB7XG4gICAgdmFyIHN0eWxlID0gbWVudUJvZHkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG1lbnVCb2R5KTtcbiAgICBtYXJnaW4gPSBOdW1iZXIoKC9eKFtcXGQtLl0rKXB4JC8uZXhlYyhzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpIHx8IFtdKVsxXSk7XG4gIH1cblxuICB2YWx1ZXNbYXJyb3dQb3NpdGlvblByb3BdID0gdmFsdWVzW2Fycm93UG9zaXRpb25Qcm9wXSB8fCAtNjsgLy8gSUUsIGV0Yy5cblxuICBpZiAoT2JqZWN0LmtleXModmFsdWVzKS5ldmVyeShmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhaXNOYU4odmFsdWVzW25hbWVdKTtcbiAgfSkpIHtcbiAgICB2YXIgYXJyb3dQb3NpdGlvbiA9IHZhbHVlc1thcnJvd1Bvc2l0aW9uUHJvcF0sXG4gICAgICAgIGJvcmRlckJvdHRvbVdpZHRoID0gdmFsdWVzWydib3JkZXItYm90dG9tLXdpZHRoJ107XG4gICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfSwgbWVudVBvc2l0aW9uQWRqdXN0bWVudFByb3AsIE1hdGguc3FydChNYXRoLnBvdyhib3JkZXJCb3R0b21XaWR0aCwgMikgKiAyKSAtIGFycm93UG9zaXRpb24gKyBtYXJnaW4gKiAobWVudURpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1RPUCA/IDIgOiAxKSk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKlxuICogS2V5IGNvZGVzIGZvciBhbGxvd2VkIGtleXMgdGhhdCB3aWxsIHRyaWdnZXIgb3BlbmluZyBhIHRvb2x0aXBcbiAqIEB0eXBlIHtJbnRlZ2VyW119XG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIGFsbG93ZWRPcGVuS2V5cyA9IFszMiwgMTNdO1xuXG52YXIgVG9vbHRpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhUb29sdGlwLCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVG9vbHRpcCk7XG4gIC8qKlxuICAgKiBUb29sdGlwLlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBUb29sdGlwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIF90aGlzLl9oYXNDb250ZXh0TWVudSA9IGZhbHNlO1xuXG4gICAgX3RoaXMuX2hvb2tPbihlbGVtZW50KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQSBmbGFnIHRvIGRldGVjdCBpZiBgb25jb250ZXh0bWVudWAgZXZlbnQgaXMgZmlyZWQgcmlnaHQgYmVmb3JlIGBmb2N1c2AvYGJsdXJgIGV2ZW50cy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiBcImNyZWF0ZWRCeUV2ZW50XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgY2FsbGVkIHdoZW4gdGhpcyB3aWRnZXQgaXMgY3JlYXRlZCB1cG9uIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdHJpZ2dlcmluZyB0aGUgY3JlYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlZEJ5RXZlbnQoZXZlbnQpIHtcbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldCxcbiAgICAgICAgICB0eXBlID0gZXZlbnQudHlwZSxcbiAgICAgICAgICB3aGljaCA9IGV2ZW50LndoaWNoO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NsaWNrJyB8fCBhbGxvd2VkT3BlbktleXMuaW5jbHVkZXMod2hpY2gpKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNsaWNrKHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgZGV0YWlsczogZ2V0TGF1bmNoaW5nRGV0YWlscyhldmVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHNob3duL2hpZGRlbiBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGUgVGhlIG5ldyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIGV2ZW50IHRyaWdnaW5nIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGNhbGxlZCB3aGVuIGNoYW5nZSBpbiBzdGF0ZSBjb21wbGV0ZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGFuZ2VTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VTdGF0ZShzdGF0ZSwgZGV0YWlsLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCF0aGlzLnRvb2x0aXApIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJpYlRvb2x0aXBUYXJnZXQpKTtcblxuICAgICAgICBpZiAoIXRvb2x0aXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHRoZSB0YXJnZXQgdG9vbHRpcC4nKTtcbiAgICAgICAgfSAvLyBMYXppbHkgY3JlYXRlIGEgY29tcG9uZW50IGluc3RhbmNlIGZvciB0b29sdGlwXG5cblxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBGbG9hdGluZ01lbnUuY3JlYXRlKHRvb2x0aXAsIHtcbiAgICAgICAgICByZWZOb2RlOiB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgY2xhc3NTaG93bjogdGhpcy5vcHRpb25zLmNsYXNzU2hvd24sXG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLm9wdGlvbnMub2JqTWVudU9mZnNldCxcbiAgICAgICAgICBjb250ZW50Tm9kZTogdG9vbHRpcC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3RvckNvbnRlbnQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2hvb2tPbih0b29sdGlwKTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2godGhpcy50b29sdGlwKTtcbiAgICAgIH0gLy8gRGVsZWdhdGVzIHRoZSBhY3Rpb24gb2YgY2hhbmdpbmcgc3RhdGUgdG8gdGhlIHRvb2x0aXAuXG4gICAgICAvLyAoQW5kIHRodXMgdGhlIGJlZm9yZS9hZnRlciBzaG93bi9oaWRkZW4gZXZlbnRzIGFyZSBmaXJlZCBmcm9tIHRoZSB0b29sdGlwKVxuXG5cbiAgICAgIHRoaXMudG9vbHRpcC5jaGFuZ2VTdGF0ZShzdGF0ZSwgT2JqZWN0LmFzc2lnbihkZXRhaWwsIHtcbiAgICAgICAgZGVsZWdhdG9yTm9kZTogdGhpcy5lbGVtZW50XG4gICAgICB9KSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBzaG93IHRoZSB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhdHRhY2ggdGhlIGV2ZW50cyB0by5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hvb2tPblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaG9va09uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCB0aGUgX2hhbmRsZUNsaWNrIGZ1bmN0aW9uIGZvciBkaXNwbGF5aW5nIGEgdG9vbHRpcFxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZ0IC0gdXNlciBpbml0aWF0ZWQgZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7SW50ZWdlcltdfSBbYWxsb3dlZEtleXNdIC0gYWxsb3dlZCBrZXkgY29kZXMgdGhlIHVzZXIgbWF5IHByZXNzIHRvIG9wZW4gdGhlIHRvb2x0aXBcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuXG4gICAgICB2YXIgaGFuZGxlQ2xpY2tDb250ZXh0TWVudSA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrQ29udGV4dE1lbnUoZXZ0LCBhbGxvd2VkS2V5cykge1xuICAgICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IGV2dC5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgICAgdHlwZSA9IGV2dC50eXBlLFxuICAgICAgICAgICAgd2hpY2ggPSBldnQud2hpY2g7IC8vIEFsbG93IHVzZXIgdG8gdXNlIGBzcGFjZWAgb3IgYGVudGVyYCB0byBvcGVuIHRvb2x0aXBcblxuICAgICAgICBpZiAodHlwZW9mIGFsbG93ZWRLZXlzID09PSAndW5kZWZpbmVkJyB8fCBhbGxvd2VkS2V5cy5pbmNsdWRlcyh3aGljaCkpIHtcbiAgICAgICAgICB2YXIgaGFkQ29udGV4dE1lbnUgPSBfdGhpczIuX2hhc0NvbnRleHRNZW51O1xuICAgICAgICAgIF90aGlzMi5faGFzQ29udGV4dE1lbnUgPSB0eXBlID09PSAnY29udGV4dG1lbnUnO1xuXG4gICAgICAgICAgX3RoaXMyLl9oYW5kbGVDbGljayh7XG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGhhZENvbnRleHRNZW51OiBoYWRDb250ZXh0TWVudSxcbiAgICAgICAgICAgIGRldGFpbHM6IGdldExhdW5jaGluZ0RldGFpbHMoZXZ0KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm1hbmFnZShvbihlbGVtZW50LCAnY2xpY2snLCBoYW5kbGVDbGlja0NvbnRleHRNZW51LCBmYWxzZSkpO1xuXG4gICAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgIT09ICdCVVRUT04nKSB7XG4gICAgICAgIHRoaXMubWFuYWdlKG9uKHRoaXMuZWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBoYW5kbGVDbGlja0NvbnRleHRNZW51KGV2ZW50LCBhbGxvd2VkT3BlbktleXMpO1xuICAgICAgICB9LCBmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNsaWNrL2ZvY3VzIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyYW1zLnJlbGF0ZWRUYXJnZXQgVGhlIGVsZW1lbnQgdGhhdCBmb2N1cyB3ZW50IHRvLiAoRm9yIGBibHVyYCBldmVudClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnR5cGUgVGhlIGV2ZW50IHR5cGUgdHJpZ2dlcmluZyB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5oYWRDb250ZXh0TWVudVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuZGV0YWlscyBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDbGljayhfcmVmMikge1xuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSBfcmVmMi5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgIHR5cGUgPSBfcmVmMi50eXBlLFxuICAgICAgICAgIGhhZENvbnRleHRNZW51ID0gX3JlZjIuaGFkQ29udGV4dE1lbnUsXG4gICAgICAgICAgZGV0YWlscyA9IF9yZWYyLmRldGFpbHM7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGNsaWNrOiAnc2hvd24nLFxuICAgICAgICBrZXlkb3duOiAnc2hvd24nLFxuICAgICAgICBibHVyOiAnaGlkZGVuJyxcbiAgICAgICAgdG91Y2hsZWF2ZTogJ2hpZGRlbicsXG4gICAgICAgIHRvdWNoY2FuY2VsOiAnaGlkZGVuJ1xuICAgICAgfVt0eXBlXTtcbiAgICAgIHZhciBzaG91bGRQcmV2ZW50Q2xvc2U7XG5cbiAgICAgIGlmICh0eXBlID09PSAnYmx1cicpIHtcbiAgICAgICAgLy8gTm90ZTogU1ZHRWxlbWVudCBpbiBJRTExIGRvZXMgbm90IGhhdmUgYC5jb250YWlucygpYFxuICAgICAgICB2YXIgd2VudFRvU2VsZiA9IHJlbGF0ZWRUYXJnZXQgJiYgdGhpcy5lbGVtZW50LmNvbnRhaW5zICYmIHRoaXMuZWxlbWVudC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSB8fCB0aGlzLnRvb2x0aXAgJiYgdGhpcy50b29sdGlwLmVsZW1lbnQuY29udGFpbnMocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIHNob3VsZFByZXZlbnRDbG9zZSA9IGhhZENvbnRleHRNZW51IHx8IHdlbnRUb1NlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2hvdWxkUHJldmVudENsb3NlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoc3RhdGUsIGRldGFpbHMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS10b29sdGlwLXRyaWdnZXJdJyxcbiAgICAgICAgc2VsZWN0b3JDb250ZW50OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tdG9vbHRpcF9fY29udGVudFwiKSxcbiAgICAgICAgY2xhc3NTaG93bjogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tdG9vbHRpcC0tc2hvd25cIiksXG4gICAgICAgIGF0dHJpYlRvb2x0aXBUYXJnZXQ6ICdkYXRhLXRvb2x0aXAtdGFyZ2V0JyxcbiAgICAgICAgb2JqTWVudU9mZnNldDogZ2V0TWVudU9mZnNldCxcbiAgICAgICAgaW5pdEV2ZW50TmFtZXM6IFsnY2xpY2snLCAna2V5ZG93biddXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIFRvb2x0aXAuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBUb29sdGlwO1xufShtaXhpbihjcmVhdGVDb21wb25lbnQsIGluaXRDb21wb25lbnRCeUV2ZW50LCBldmVudGVkU2hvd0hpZGVTdGF0ZSwgaGFuZGxlcykpO1xuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IG1peGluIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9taXhpbic7XG5pbXBvcnQgY3JlYXRlQ29tcG9uZW50IGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2NyZWF0ZS1jb21wb25lbnQnO1xuaW1wb3J0IGluaXRDb21wb25lbnRCeVNlYXJjaCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9pbml0LWNvbXBvbmVudC1ieS1zZWFyY2gnO1xuaW1wb3J0IGhhbmRsZXMgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaGFuZGxlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL29uJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcblxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbnZhciBIZWFkZXJOYXYgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taXhpbikge1xuICBfaW5oZXJpdHMoSGVhZGVyTmF2LCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSGVhZGVyTmF2KTtcbiAgLyoqXG4gICAqIEhlYWRlciBuYXYuXG4gICAqIEBleHRlbmRzIENyZWF0ZUNvbXBvbmVudFxuICAgKiBAZXh0ZW5kcyBJbml0Q29tcG9uZW50QnlTZWFyY2hcbiAgICogQGV4dGVuZHMgSGFuZGxlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgYW4gaGVhZGVyIG5hdi5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclN1Ym1lbnVdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBzdWIgbWVudXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclN1Ym1lbnVMaW5rXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHRyaWdnZXIgYnV0dG9ucyBvZiBzdWIgbWVudXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclN1Ym1lbnVJdGVtXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHN1YiBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIEhlYWRlck5hdihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlck5hdik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMuZ2V0Q3VycmVudE5hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZm9jdXNlZCA9IF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsb3Nlc3QoX3RoaXMub3B0aW9ucy5zZWxlY3RvclN1Ym1lbnUpO1xuXG4gICAgICByZXR1cm4gZm9jdXNlZCAmJiBmb2N1c2VkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA/IGZvY3VzZWQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yU3VibWVudUxpbmspIDogbnVsbDtcbiAgICB9O1xuXG4gICAgX3RoaXMubmF2aWdhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0b0FycmF5KF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChfdGhpcy5vcHRpb25zLnNlbGVjdG9yU3VibWVudUxpbmspKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gX3RoaXMuZ2V0Q3VycmVudE5hdmlnYXRpb24oKTtcblxuICAgICAgdmFyIGdldE5leHRJdGVtID0gZnVuY3Rpb24gZ2V0TmV4dEl0ZW0ob2xkKSB7XG4gICAgICAgIHZhciBoYW5kbGVVbmRlcmZsb3cgPSBmdW5jdGlvbiBoYW5kbGVVbmRlcmZsb3coaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBpbmRleCArIChpbmRleCA+PSAwID8gMCA6IGxlbmd0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZU92ZXJmbG93ID0gZnVuY3Rpb24gaGFuZGxlT3ZlcmZsb3coaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBpbmRleCAtIChpbmRleCA8IGxlbmd0aCA/IDAgOiBsZW5ndGgpO1xuICAgICAgICB9OyAvLyBgaXRlbXMuaW5kZXhPZihvbGQpYCBtYXkgYmUgLTEgKFNjZW5hcmlvIG9mIG5vIHByZXZpb3VzIGZvY3VzKVxuXG5cbiAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5tYXgoaXRlbXMuaW5kZXhPZihvbGQpICsgZGlyZWN0aW9uLCAtMSk7XG4gICAgICAgIHJldHVybiBpdGVtc1toYW5kbGVVbmRlcmZsb3coaGFuZGxlT3ZlcmZsb3coaW5kZXgsIGl0ZW1zLmxlbmd0aCksIGl0ZW1zLmxlbmd0aCldO1xuICAgICAgfTtcblxuICAgICAgZ2V0TmV4dEl0ZW0oc3RhcnQpLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIF90aGlzLl9oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIga2V5Q29kZXMgPSB7XG4gICAgICAgIDM3OiBfdGhpcy5jb25zdHJ1Y3Rvci5OQVZJR0FURS5CQUNLV0FSRCxcbiAgICAgICAgLy8gbGVmdCBhcnJvd1xuICAgICAgICAzOTogX3RoaXMuY29uc3RydWN0b3IuTkFWSUdBVEUuRk9SV0FSRCAvLyByaWdodCBhcnJvd1xuXG4gICAgICB9O1xuICAgICAgdmFyIGtleUNvZGVNYXRjaGVzID0ga2V5Q29kZXNbZXZlbnQud2hpY2hdO1xuXG4gICAgICBpZiAoa2V5Q29kZU1hdGNoZXMpIHtcbiAgICAgICAgX3RoaXMubmF2aWdhdGUoa2V5Q29kZU1hdGNoZXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ2tleWRvd24nLCBfdGhpcy5faGFuZGxlS2V5RG93bikpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWFwIGFzc29jaWF0aW5nIERPTSBlbGVtZW50IGFuZCBIZWFkZXIgaW5zdGFuY2UuXG4gICAqIEBtZW1iZXIgSGVhZGVyTmF2LmNvbXBvbmVudHNcbiAgICogQHR5cGUge1dlYWtNYXB9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhlYWRlck5hdiwgbnVsbCwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBIZWFkZXJOYXYuY3JlYXRlIC5jcmVhdGUoKX0sIG9yXG4gICAgICoge0BsaW5rY29kZSBIZWFkZXJOYXYuaW5pdCAuaW5pdCgpfSxcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBvdmVycmlkZW4gZm9yIHRoZSBpbnN0YW5jZSBiZWluZyBjcmVhdGUgYW5kXG4gICAgICogaG93IHtAbGlua2NvZGUgSGVhZGVyTmF2LmluaXQgLmluaXQoKX0gd29ya3MuXG4gICAgICogQG1lbWJlciBIZWFkZXJOYXYub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgZGF0YSBhdHRyaWJ1dGUgdG8gZmluZCBzaWRlIG5hdnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclN1Ym1lbnVdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBzdWIgbWVudXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclN1Ym1lbnVMaW5rXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHRyaWdnZXIgYnV0dG9ucyBvZiBzdWIgbWVudXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclN1Ym1lbnVJdGVtXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIHN1YiBtZW51IGl0ZW1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS1oZWFkZXItbmF2XScsXG4gICAgICAgIHNlbGVjdG9yTmF2S2luZDogJ1tkYXRhLWhlYWRlci1uYXYta2luZF0nLFxuICAgICAgICBzZWxlY3RvclN1Ym1lbnU6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1oZWFkZXJfX3N1Ym1lbnVcIiksXG4gICAgICAgIHNlbGVjdG9yU3VibWVudUxpbms6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1oZWFkZXJfX21lbnUtdGl0bGVcIiksXG4gICAgICAgIHNlbGVjdG9yU3VibWVudUl0ZW06IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1oZWFkZXJfX21lbnUtdGl0bGUgPiAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1oZWFkZXJfX21lbnUtaXRlbVwiKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW51bSBmb3IgbmF2aWdhdGluZyBiYWNrd2FyZC9mb3J3YXJkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIgSGVhZGVyLk5BVklHQVRFXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkFDS1dBUkQgTmF2aWdhdGluZyBiYWNrd2FyZC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRk9SV0FSRCBOYXZpZ2F0aW5nIGZvcndhcmQuXG4gICAgICovXG5cbiAgfV0pO1xuXG4gIEhlYWRlck5hdi5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgSGVhZGVyTmF2Lk5BVklHQVRFID0ge1xuICAgIEJBQ0tXQVJEOiAtMSxcbiAgICBGT1JXQVJEOiAxXG4gIH07XG4gIHJldHVybiBIZWFkZXJOYXY7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBoYW5kbGVzKSk7XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlck5hdjsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBoYW5kbGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2hhbmRsZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9zZXR0aW5ncyc7XG5pbXBvcnQgZXZlbnRNYXRjaGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9ldmVudC1tYXRjaGVzJztcblxudmFyIGZvckVhY2ggPSAvKiAjX19QVVJFX18gKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbn0oKTtcblxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbnZhciBIZWFkZXJTdWJtZW51ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKEhlYWRlclN1Ym1lbnUsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihIZWFkZXJTdWJtZW51KTtcbiAgLyoqXG4gICAqIFN1YiBtZW51cyBpbiBoZWFkZXIgbmF2LlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGEgc3VibWVudSBpbiBoZWFkZXIgbmF2LlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yVHJpZ2dlcl0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSB0cmlnZ2VyIGJ1dHRvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9ySXRlbV0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBtZW51IGl0ZW1zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXR0cmliRXhwYW5kZWRdIFRoZSBhdHRyaWJ1dGUgdGhhdCByZXByZXNlbnRzIHRoZSBleHBhbmRlZC9jb2xsYXBzZWQgc3RhdGUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gSGVhZGVyU3VibWVudShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlclN1Ym1lbnUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLl9nZXRBY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBpc0ZseW91dE1lbnUgPSBldmVudE1hdGNoZXMoZXZlbnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JGbHlvdXRNZW51KTtcblxuICAgICAgaWYgKGlzRmx5b3V0TWVudSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY29uc3RydWN0b3IuYWN0aW9ucy5ERUxFR0FURV9UT19GTFlPVVRfTUVOVTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAzMjogX3RoaXMuY29uc3RydWN0b3IuYWN0aW9ucy5UT0dHTEVfU1VCTUVOVV9XSVRIX0ZPQ1VTLFxuICAgICAgICAgICAgLy8gc3BhY2UgYmFyXG4gICAgICAgICAgICAxMzogX3RoaXMuY29uc3RydWN0b3IuYWN0aW9ucy5UT0dHTEVfU1VCTUVOVV9XSVRIX0ZPQ1VTLFxuICAgICAgICAgICAgLy8gZW50ZXJcbiAgICAgICAgICAgIDI3OiBfdGhpcy5jb25zdHJ1Y3Rvci5hY3Rpb25zLkNMT1NFX1NVQk1FTlUgLy8gZXNjXG4gICAgICAgICAgICAvLyBwb3NzaWJsZSBhcnJvdyBrZXlzXG5cbiAgICAgICAgICB9W2V2ZW50LndoaWNoXTtcblxuICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50TWF0Y2hlcyhldmVudCwgX3RoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW0pID8gX3RoaXMuY29uc3RydWN0b3IuYWN0aW9ucy5DTE9TRV9TVUJNRU5VIDogbnVsbDtcblxuICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpc09mU2VsZiA9IF90aGlzLmVsZW1lbnQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpc09mU2VsZiA/IG51bGwgOiBfdGhpcy5jb25zdHJ1Y3Rvci5hY3Rpb25zLkNMT1NFX1NVQk1FTlU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5jb25zdHJ1Y3Rvci5hY3Rpb25zLk9QRU5fU1VCTUVOVTtcblxuICAgICAgICBjYXNlICdtb3VzZWxlYXZlJzpcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY29uc3RydWN0b3IuYWN0aW9ucy5DTE9TRV9TVUJNRU5VO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLl9nZXROZXdTdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUcmlnZ2VyKTtcblxuICAgICAgdmFyIGlzRXhwYW5kZWQgPSB0cmlnZ2VyLmdldEF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkV4cGFuZGVkKSA9PT0gJ3RydWUnO1xuXG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlIF90aGlzLmNvbnN0cnVjdG9yLmFjdGlvbnMuQ0xPU0VfU1VCTUVOVTpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSBfdGhpcy5jb25zdHJ1Y3Rvci5hY3Rpb25zLk9QRU5fU1VCTUVOVTpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIF90aGlzLmNvbnN0cnVjdG9yLmFjdGlvbnMuVE9HR0xFX1NVQk1FTlVfV0lUSF9GT0NVUzpcbiAgICAgICAgICByZXR1cm4gIWlzRXhwYW5kZWQ7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gaXNFeHBhbmRlZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX3NldFN0YXRlID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBzaG91bGRCZUV4cGFuZGVkID0gX3JlZi5zaG91bGRCZUV4cGFuZGVkLFxuICAgICAgICAgIHNob3VsZEZvY3VzT25PcGVuID0gX3JlZi5zaG91bGRGb2N1c09uT3BlbjtcblxuICAgICAgdmFyIHRyaWdnZXIgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRyaWdnZXIpO1xuXG4gICAgICB0cmlnZ2VyLnNldEF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkV4cGFuZGVkLCBzaG91bGRCZUV4cGFuZGVkKTtcbiAgICAgIGZvckVhY2guY2FsbChfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoX3RoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW0pLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLnRhYkluZGV4ID0gc2hvdWxkQmVFeHBhbmRlZCA/IDAgOiAtMTtcbiAgICAgIH0pOyAvLyBmb2N1cyBmaXJzdCBzdWJtZW51IGl0ZW1cblxuICAgICAgaWYgKHNob3VsZEJlRXhwYW5kZWQgJiYgc2hvdWxkRm9jdXNPbk9wZW4pIHtcbiAgICAgICAgX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtKS5mb2N1cygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRDdXJyZW50TmF2aWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmb2N1c2VkID0gX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICByZXR1cm4gZm9jdXNlZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZm9jdXNlZC5tYXRjaGVzKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtKSA/IGZvY3VzZWQgOiBudWxsO1xuICAgIH07XG5cbiAgICBfdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBpdGVtcyA9IHRvQXJyYXkoX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtKSk7XG5cbiAgICAgIHZhciBzdGFydCA9IF90aGlzLmdldEN1cnJlbnROYXZpZ2F0aW9uKCkgfHwgX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JJdGVtU2VsZWN0ZWQpO1xuXG4gICAgICB2YXIgZ2V0TmV4dEl0ZW0gPSBmdW5jdGlvbiBnZXROZXh0SXRlbShvbGQpIHtcbiAgICAgICAgdmFyIGhhbmRsZVVuZGVyZmxvdyA9IGZ1bmN0aW9uIGhhbmRsZVVuZGVyZmxvdyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICsgKGluZGV4ID49IDAgPyAwIDogbGVuZ3RoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlT3ZlcmZsb3cgPSBmdW5jdGlvbiBoYW5kbGVPdmVyZmxvdyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4IC0gKGluZGV4IDwgbGVuZ3RoID8gMCA6IGxlbmd0aCk7XG4gICAgICAgIH07IC8vIGBpdGVtcy5pbmRleE9mKG9sZClgIG1heSBiZSAtMSAoU2NlbmFyaW8gb2Ygbm8gcHJldmlvdXMgZm9jdXMpXG5cblxuICAgICAgICB2YXIgaW5kZXggPSBNYXRoLm1heChpdGVtcy5pbmRleE9mKG9sZCkgKyBkaXJlY3Rpb24sIC0xKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zW2hhbmRsZVVuZGVyZmxvdyhoYW5kbGVPdmVyZmxvdyhpbmRleCwgaXRlbXMubGVuZ3RoKSwgaXRlbXMubGVuZ3RoKV07XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBjdXJyZW50ID0gZ2V0TmV4dEl0ZW0oc3RhcnQpOyBjdXJyZW50ICYmIGN1cnJlbnQgIT09IHN0YXJ0OyBjdXJyZW50ID0gZ2V0TmV4dEl0ZW0oY3VycmVudCkpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50Lm1hdGNoZXMoX3RoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW1IaWRkZW4pICYmICFjdXJyZW50LnBhcmVudE5vZGUubWF0Y2hlcyhfdGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbUhpZGRlbikgJiYgIWN1cnJlbnQubWF0Y2hlcyhfdGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbVNlbGVjdGVkKSkge1xuICAgICAgICAgIGN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5faGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JUcmlnZ2VyKTtcblxuICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbiA9IF90aGlzLl9nZXRBY3Rpb24oZXZlbnQpO1xuXG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBzaG91bGRCZUV4cGFuZGVkID0gX3RoaXMuX2dldE5ld1N0YXRlKGFjdGlvbik7XG5cbiAgICAgICAgX3RoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICBzaG91bGRCZUV4cGFuZGVkOiBzaG91bGRCZUV4cGFuZGVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5faGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHRyaWdnZXIgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5zZWxlY3RvclRyaWdnZXIpO1xuXG4gICAgICBpZiAoIXRyaWdnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aW9uID0gX3RoaXMuX2dldEFjdGlvbihldmVudCk7XG5cbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgY2FzZSBfdGhpcy5jb25zdHJ1Y3Rvci5hY3Rpb25zLkRFTEVHQVRFX1RPX0ZMWU9VVF9NRU5VOlxuICAgICAgICAgIC8vIGN1cnJlbnRseSB3ZSBkbyBub3QgaGF2ZSBhIHNjZW5hcmlvIHRoYXQgaGFuZGxlcyBmbHlvdXQgbWVudVxuICAgICAgICAgIC8vIGhhbmRsZUZseW91dE1lbnVcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gY3VycmVudGx5IHdlIGRvIG5vdCBoYXZlIGEgc2NlbmFyaW8gdGhhdCBvcGVucyBhIHN1Ym1lbnUgb24ga2V5ZG93blxuICAgICAgICAvLyBjYXNlIHRoaXMuY29uc3RydWN0b3IuYWN0aW9ucy5PUEVOX1NVQk1FTlU6XG5cbiAgICAgICAgY2FzZSBfdGhpcy5jb25zdHJ1Y3Rvci5hY3Rpb25zLkNMT1NFX1NVQk1FTlU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNob3VsZEJlRXhwYW5kZWQgPSBfdGhpcy5fZ2V0TmV3U3RhdGUoYWN0aW9uKTtcblxuICAgICAgICAgICAgX3RoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgc2hvdWxkQmVFeHBhbmRlZDogc2hvdWxkQmVFeHBhbmRlZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIF90aGlzLmNvbnN0cnVjdG9yLmFjdGlvbnMuVE9HR0xFX1NVQk1FTlVfV0lUSF9GT0NVUzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3Nob3VsZEJlRXhwYW5kZWQgPSBfdGhpcy5fZ2V0TmV3U3RhdGUoYWN0aW9uKTtcblxuICAgICAgICAgICAgX3RoaXMuX3NldFN0YXRlKHtcbiAgICAgICAgICAgICAgc2hvdWxkQmVFeHBhbmRlZDogX3Nob3VsZEJlRXhwYW5kZWQsXG4gICAgICAgICAgICAgIHNob3VsZEZvY3VzT25PcGVuOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gdHJpZ2dlci5nZXRBdHRyaWJ1dGUoX3RoaXMub3B0aW9ucy5hdHRyaWJFeHBhbmRlZCkgPT09ICd0cnVlJztcblxuICAgICAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgMzg6IF90aGlzLmNvbnN0cnVjdG9yLk5BVklHQVRFLkJBQ0tXQVJELFxuICAgICAgICAgICAgICAgIDQwOiBfdGhpcy5jb25zdHJ1Y3Rvci5OQVZJR0FURS5GT1JXQVJEXG4gICAgICAgICAgICAgIH1bZXZlbnQud2hpY2hdO1xuXG4gICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmQga2V5XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIGtleSBmcm9tIHNjcm9sbGluZyBwYWdlXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lbnVJdGVtcyA9IF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChfdGhpcy5vcHRpb25zLnNlbGVjdG9ySXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RNZW51SXRlbSA9IG1lbnVJdGVtc1ttZW51SXRlbXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNZW51SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZW51SXRlbS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBob21lIGtleVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50cyBrZXkgZnJvbSBzY3JvbGxpbmcgcGFnZVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRlbGVtZW50JHF1ZXJ5U2UgPSBfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoX3RoaXMub3B0aW9ucy5zZWxlY3Rvckl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMkZWxlbWVudCRxdWVyeVNlMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGVsZW1lbnQkcXVlcnlTZSwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE1lbnVJdGVtID0gX3RoaXMkZWxlbWVudCRxdWVyeVNlMlswXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RNZW51SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgIGZpcnN0TWVudUl0ZW0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzZSAzODogLy8gdXAgYXJyb3dcblxuICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAvLyBkb3duIGFycm93XG4gICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0ZShkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50cyBrZXlzIGZyb20gc2Nyb2xsaW5nIHBhZ2VcblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaGFzRm9jdXNPdXQgPSAoJ29uZm9jdXNvdXQnIGluIHdpbmRvdyk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgaGFzRm9jdXNPdXQgPyAnZm9jdXNvdXQnIDogJ2JsdXInLCBfdGhpcy5faGFuZGxlRXZlbnQsICFoYXNGb2N1c091dCkpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQsICdtb3VzZWVudGVyJywgX3RoaXMuX2hhbmRsZUV2ZW50KSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgJ21vdXNlbGVhdmUnLCBfdGhpcy5faGFuZGxlRXZlbnQpKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAnY2xpY2snLCBfdGhpcy5faGFuZGxlRXZlbnQpKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50LCAna2V5ZG93bicsIF90aGlzLl9oYW5kbGVLZXlEb3duKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIEhlYWRlclN1Ym1lbnUgaW5zdGFuY2UuXG4gICAqIEBtZW1iZXIgSGVhZGVyU3VibWVudS5jb21wb25lbnRzXG4gICAqIEB0eXBlIHtXZWFrTWFwfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhIZWFkZXJTdWJtZW51LCBudWxsLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgKiB7QGxpbmtjb2RlIEhlYWRlclN1Ym1lbnUuY3JlYXRlIC5jcmVhdGUoKX0sIG9yXG4gICAgICoge0BsaW5rY29kZSBIZWFkZXJTdWJtZW51LmluaXQgLmluaXQoKX0sXG4gICAgICogcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgb3ZlcnJpZGVuIGZvciB0aGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlIGFuZFxuICAgICAqIGhvdyB7QGxpbmtjb2RlIEhlYWRlclN1Ym1lbnUuaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAbWVtYmVyIEhlYWRlclN1Ym1lbnUub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgZGF0YSBhdHRyaWJ1dGUgdG8gZmluZCBzaWRlIG5hdnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclRyaWdnZXJdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgdHJpZ2dlciBidXR0b24uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3Rvckl0ZW1dIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgbWVudSBpdGVtcy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2F0dHJpYkV4cGFuZGVkXSBUaGUgYXR0cmlidXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZXhwYW5kZWQvY29sbGFwc2VkIHN0YXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS1oZWFkZXItc3VibWVudV0nLFxuICAgICAgICBzZWxlY3RvclRyaWdnZXI6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1oZWFkZXJfX21lbnUtdGl0bGVcIiksXG4gICAgICAgIHNlbGVjdG9ySXRlbTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLWhlYWRlcl9fbWVudSAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1oZWFkZXJfX21lbnUtaXRlbVwiKSxcbiAgICAgICAgYXR0cmliRXhwYW5kZWQ6ICdhcmlhLWV4cGFuZGVkJ1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW51bSBmb3IgbmF2aWdhdGluZyBiYWNrd2FyZC9mb3J3YXJkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIgSGVhZGVyU3VibWVudS5OQVZJR0FURVxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJBQ0tXQVJEIE5hdmlnYXRpbmcgYmFja3dhcmQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZPUldBUkQgTmF2aWdhdGluZyBmb3J3YXJkLlxuICAgICAqL1xuXG4gIH1dKTtcblxuICBIZWFkZXJTdWJtZW51LmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICBIZWFkZXJTdWJtZW51LmFjdGlvbnMgPSB7XG4gICAgQ0xPU0VfU1VCTUVOVTogJ0NMT1NFX1NVQk1FTlUnLFxuICAgIE9QRU5fU1VCTUVOVTogJ09QRU5fU1VCTUVOVScsXG4gICAgVE9HR0xFX1NVQk1FTlVfV0lUSF9GT0NVUzogJ1RPR0dMRV9TVUJNRU5VX1dJVEhfRk9DVVMnLFxuICAgIERFTEVHQVRFX1RPX0ZMWU9VVF9NRU5VOiAnREVMRUdBVEVfVE9fRkxZT1VUX01FTlUnXG4gIH07XG4gIEhlYWRlclN1Ym1lbnUuTkFWSUdBVEUgPSB7XG4gICAgQkFDS1dBUkQ6IC0xLFxuICAgIEZPUldBUkQ6IDFcbiAgfTtcbiAgcmV0dXJuIEhlYWRlclN1Ym1lbnU7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBoYW5kbGVzKSk7XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlclN1Ym1lbnU7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgbWl4aW4gZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL21peGluJztcbmltcG9ydCBjcmVhdGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvY3JlYXRlLWNvbXBvbmVudCc7XG5pbXBvcnQgaW5pdENvbXBvbmVudEJ5TGF1bmNoZXIgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktbGF1bmNoZXInO1xuaW1wb3J0IGV2ZW50ZWRTaG93SGlkZVN0YXRlIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2V2ZW50ZWQtc2hvdy1oaWRlLXN0YXRlJztcbmltcG9ydCBoYW5kbGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2hhbmRsZXMnO1xuaW1wb3J0IGV2ZW50ZWRTdGF0ZSBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9ldmVudGVkLXN0YXRlJztcbmltcG9ydCB0b2dnbGVBdHRyaWJ1dGUgZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXNjL3RvZ2dsZS1hdHRyaWJ1dGUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuXG52YXIgTmF2aWdhdGlvbk1lbnVQYW5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21peGluKSB7XG4gIF9pbmhlcml0cyhOYXZpZ2F0aW9uTWVudVBhbmVsLCBfbWl4aW4pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTmF2aWdhdGlvbk1lbnVQYW5lbCk7XG5cbiAgZnVuY3Rpb24gTmF2aWdhdGlvbk1lbnVQYW5lbCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF2aWdhdGlvbk1lbnVQYW5lbCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgX3RoaXMuY3JlYXRlZEJ5TGF1bmNoZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBpc0V4cGFuZGVkID0gIV90aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGlzRXhwYW5kZWQgPyAnY29sbGFwc2VkJyA6ICdleHBhbmRlZCc7XG4gICAgICBfdGhpcy50cmlnZ2VyQnV0dG9uID0gZXZlbnQuZGVsZWdhdGVUYXJnZXQ7XG5cbiAgICAgIF90aGlzLmNoYW5nZVN0YXRlKG5ld1N0YXRlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2hvdWxkU3RhdGVCZUNoYW5nZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZSA9PT0gJ2V4cGFuZGVkJyA9PT0gX3RoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hpZGRlbicpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB0b2dnbGVBdHRyaWJ1dGUoX3RoaXMuZWxlbWVudCwgJ2hpZGRlbicsIHN0YXRlICE9PSAnZXhwYW5kZWQnKTtcblxuICAgICAgaWYgKF90aGlzLnRyaWdnZXJCdXR0b24pIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXhwYW5kZWQnKSB7XG4gICAgICAgICAgdmFyIGZvY3VzYWJsZU1lbnVJdGVtcyA9IF90aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLnNlbGVjdG9yRm9jdXNhYmxlTWVudUl0ZW0pO1xuXG4gICAgICAgICAgaWYgKGZvY3VzYWJsZU1lbnVJdGVtcykge1xuICAgICAgICAgICAgZm9jdXNhYmxlTWVudUl0ZW1zLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsID0gc3RhdGUgPT09ICdleHBhbmRlZCcgPyBfdGhpcy50cmlnZ2VyQnV0dG9uLmdldEF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkxhYmVsQ29sbGFwc2UpIDogX3RoaXMudHJpZ2dlckJ1dHRvbi5nZXRBdHRyaWJ1dGUoX3RoaXMub3B0aW9ucy5hdHRyaWJMYWJlbEV4cGFuZCk7XG5cbiAgICAgICAgX3RoaXMudHJpZ2dlckJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKF90aGlzLm9wdGlvbnMuY2xhc3NOYXZpZ2F0aW9uTWVudVBhbmVsSGVhZGVyQWN0aW9uQWN0aXZlLCBzdGF0ZSA9PT0gJ2V4cGFuZGVkJyk7XG5cbiAgICAgICAgX3RoaXMudHJpZ2dlckJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG5cbiAgICAgICAgX3RoaXMudHJpZ2dlckJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgbGFiZWwpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTmF2aWdhdGlvbk1lbnVQYW5lbCwgbnVsbCwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBOYXZpZ2F0aW9uTWVudVBhbmVsLmNyZWF0ZSAuY3JlYXRlKCl9LCBvclxuICAgICAqIHtAbGlua2NvZGUgTmF2aWdhdGlvbk1lbnVQYW5lbC5pbml0IC5pbml0KCl9LFxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgYXJlIG92ZXJyaWRlbiBmb3IgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZSBhbmRcbiAgICAgKiBob3cge0BsaW5rY29kZSBOYXZpZ2F0aW9uTWVudVBhbmVsLmluaXQgLmluaXQoKX0gd29ya3MuXG4gICAgICogQG1lbWJlciBOYXZpZ2F0aW9uTWVudVBhbmVsLm9wdGlvbnNcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIENTUyBjbGFzcyB0byBmaW5kIHBvcHVwIG5hdnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYkluaXRUYXJnZXQgVGhlIGF0dHJpYnV0ZSBuYW1lIGluIHRoZSBsYXVuY2hlciBidXR0b25zIHRvIGZpbmQgdGFyZ2V0IHBvcHVwIG5hdi5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBpbml0RXZlbnROYW1lcyBUaGUgZXZlbnRzIHRoYXQgdGhlIGNvbXBvbmVudCB3aWxsIGhhbmRsZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdEV2ZW50TmFtZXM6IFsnY2xpY2snXSxcbiAgICAgICAgZXZlbnRCZWZvcmVFeHBhbmRlZDogJ25hdmlnYXRpb24tbWVudS1iZWluZy1leHBhbmRlZCcsXG4gICAgICAgIGV2ZW50QWZ0ZXJFeHBhbmRlZDogJ25hdmlnYXRpb24tbWVudS1leHBhbmRlZCcsXG4gICAgICAgIGV2ZW50QmVmb3JlQ29sbGFwc2VkOiAnbmF2aWdhdGlvbi1tZW51LWJlaW5nLWNvbGxhcHNlZCcsXG4gICAgICAgIGV2ZW50QWZ0ZXJDb2xsYXBzZWQ6ICduYXZpZ2F0aW9uLW1lbnUtY29sbGFwc2VkJyxcbiAgICAgICAgc2VsZWN0b3JGb2N1c2FibGVNZW51SXRlbTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLW5hdmlnYXRpb25fX2NhdGVnb3J5LXRvZ2dsZSwgLlwiKS5jb25jYXQocHJlZml4LCBcIi0tbmF2aWdhdGlvbi1saW5rXCIpLFxuICAgICAgICBjbGFzc05hdmlnYXRpb25NZW51UGFuZWxIZWFkZXJBY3Rpb25BY3RpdmU6IFwiXCIuY29uY2F0KHByZWZpeCwgXCItLWhlYWRlcl9fYWN0aW9uLS1hY3RpdmVcIiksXG4gICAgICAgIGF0dHJpYkxhYmVsRXhwYW5kOiAnZGF0YS1uYXZpZ2F0aW9uLW1lbnUtcGFuZWwtbGFiZWwtZXhwYW5kJyxcbiAgICAgICAgYXR0cmliTGFiZWxDb2xsYXBzZTogJ2RhdGEtbmF2aWdhdGlvbi1tZW51LXBhbmVsLWxhYmVsLWNvbGxhcHNlJ1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBOYXZpZ2F0aW9uTWVudVBhbmVsLmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gTmF2aWdhdGlvbk1lbnVQYW5lbDtcbn0obWl4aW4oY3JlYXRlQ29tcG9uZW50LCBpbml0Q29tcG9uZW50QnlMYXVuY2hlciwgZXZlbnRlZFNob3dIaWRlU3RhdGUsIGhhbmRsZXMsIGV2ZW50ZWRTdGF0ZSkpO1xuXG5leHBvcnQgeyBOYXZpZ2F0aW9uTWVudVBhbmVsIGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuaW1wb3J0IE5hdmlnYXRpb25NZW51UGFuZWwgZnJvbSAnLi9uYXZpZ2F0aW9uLW1lbnUtcGFuZWwnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5pbXBvcnQgZXZlbnRNYXRjaGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9ldmVudC1tYXRjaGVzJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcblxudmFyIE5hdmlnYXRpb25NZW51ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTmF2aWdhdGlvbk1lbnVQYW5lbCkge1xuICBfaW5oZXJpdHMoTmF2aWdhdGlvbk1lbnUsIF9OYXZpZ2F0aW9uTWVudVBhbmVsKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5hdmlnYXRpb25NZW51KTtcbiAgLyoqXG4gICAqIEEgbmF2aWdhdGlvbiBtZW51XG4gICAqIEBleHRlbmRzIE5hdmlnYXRpb25NZW51UGFuZWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGEgc2VsZWN0b3IuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JJbml0XSBUaGUgQ1NTIGNsYXNzIHRvIGZpbmQgbmF2aWdhdGlvblxuICAgKiBtZW51cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmF0dHJpYkluaXRUYXJnZXRdIFRoZSBhdHRyaWJ1dGUgbmFtZSBpbiB0aGVcbiAgICogbGF1bmNoZXIgYnV0dG9ucyB0byBmaW5kIHRhcmdldCBuYXZpZ2F0aW9uIG1lbnUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclNoZWxsTmF2U3VibWVudV0gVGhlIENTUyBzZWxlY3RvciBmb3IgYVxuICAgKiBuYXYgc3VibWVudVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JTaGVsbE5hdkxpbmtdIFRoZSBDU1Mgc2VsZWN0b3IgZm9yIGEgbmF2XG4gICAqIGxpbmtcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yU2hlbGxOYXZMaW5rQ3VycmVudF0gVGhlIENTUyBzZWxlY3RvciBmb3JcbiAgICogdGhlIGN1cnJlbnQgbmF2IGxpbmtcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yU2hlbGxOYXZJdGVtXSBUaGUgQ1NTIHNlbGVjdG9yIGZvciBhIG5hdlxuICAgKiBpdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclNoZWxsTmF2Q2F0ZWdvcnldIFRoZSBDU1Mgc2VsZWN0b3IgZm9yIGFcbiAgICogbmF2IGNhdGVnb3J5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc1NoZWxsTmF2SXRlbUFjdGl2ZV0gVGhlIENTUyBjbGFzcyBmb3IgdGhlXG4gICAqIGFjdGl2ZSBuYXYgaXRlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NTaGVsbE5hdkxpbmtDdXJyZW50XSBUaGUgQ1NTIGNsYXNzIGZvciB0aGVcbiAgICogY3VycmVudCBsYXYgbGlua1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NTaGVsbE5hdkNhdGVnb3J5RXhwYW5kZWRdIFRoZSBDU1MgY2xhc3NcbiAgICogZm9yIGFuIGV4cGFuZGVkIG5hdiBjYXRlZ29yeVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIE5hdmlnYXRpb25NZW51KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF2aWdhdGlvbk1lbnUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIF90aGlzLmdldEN1cnJlbnROYXZpZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH07XG5cbiAgICBfdGhpcy5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBpdGVtcyA9IF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoX3RoaXMub3B0aW9ucy5zZWxlY3RvckZvY3VzYWJsZU5hdkl0ZW1zKSk7XG5cbiAgICAgIHZhciBzdGFydCA9IF90aGlzLmdldEN1cnJlbnROYXZpZ2F0aW9uKCk7XG5cbiAgICAgIHZhciBnZXROZXh0SXRlbSA9IGZ1bmN0aW9uIGdldE5leHRJdGVtKG9sZCkge1xuICAgICAgICB2YXIgaGFuZGxlVW5kZXJmbG93ID0gZnVuY3Rpb24gaGFuZGxlVW5kZXJmbG93KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggKyAoaW5kZXggPj0gMCA/IDAgOiBsZW5ndGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVPdmVyZmxvdyA9IGZ1bmN0aW9uIGhhbmRsZU92ZXJmbG93KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggLSAoaW5kZXggPCBsZW5ndGggPyAwIDogbGVuZ3RoKTtcbiAgICAgICAgfTsgLy8gYGl0ZW1zLmluZGV4T2Yob2xkKWAgbWF5IGJlIC0xIChTY2VuYXJpbyBvZiBubyBwcmV2aW91cyBmb2N1cylcblxuXG4gICAgICAgIHZhciBpbmRleCA9IE1hdGgubWF4KGl0ZW1zLmluZGV4T2Yob2xkKSArIGRpcmVjdGlvbiwgLTEpO1xuICAgICAgICByZXR1cm4gaXRlbXNbaGFuZGxlVW5kZXJmbG93KGhhbmRsZU92ZXJmbG93KGluZGV4LCBpdGVtcy5sZW5ndGgpLCBpdGVtcy5sZW5ndGgpXTtcbiAgICAgIH07XG5cbiAgICAgIGdldE5leHRJdGVtKHN0YXJ0KS5mb2N1cygpO1xuICAgIH07XG5cbiAgICBfdGhpcy5faGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gaGFuZGxlIEVzY1xuICAgICAgdmFyIGlzRXhwYW5kZWQgPSAhX3RoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hpZGRlbicpO1xuXG4gICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3ICYmIGlzRXhwYW5kZWQpIHtcbiAgICAgICAgX3RoaXMuY2hhbmdlU3RhdGUoJ2NvbGxhcHNlZCcpO1xuXG4gICAgICAgIGlmIChfdGhpcy50cmlnZ2VyQnV0dG9uKSB7XG4gICAgICAgICAgX3RoaXMudHJpZ2dlckJ1dHRvbi5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBoYW5kbGUgdXAvZG93biBhcnJvdyBrZXlzXG5cblxuICAgICAgdmFyIG1hdGNoZXNOYXZTdWJtZW51ID0gZXZlbnRNYXRjaGVzKGV2ZW50LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yU2hlbGxOYXZTdWJtZW51KTtcbiAgICAgIHZhciBtYXRjaGVzU2hlbGxOYXZMaW5rID0gZXZlbnRNYXRjaGVzKGV2ZW50LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yU2hlbGxOYXZMaW5rKTtcblxuICAgICAgaWYgKCFtYXRjaGVzTmF2U3VibWVudSAmJiAhbWF0Y2hlc1NoZWxsTmF2TGluaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuYXZpZ2F0aW9uS2V5Q29kZXMgPSB7XG4gICAgICAgIDM4OiBfdGhpcy5jb25zdHJ1Y3Rvci5OQVZJR0FURS5CQUNLV0FSRCxcbiAgICAgICAgLy8gdXAgYXJyb3dcbiAgICAgICAgNDA6IF90aGlzLmNvbnN0cnVjdG9yLk5BVklHQVRFLkZPUldBUkQgLy8gZG93biBhcnJvd1xuXG4gICAgICB9O1xuICAgICAgdmFyIG5hdmlnYXRpb25LZXlDb2RlTWF0Y2hlcyA9IG5hdmlnYXRpb25LZXlDb2Rlc1tldmVudC53aGljaF07XG5cbiAgICAgIGlmIChuYXZpZ2F0aW9uS2V5Q29kZU1hdGNoZXMpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBhcnJvdyBrZXlzIGZyb20gc2Nyb2xsaW5nXG5cbiAgICAgICAgX3RoaXMubmF2aWdhdGUobmF2aWdhdGlvbktleUNvZGVNYXRjaGVzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX2hhbmRsZUZvY3VzT3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgbmV4dFRhcmdldElzT2ZTZWxmID0gX3RoaXMuZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSB8fCBldmVudC5yZWxhdGVkVGFyZ2V0ID09PSBfdGhpcy50cmlnZ2VyQnV0dG9uIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICB2YXIgb2xkVGFyZ2V0SXNPZlNlbGYgPSBfdGhpcy5lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG5cbiAgICAgIGlmIChvbGRUYXJnZXRJc09mU2VsZiAmJiAhbmV4dFRhcmdldElzT2ZTZWxmKSB7XG4gICAgICAgIF90aGlzLmNoYW5nZVN0YXRlKCdjb2xsYXBzZWQnKTtcblxuICAgICAgICBfdGhpcy50cmlnZ2VyQnV0dG9uLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmNoYW5nZU5hdlN1Ym1lbnVTdGF0ZSA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbWF0Y2hlc05hdlN1Ym1lbnUgPSBfcmVmLm1hdGNoZXNOYXZTdWJtZW51LFxuICAgICAgICAgIHNob3VsZEJlQ29sbGFwc2VkID0gX3JlZi5zaG91bGRCZUNvbGxhcHNlZDtcbiAgICAgIHZhciBzaGVsbE5hdkNhdGVnb3J5ID0gbWF0Y2hlc05hdlN1Ym1lbnUuY2xvc2VzdChfdGhpcy5vcHRpb25zLnNlbGVjdG9yU2hlbGxOYXZDYXRlZ29yeSk7XG5cbiAgICAgIGlmICghc2hlbGxOYXZDYXRlZ29yeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoZXNOYXZTdWJtZW51LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICFzaG91bGRCZUNvbGxhcHNlZCk7XG4gICAgICBzaGVsbE5hdkNhdGVnb3J5LmNsYXNzTGlzdC50b2dnbGUoX3RoaXMub3B0aW9ucy5jbGFzc1NoZWxsTmF2Q2F0ZWdvcnlFeHBhbmRlZCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNoZWxsTmF2Q2F0ZWdvcnkucXVlcnlTZWxlY3RvckFsbChfdGhpcy5vcHRpb25zLnNlbGVjdG9yU2hlbGxOYXZMaW5rKSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS50YWJJbmRleCA9ICFzaG91bGRCZUNvbGxhcHNlZCA/IDAgOiAtMTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5faGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBtYXRjaGVzTmF2U3VibWVudSA9IGV2ZW50TWF0Y2hlcyhldmVudCwgX3RoaXMub3B0aW9ucy5zZWxlY3RvclNoZWxsTmF2U3VibWVudSk7XG4gICAgICB2YXIgbWF0Y2hlc1NoZWxsTmF2TGluayA9IGV2ZW50TWF0Y2hlcyhldmVudCwgX3RoaXMub3B0aW9ucy5zZWxlY3RvclNoZWxsTmF2TGluayk7XG4gICAgICB2YXIgbWF0Y2hlc05lc3RlZFNoZWxsTmF2TGluayA9IGV2ZW50TWF0Y2hlcyhldmVudCwgX3RoaXMub3B0aW9ucy5zZWxlY3RvclNoZWxsTmVzdGVkTmF2TGluayk7XG5cbiAgICAgIGlmICghbWF0Y2hlc05hdlN1Ym1lbnUgJiYgIW1hdGNoZXNTaGVsbE5hdkxpbmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2hlc05lc3RlZFNoZWxsTmF2TGluaykge1xuICAgICAgICBfdG9Db25zdW1hYmxlQXJyYXkoX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JTaGVsbE5hdkxpbmtDdXJyZW50KSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKF90aGlzLm9wdGlvbnMuY2xhc3NTaGVsbE5hdkl0ZW1BY3RpdmUsIF90aGlzLm9wdGlvbnMuY2xhc3NTaGVsbE5hdkxpbmtDdXJyZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWF0Y2hlc05lc3RlZFNoZWxsTmF2TGluay5jbG9zZXN0KF90aGlzLm9wdGlvbnMuc2VsZWN0b3JTaGVsbE5hdk5lc3RlZENhdGVnb3J5KS5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NTaGVsbE5hdkl0ZW1BY3RpdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaGVzTmF2U3VibWVudSkge1xuICAgICAgICB2YXIgaXNFeHBhbmRlZCA9IG1hdGNoZXNOYXZTdWJtZW51LmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpID09PSAndHJ1ZSc7XG5cbiAgICAgICAgX3RoaXMuY2hhbmdlTmF2U3VibWVudVN0YXRlKHtcbiAgICAgICAgICBtYXRjaGVzTmF2U3VibWVudTogbWF0Y2hlc05hdlN1Ym1lbnUsXG4gICAgICAgICAgaXNFeHBhbmRlZDogaXNFeHBhbmRlZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaGVzU2hlbGxOYXZMaW5rKSB7XG4gICAgICAgIF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoX3RoaXMub3B0aW9ucy5zZWxlY3RvclNoZWxsTmF2TGlua0N1cnJlbnQpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1NoZWxsTmF2SXRlbUFjdGl2ZSwgX3RoaXMub3B0aW9ucy5jbGFzc1NoZWxsTmF2TGlua0N1cnJlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtYXRjaGVzU2hlbGxOYXZMaW5rLmNsb3Nlc3QoX3RoaXMub3B0aW9ucy5zZWxlY3RvclNoZWxsTmF2SXRlbSkuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzU2hlbGxOYXZJdGVtQWN0aXZlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKGVsZW1lbnQsICdjbGljaycsIF90aGlzLl9oYW5kbGVDbGljaykpO1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKGVsZW1lbnQsICdrZXlkb3duJywgX3RoaXMuX2hhbmRsZUtleURvd24pKTtcblxuICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaGlkZGVuJykgJiYgIV90aGlzLnRyaWdnZXJCdXR0b24uY29udGFpbnMoZXZlbnQudGFyZ2V0KSAmJiAhX3RoaXMuZWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgIF90aGlzLmNoYW5nZVN0YXRlKCdjb2xsYXBzZWQnKTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICB2YXIgaGFzRm9jdXNPdXQgPSAoJ29uZm9jdXNvdXQnIGluIHdpbmRvdyk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob24oX3RoaXMuZWxlbWVudCwgaGFzRm9jdXNPdXQgPyAnZm9jdXNvdXQnIDogJ2JsdXInLCBfdGhpcy5faGFuZGxlRm9jdXNPdXQsICFoYXNGb2N1c091dCkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH0gQ3VycmVudGx5IGhpZ2hsaWdodGVkIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5hdmlnYXRpb25NZW51LCBudWxsLCBbe1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgKiB7QGxpbmtjb2RlIE5hdmlnYXRpb25NZW51LmNyZWF0ZSAuY3JlYXRlKCl9LCBvclxuICAgICAqIHtAbGlua2NvZGUgTmF2aWdhdGlvbk1lbnUuaW5pdCAuaW5pdCgpfSxcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBvdmVycmlkZW4gZm9yIHRoZSBpbnN0YW5jZSBiZWluZyBjcmVhdGUgYW5kXG4gICAgICogaG93IHtAbGlua2NvZGUgTmF2aWdhdGlvbk1lbnUuaW5pdCAuaW5pdCgpfSB3b3Jrcy5cbiAgICAgKiBAbWVtYmVyIE5hdmlnYXRpb25NZW51Lm9wdGlvbnNcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvckluaXQgVGhlIENTUyBjbGFzcyB0byBmaW5kIG5hdmlnYXRpb24gbWVudXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYkluaXRUYXJnZXQgVGhlIGF0dHJpYnV0ZSBuYW1lIGluIHRoZVxuICAgICAqIGxhdW5jaGVyIGJ1dHRvbnMgdG8gZmluZCB0YXJnZXQgbmF2aWdhdGlvbiBtZW51LlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGluaXRFdmVudE5hbWVzIFRoZSBldmVudHMgdGhhdCB0aGUgY29tcG9uZW50XG4gICAgICogd2lsbCBoYW5kbGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzLnByZWZpeDtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoTmF2aWdhdGlvbk1lbnVQYW5lbC5vcHRpb25zKSwge1xuICAgICAgICBzZWxlY3RvckluaXQ6ICdbZGF0YS1uYXZpZ2F0aW9uLW1lbnVdJyxcbiAgICAgICAgYXR0cmliSW5pdFRhcmdldDogJ2RhdGEtbmF2aWdhdGlvbi1tZW51LXRhcmdldCcsXG4gICAgICAgIHNlbGVjdG9yU2hlbGxOYXZTdWJtZW51OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tbmF2aWdhdGlvbl9fY2F0ZWdvcnktdG9nZ2xlXCIpLFxuICAgICAgICBzZWxlY3RvclNoZWxsTmF2TGluazogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLW5hdmlnYXRpb24tbGlua1wiKSxcbiAgICAgICAgc2VsZWN0b3JTaGVsbE5lc3RlZE5hdkxpbms6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1uYXZpZ2F0aW9uX19jYXRlZ29yeS1pdGVtID4gYS5cIikuY29uY2F0KHByZWZpeCwgXCItLW5hdmlnYXRpb24tbGlua1wiKSxcbiAgICAgICAgc2VsZWN0b3JTaGVsbE5hdkxpbmtDdXJyZW50OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tbmF2aWdhdGlvbi1pdGVtLS1hY3RpdmUsLlwiKS5jb25jYXQocHJlZml4LCBcIi0tbmF2aWdhdGlvbl9fY2F0ZWdvcnktaXRlbS0tYWN0aXZlXCIpLFxuICAgICAgICBzZWxlY3RvckZvY3VzYWJsZU5hdkl0ZW1zOiBcIlxcbiAgICAgICAgLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1uYXZpZ2F0aW9uX19jYXRlZ29yeS10b2dnbGUsXFxuICAgICAgICAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1uYXZpZ2F0aW9uLWl0ZW0gPiAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1uYXZpZ2F0aW9uLWxpbmssXFxuICAgICAgICAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1uYXZpZ2F0aW9uLWxpbmtbdGFiaW5kZXg9XFxcIjBcXFwiXVxcbiAgICAgIFwiKSxcbiAgICAgICAgc2VsZWN0b3JTaGVsbE5hdkl0ZW06IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1uYXZpZ2F0aW9uLWl0ZW1cIiksXG4gICAgICAgIHNlbGVjdG9yU2hlbGxOYXZDYXRlZ29yeTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLW5hdmlnYXRpb25fX2NhdGVnb3J5XCIpLFxuICAgICAgICBzZWxlY3RvclNoZWxsTmF2TmVzdGVkQ2F0ZWdvcnk6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1uYXZpZ2F0aW9uX19jYXRlZ29yeS1pdGVtXCIpLFxuICAgICAgICBjbGFzc1NoZWxsTmF2SXRlbUFjdGl2ZTogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tbmF2aWdhdGlvbi1pdGVtLS1hY3RpdmVcIiksXG4gICAgICAgIGNsYXNzU2hlbGxOYXZMaW5rQ3VycmVudDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tbmF2aWdhdGlvbl9fY2F0ZWdvcnktaXRlbS0tYWN0aXZlXCIpLFxuICAgICAgICBjbGFzc1NoZWxsTmF2Q2F0ZWdvcnlFeHBhbmRlZDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tbmF2aWdhdGlvbl9fY2F0ZWdvcnktLWV4cGFuZGVkXCIpXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW51bSBmb3IgbmF2aWdhdGluZyBiYWNrd2FyZC9mb3J3YXJkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIgTmF2aWdhdGlvbk1lbnVQYW5lbC5OQVZJR0FURVxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJBQ0tXQVJEIE5hdmlnYXRpbmcgYmFja3dhcmQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZPUldBUkQgTmF2aWdhdGluZyBmb3J3YXJkLlxuICAgICAqL1xuXG4gIH1dKTtcblxuICBOYXZpZ2F0aW9uTWVudS5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgTmF2aWdhdGlvbk1lbnUuTkFWSUdBVEUgPSB7XG4gICAgQkFDS1dBUkQ6IC0xLFxuICAgIEZPUldBUkQ6IDFcbiAgfTtcbiAgcmV0dXJuIE5hdmlnYXRpb25NZW51O1xufShOYXZpZ2F0aW9uTWVudVBhbmVsKTtcblxuZXhwb3J0IHsgTmF2aWdhdGlvbk1lbnUgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmltcG9ydCBOYXZpZ2F0aW9uTWVudVBhbmVsIGZyb20gJy4vbmF2aWdhdGlvbi1tZW51LXBhbmVsJztcbmltcG9ydCBvbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2Mvb24nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvc2V0dGluZ3MnO1xuaW1wb3J0IG9uRm9jdXNPdXRCeUtleWJvYXJkIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbi1mb2N1cy1ieS1rZXlib2FyZCc7XG52YXIgc2VxID0gMDtcblxudmFyIFByb2R1Y3RTd2l0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05hdmlnYXRpb25NZW51UGFuZWwpIHtcbiAgX2luaGVyaXRzKFByb2R1Y3RTd2l0Y2hlciwgX05hdmlnYXRpb25NZW51UGFuZWwpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUHJvZHVjdFN3aXRjaGVyKTtcbiAgLyoqXG4gICAqIEEgbmF2aWdhdGlvbiBtZW51LlxuICAgKiBAZXh0ZW5kcyBOYXZpZ2F0aW9uTWVudVBhbmVsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd29ya2luZyBhcyBhIHNlbGVjdG9yLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBjb21wb25lbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9ySW5pdF0gVGhlIENTUyBjbGFzcyB0byBmaW5kIHByb2R1Y3RcbiAgICogc3dpdGNoZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hdHRyaWJJbml0VGFyZ2V0XSBUaGUgYXR0cmlidXRlIG5hbWUgaW4gdGhlXG4gICAqIGxhdW5jaGVyIGJ1dHRvbnMgdG8gZmluZCB0YXJnZXQgcHJvZHVjdCBzd2l0Y2hlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NQcm9kdWN0U3dpdGNoZXJFeHBhbmRlZF0gVGhlIENTUyBjbGFzc1xuICAgKiBmb3IgYW4gZXhwYW5kZWQgcHJvZHVjdCBzd2l0Y2hlclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFByb2R1Y3RTd2l0Y2hlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2R1Y3RTd2l0Y2hlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIF90aGlzLmN1cnJlbnQgPSAnJztcbiAgICBfdGhpcy50cmlnZ2VyQnV0dG9uSWRzID0gbmV3IFNldCgpO1xuXG4gICAgX3RoaXMuX2hhbmRsZUZvY3VzT3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50VHJpZ2dlckJ1dHRvbiA9IF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChfdGhpcy5jdXJyZW50KTtcblxuICAgICAgaWYgKGN1cnJlbnRUcmlnZ2VyQnV0dG9uICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgIWV2ZW50LnJlbGF0ZWRUYXJnZXQubWF0Y2hlcyhfdGhpcy5vcHRpb25zLnNlbGVjdG9yRmxvYXRpbmdNZW51cykpIHtcbiAgICAgICAgY3VycmVudFRyaWdnZXJCdXR0b24uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX2hhbmRsZUtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBpc0V4cGFuZGVkID0gIV90aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdoaWRkZW4nKTtcblxuICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAyNyAmJiBpc0V4cGFuZGVkKSB7XG4gICAgICAgIHZhciB0cmlnZ2VyQnV0dG9uID0gX3RoaXMuY3VycmVudDtcblxuICAgICAgICBfdGhpcy5jaGFuZ2VTdGF0ZShfdGhpcy5jb25zdHJ1Y3Rvci5TRUxFQ1RfTk9ORSk7XG5cbiAgICAgICAgX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRyaWdnZXJCdXR0b24pLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZWRCeUxhdW5jaGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgaXNFeHBhbmRlZCA9IF90aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKF90aGlzLm9wdGlvbnMuY2xhc3NQcm9kdWN0U3dpdGNoZXJFeHBhbmRlZCk7XG5cbiAgICAgIHZhciBsYXVuY2hlciA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0O1xuXG4gICAgICBpZiAoIWxhdW5jaGVyLmlkKSB7XG4gICAgICAgIGxhdW5jaGVyLmlkID0gXCJfX2NhcmJvbi1wcm9kdWN0LXN3aXRjaGVyLWxhdW5jaGVyLVwiLmNvbmNhdChzZXErKyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gbGF1bmNoZXIuaWQ7XG5cbiAgICAgIF90aGlzLmNoYW5nZVN0YXRlKGlzRXhwYW5kZWQgJiYgX3RoaXMuY3VycmVudCA9PT0gY3VycmVudCA/IF90aGlzLmNvbnN0cnVjdG9yLlNFTEVDVF9OT05FIDogY3VycmVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLnNob3VsZFN0YXRlQmVDaGFuZ2VkID0gZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5jdXJyZW50ICE9PSBjdXJyZW50O1xuICAgIH07XG5cbiAgICBfdGhpcy5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICBfdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoX3RoaXMub3B0aW9ucy5jbGFzc1Byb2R1Y3RTd2l0Y2hlckV4cGFuZGVkLCBzdGF0ZSAhPT0gX3RoaXMuY29uc3RydWN0b3IuU0VMRUNUX05PTkUpO1xuXG4gICAgICBfdGhpcy5jdXJyZW50ID0gc3RhdGU7XG5cbiAgICAgIGlmIChfdGhpcy5jdXJyZW50ICE9PSBfdGhpcy5jb25zdHJ1Y3Rvci5TRUxFQ1RfTk9ORSkge1xuICAgICAgICBfdGhpcy50cmlnZ2VyQnV0dG9uSWRzLmFkZChfdGhpcy5jdXJyZW50KTtcbiAgICAgIH0gLy8gZGVhY3RpdmF0ZSBhbGwgb3RoZXIgdHJpZ2dlciBidXR0b25zXG5cblxuICAgICAgX3RoaXMudHJpZ2dlckJ1dHRvbklkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYnV0dG9uID0gX3RoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICB2YXIgbGFiZWwgPSBidXR0b24uZ2V0QXR0cmlidXRlKF90aGlzLm9wdGlvbnMuYXR0cmliTGFiZWxFeHBhbmQpO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5vcHRpb25zLmNsYXNzTmF2aWdhdGlvbk1lbnVQYW5lbEhlYWRlckFjdGlvbkFjdGl2ZSk7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgbGFiZWwpO1xuICAgICAgfSk7IC8vIHNldCBhY3RpdmUgdHJpZ2dlciBidXR0b24gYXR0cmlidXRlc1xuXG5cbiAgICAgIHZhciBjdXJyZW50VHJpZ2dlckJ1dHRvbiA9IF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChfdGhpcy5jdXJyZW50KTtcblxuICAgICAgaWYgKGN1cnJlbnRUcmlnZ2VyQnV0dG9uKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGN1cnJlbnRUcmlnZ2VyQnV0dG9uLmdldEF0dHJpYnV0ZShfdGhpcy5vcHRpb25zLmF0dHJpYkxhYmVsQ29sbGFwc2UpO1xuICAgICAgICBjdXJyZW50VHJpZ2dlckJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKF90aGlzLm9wdGlvbnMuY2xhc3NOYXZpZ2F0aW9uTWVudVBhbmVsSGVhZGVyQWN0aW9uQWN0aXZlKTtcbiAgICAgICAgY3VycmVudFRyaWdnZXJCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuICAgICAgICBjdXJyZW50VHJpZ2dlckJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgbGFiZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgIT09IF90aGlzLmNvbnN0cnVjdG9yLlNFTEVDVF9OT05FKSB7XG4gICAgICAgIF90aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG5cbiAgICAgICAgX3RoaXMuZWxlbWVudC5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm1hbmFnZShvbihlbGVtZW50LCAna2V5ZG93bicsIF90aGlzLl9oYW5kbGVLZXlEb3duKSk7XG5cbiAgICBfdGhpcy5tYW5hZ2Uob25Gb2N1c091dEJ5S2V5Ym9hcmQoZWxlbWVudCwgJ2JsdXInLCBfdGhpcy5faGFuZGxlRm9jdXNPdXQpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogaWQgb2YgY3VycmVudGx5IGFjdGl2ZSB0cmlnZ2VyIGJ1dHRvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQcm9kdWN0U3dpdGNoZXIsIFt7XG4gICAga2V5OiBcInJlbGVhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAgIHRoaXMudHJpZ2dlckJ1dHRvbklkcy5jbGVhcigpO1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFByb2R1Y3RTd2l0Y2hlci5wcm90b3R5cGUpLCBcInJlbGVhc2VcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBhc3NvY2lhdGluZyBET00gZWxlbWVudCBhbmQgUHJvZHVjdFN3aXRjaGVyIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXIgUHJvZHVjdFN3aXRjaGVyLmNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IsXG4gICAgICoge0BsaW5rY29kZSBQcm9kdWN0U3dpdGNoZXIuY3JlYXRlIC5jcmVhdGUoKX0sIG9yXG4gICAgICoge0BsaW5rY29kZSBQcm9kdWN0U3dpdGNoZXIuaW5pdCAuaW5pdCgpfSxcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGFyZSBvdmVycmlkZW4gZm9yIHRoZSBpbnN0YW5jZSBiZWluZyBjcmVhdGUgYW5kXG4gICAgICogaG93IHtAbGlua2NvZGUgUHJvZHVjdFN3aXRjaGVyLmluaXQgLmluaXQoKX0gd29ya3MuXG4gICAgICogQG1lbWJlciBQcm9kdWN0U3dpdGNoZXIub3B0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9ySW5pdCBUaGUgQ1NTIGNsYXNzIHRvIGZpbmQgcG9wdXAgbmF2cy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXR0cmliSW5pdFRhcmdldCBUaGUgYXR0cmlidXRlIG5hbWUgaW4gdGhlXG4gICAgICogbGF1bmNoZXIgYnV0dG9ucyB0byBmaW5kIHRhcmdldCBwb3B1cCBuYXYuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gaW5pdEV2ZW50TmFtZXMgVGhlIGV2ZW50cyB0aGF0IHRoZSBjb21wb25lbnRcbiAgICAgKiB3aWxsIGhhbmRsZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MucHJlZml4O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShOYXZpZ2F0aW9uTWVudVBhbmVsLm9wdGlvbnMpLCB7XG4gICAgICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLXByb2R1Y3Qtc3dpdGNoZXJdJyxcbiAgICAgICAgc2VsZWN0b3JGbG9hdGluZ01lbnVzOiBcIlxcbiAgICAgICAgLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1vdmVyZmxvdy1tZW51LW9wdGlvbnMsXFxuICAgICAgICAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1vdmVyZmxvdy1tZW51LW9wdGlvbnMgKixcXG4gICAgICAgIC5cIikuY29uY2F0KHByZWZpeCwgXCItLXRvb2x0aXAsXFxuICAgICAgICAuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS10b29sdGlwICosXFxuICAgICAgICAuZmxhdHBpY2tlci1jYWxlbmRhcixcXG4gICAgICAgIC5mbGF0cGlja2VyLWNhbGVuZGFyICpcXG4gICAgICAgIFwiKSxcbiAgICAgICAgYXR0cmliSW5pdFRhcmdldDogJ2RhdGEtcHJvZHVjdC1zd2l0Y2hlci10YXJnZXQnLFxuICAgICAgICBjbGFzc1Byb2R1Y3RTd2l0Y2hlckV4cGFuZGVkOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1wYW5lbC0tZXhwYW5kZWRcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIFByb2R1Y3RTd2l0Y2hlci5TRUxFQ1RfTk9ORSA9ICdfX2NhcmJvbi1wcm9kdWN0LXN3aXRjaGVyLWxhdW5jaGVyLU5PTkUnO1xuICBQcm9kdWN0U3dpdGNoZXIuY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBQcm9kdWN0U3dpdGNoZXI7XG59KE5hdmlnYXRpb25NZW51UGFuZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9kdWN0U3dpdGNoZXI7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBtaXhpbiBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21pc2MvbWl4aW4nO1xuaW1wb3J0IGNyZWF0ZUNvbXBvbmVudCBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL21peGlucy9jcmVhdGUtY29tcG9uZW50JztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9nbG9iYWxzL2pzL3NldHRpbmdzJztcbmltcG9ydCBpbml0Q29tcG9uZW50QnlTZWFyY2ggZnJvbSAnLi4vLi4vZ2xvYmFscy9qcy9taXhpbnMvaW5pdC1jb21wb25lbnQtYnktc2VhcmNoJztcbmltcG9ydCBoYW5kbGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWl4aW5zL2hhbmRsZXMnO1xuaW1wb3J0IG9uIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9vbic7XG5pbXBvcnQgZXZlbnRNYXRjaGVzIGZyb20gJy4uLy4uL2dsb2JhbHMvanMvbWlzYy9ldmVudC1tYXRjaGVzJztcbnZhciBwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXg7XG5cbnZhciBTaWRlTmF2ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWl4aW4pIHtcbiAgX2luaGVyaXRzKFNpZGVOYXYsIF9taXhpbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTaWRlTmF2KTtcbiAgLyoqXG4gICAqIFRoZSBtYXAgYXNzb2NpYXRpbmcgRE9NIGVsZW1lbnQgYW5kIGNvcHkgYnV0dG9uIFVJIGluc3RhbmNlLlxuICAgKiBAbWVtYmVyIFNpZGVOYXYuY29tcG9uZW50c1xuICAgKiBAdHlwZSB7V2Vha01hcH1cbiAgICovXG5cbiAgLyoqXG4gICAqIFNpZGUgbmF2LlxuICAgKiBAZXh0ZW5kcyBDcmVhdGVDb21wb25lbnRcbiAgICogQGV4dGVuZHMgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqIEBleHRlbmRzIEhhbmRsZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIGEgc2lkZSBuYXYuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JTaWRlTmF2VG9nZ2xlXVxuICAgKiAgIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgdG9nZ2xlIGJ1dHRvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9yU2lkZU5hdlN1Ym1lbnVdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgdHJpZ2dlciBidXR0b25zIGZvciBzdWIgbmF2IGl0ZW1zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JTaWRlTmF2SXRlbV0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoZSBuYXYgaXRlbXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclNpZGVOYXZMaW5rXSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGludGVyYWN0aXZlIHBvdGlvbnMgaW4gbm9uLW5lc3RlZCBuYXYgaXRlbXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RvclNpZGVOYXZMaW5rQ3VycmVudF1cbiAgICogICBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhlIGludGVyYWN0aXZlIHBvdGlvbiBpbiBhY3RpdmUgbm9uLW5lc3RlZCBuYXYgaXRlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzU2lkZU5hdkV4cGFuZGVkXSBUaGUgQ1NTIGNsYXNzIGZvciB0aGUgZXhwYW5kZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGFzc1NpZGVOYXZJdGVtQWN0aXZlXVxuICAgKiAgIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBhY3RpdmUvaW5hY3RpdmUgc3RhdGUgZm9yIG5hdiBpdGVtcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzU2lkZU5hdkxpbmtDdXJyZW50XVxuICAgKiAgIFRoZSBDU1MgY2xhc3MgZm9yIHRoZSBhY3RpdmUvaW5hY3RpdmUgc3RhdGUgb2YgdGhlIGludGVyYWN0aXZlIHBvdGlvbiBpbiBub24tbmVzdGVkIG5hdiBpdGVtcy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBTaWRlTmF2KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lkZU5hdik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMuX2hhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyIG1hdGNoZXNUb2dnbGUgPSBldmVudE1hdGNoZXMoZXZ0LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yU2lkZU5hdlRvZ2dsZSk7XG4gICAgICB2YXIgbWF0Y2hlc05hdlN1Ym1lbnUgPSBldmVudE1hdGNoZXMoZXZ0LCBfdGhpcy5vcHRpb25zLnNlbGVjdG9yU2lkZU5hdlN1Ym1lbnUpO1xuICAgICAgdmFyIG1hdGNoZXNTaWRlTmF2TGluayA9IGV2ZW50TWF0Y2hlcyhldnQsIF90aGlzLm9wdGlvbnMuc2VsZWN0b3JTaWRlTmF2TGluayk7XG5cbiAgICAgIGlmICghbWF0Y2hlc1RvZ2dsZSAmJiAhbWF0Y2hlc05hdlN1Ym1lbnUgJiYgIW1hdGNoZXNTaWRlTmF2TGluaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaGVzVG9nZ2xlKSB7XG4gICAgICAgIF90aGlzLmNoYW5nZVN0YXRlKCFfdGhpcy5pc05hdkV4cGFuZGVkKCkgPyBfdGhpcy5jb25zdHJ1Y3Rvci5zdGF0ZS5FWFBBTkRFRCA6IF90aGlzLmNvbnN0cnVjdG9yLnN0YXRlLkNPTExBUFNFRCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2hlc05hdlN1Ym1lbnUpIHtcbiAgICAgICAgdmFyIGlzU3VibWVudUV4cGFuZGVkID0gbWF0Y2hlc05hdlN1Ym1lbnUuZ2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJykgPT09ICd0cnVlJztcbiAgICAgICAgbWF0Y2hlc05hdlN1Ym1lbnUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgXCJcIi5jb25jYXQoIWlzU3VibWVudUV4cGFuZGVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoZXNTaWRlTmF2TGluaykge1xuICAgICAgICBfdG9Db25zdW1hYmxlQXJyYXkoX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuc2VsZWN0b3JTaWRlTmF2TGlua0N1cnJlbnQpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMub3B0aW9ucy5jbGFzc1NpZGVOYXZJdGVtQWN0aXZlLCBfdGhpcy5vcHRpb25zLmNsYXNzU2lkZU5hdkxpbmtDdXJyZW50KTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtYXRjaGVzU2lkZU5hdkxpbmsuY2xhc3NMaXN0LmFkZChfdGhpcy5vcHRpb25zLmNsYXNzU2lkZU5hdkxpbmtDdXJyZW50KTtcbiAgICAgICAgdmFyIGNsb3Nlc3RTaWRlTmF2SXRlbSA9IG1hdGNoZXNTaWRlTmF2TGluay5jbG9zZXN0KF90aGlzLm9wdGlvbnMuc2VsZWN0b3JTaWRlTmF2SXRlbSk7XG5cbiAgICAgICAgaWYgKGNsb3Nlc3RTaWRlTmF2SXRlbSkge1xuICAgICAgICAgIGNsb3Nlc3RTaWRlTmF2SXRlbS5jbGFzc0xpc3QuYWRkKF90aGlzLm9wdGlvbnMuY2xhc3NTaWRlTmF2SXRlbUFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMubWFuYWdlKG9uKGVsZW1lbnQsICdjbGljaycsIF90aGlzLl9oYW5kbGVDbGljaykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbnVtIGZvciB0b2dnbGluZyBzaWRlIG5hdiB2aXNpYmlsaXR5XG4gICAqIEByZWFkb25seVxuICAgKiBAbWVtYmVyIFNpZGVOYXYuc3RhdGVcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IEVYUEFOREVEIE9wZW5pbmcvdmlzaWJsZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gQ09MTEFQU0VEIENsb3NpbmcvaGlkZGVuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFNpZGVOYXYsIFt7XG4gICAga2V5OiBcImlzTmF2RXhwYW5kZWRcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBuYXYgaXMgZXhwYW5kZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXZFeHBhbmRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMub3B0aW9ucy5jbGFzc1NpZGVOYXZFeHBhbmRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGV4cGFuZGVkL2NvbGxhcHNlZCBzdGF0ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoYW5nZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZVN0YXRlKHN0YXRlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLm9wdGlvbnMuY2xhc3NTaWRlTmF2RXhwYW5kZWQsIHN0YXRlID09PSB0aGlzLmNvbnN0cnVjdG9yLnN0YXRlLkVYUEFOREVEKTtcbiAgICB9XG4gIH1dKTtcblxuICBTaWRlTmF2LmNvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICBTaWRlTmF2LnN0YXRlID0ge1xuICAgIEVYUEFOREVEOiAnZXhwYW5kZWQnLFxuICAgIENPTExBUFNFRDogJ2NvbGxhcHNlZCdcbiAgfTtcbiAgU2lkZU5hdi5vcHRpb25zID0ge1xuICAgIHNlbGVjdG9ySW5pdDogJ1tkYXRhLXNpZGUtbmF2XScsXG4gICAgc2VsZWN0b3JTaWRlTmF2VG9nZ2xlOiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tc2lkZS1uYXZfX3RvZ2dsZVwiKSxcbiAgICBzZWxlY3RvclNpZGVOYXZTdWJtZW51OiBcIi5cIi5jb25jYXQocHJlZml4LCBcIi0tc2lkZS1uYXZfX3N1Ym1lbnVcIiksXG4gICAgc2VsZWN0b3JTaWRlTmF2SXRlbTogXCIuXCIuY29uY2F0KHByZWZpeCwgXCItLXNpZGUtbmF2X19pdGVtXCIpLFxuICAgIHNlbGVjdG9yU2lkZU5hdkxpbms6IFwiLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zaWRlLW5hdl9fbGlua1wiKSxcbiAgICBzZWxlY3RvclNpZGVOYXZMaW5rQ3VycmVudDogXCJbYXJpYS1jdXJyZW50PVxcXCJwYWdlXFxcIl0sLlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zaWRlLW5hdl9fbGluay0tY3VycmVudCwuXCIpLmNvbmNhdChwcmVmaXgsIFwiLS1zaWRlLW5hdl9faXRlbS0tYWN0aXZlXCIpLFxuICAgIGNsYXNzU2lkZU5hdkV4cGFuZGVkOiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLS1zaWRlLW5hdi0tZXhwYW5kZWRcIiksXG4gICAgY2xhc3NTaWRlTmF2SXRlbUFjdGl2ZTogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tc2lkZS1uYXZfX2l0ZW0tLWFjdGl2ZVwiKSxcbiAgICBjbGFzc1NpZGVOYXZMaW5rQ3VycmVudDogXCJcIi5jb25jYXQocHJlZml4LCBcIi0tc2lkZS1uYXZfX2xpbmstLWN1cnJlbnRcIilcbiAgfTtcbiAgcmV0dXJuIFNpZGVOYXY7XG59KG1peGluKGNyZWF0ZUNvbXBvbmVudCwgaW5pdENvbXBvbmVudEJ5U2VhcmNoLCBoYW5kbGVzKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNpZGVOYXY7IiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlY2tib3ggfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NoZWNrYm94L2NoZWNrYm94JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsZVVwbG9hZGVyIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9maWxlLXVwbG9hZGVyL2ZpbGUtdXBsb2FkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb250ZW50U3dpdGNoZXIgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NvbnRlbnQtc3dpdGNoZXIvY29udGVudC1zd2l0Y2hlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYiB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdGFicy90YWJzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3ZlcmZsb3dNZW51IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9vdmVyZmxvdy1tZW51L292ZXJmbG93LW1lbnUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNb2RhbCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbW9kYWwvbW9kYWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMb2FkaW5nIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9sb2FkaW5nL2xvYWRpbmcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbmxpbmVMb2FkaW5nIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9pbmxpbmUtbG9hZGluZy9pbmxpbmUtbG9hZGluZyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERyb3Bkb3duIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9kcm9wZG93bi9kcm9wZG93bic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE51bWJlcklucHV0IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9udW1iZXItaW5wdXQvbnVtYmVyLWlucHV0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0YVRhYmxlVjIgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2RhdGEtdGFibGUtdjIvZGF0YS10YWJsZS12Mic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERhdGFUYWJsZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvZGF0YS10YWJsZS9kYXRhLXRhYmxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0ZVBpY2tlciB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvZGF0ZS1waWNrZXIvZGF0ZS1waWNrZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYWdpbmF0aW9uIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9wYWdpbmF0aW9uL3BhZ2luYXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWFyY2ggfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3NlYXJjaC9zZWFyY2gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBY2NvcmRpb24gfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb3B5QnV0dG9uIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb3B5LWJ1dHRvbi9jb3B5LWJ1dHRvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vdGlmaWNhdGlvbiB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvb2xiYXIgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3Rvb2xiYXIvdG9vbGJhcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvb2x0aXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvb2x0aXBTaW1wbGUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC0tc2ltcGxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJvZ3Jlc3NJbmRpY2F0b3IgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3Byb2dyZXNzLWluZGljYXRvci9wcm9ncmVzcy1pbmRpY2F0b3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGbG9hdGluZ01lbnUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2Zsb2F0aW5nLW1lbnUvZmxvYXRpbmctbWVudSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0cnVjdHVyZWRMaXN0IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9zdHJ1Y3R1cmVkLWxpc3Qvc3RydWN0dXJlZC1saXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2xpZGVyIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9zbGlkZXIvc2xpZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGlsZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdGlsZS90aWxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29kZVNuaXBwZXQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NvZGUtc25pcHBldC9jb2RlLXNuaXBwZXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0SW5wdXQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3RleHQtaW5wdXQvdGV4dC1pbnB1dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZGVOYXYgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3VpLXNoZWxsL3NpZGUtbmF2JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSGVhZGVyU3VibWVudSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdWktc2hlbGwvaGVhZGVyLXN1Ym1lbnUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWFkZXJOYXYgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3VpLXNoZWxsL2hlYWRlci1uYXYnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOYXZpZ2F0aW9uTWVudSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdWktc2hlbGwvbmF2aWdhdGlvbi1tZW51JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJvZHVjdFN3aXRjaGVyIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy91aS1zaGVsbC9wcm9kdWN0LXN3aXRjaGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGFnaW5hdGlvbk5hdiB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvcGFnaW5hdGlvbi1uYXYvcGFnaW5hdGlvbi1uYXYnOyIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3Rvci5cbiAqIEByZXR1cm5zIHtFbGVtZW50fVxuICogICBUaGUgY2xvc2VzdCBhbmNlc3RvciBvZiB0aGUgZXZlbnQgdGFyZ2V0IChvciB0aGUgZXZlbnQgdGFyZ2V0IGl0c2VsZikgd2hpY2ggbWF0Y2hlcyB0aGUgc2VsZWN0b3JzIGdpdmVuIGluIHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGV2ZW50LCBzZWxlY3Rvcikge1xuICAvLyA8c3ZnPiBpbiBJRSBkb2VzIG5vdCBoYXZlIGBFbGVtZW50I21zTWF0Y2hlc1NlbGVjdG9yKClgICh0aGF0IHNob3VsZCBiZSBjb3BpZWQgdG8gYEVsZW1lbnQjbWF0Y2hlcygpYCBieSBhIHBvbHlmaWxsKS5cbiAgLy8gQWxzbyBhIHdlaXJkIGJlaGF2aW9yIGlzIHNlZW4gaW4gSUUgd2hlcmUgRE9NIHRyZWUgc2VlbXMgYnJva2VuIHdoZW4gYGV2ZW50LnRhcmdldGAgaXMgb24gPHN2Zz4uXG4gIC8vIFRoZXJlZm9yZSB0aGlzIGZ1bmN0aW9uIHNpbXBseSByZXR1cm5zIGB1bmRlZmluZWRgIHdoZW4gYGV2ZW50LnRhcmdldGAgaXMgb24gPHN2Zz4uXG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG4gICAgICBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcblxuICBpZiAodHlwZW9mIHRhcmdldC5tYXRjaGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgLy8gSWYgZXZlbnQgdGFyZ2V0IGl0c2VsZiBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3RvciwgcmV0dXJuIGl0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQubWF0Y2hlcyhcIlwiLmNvbmNhdChzZWxlY3RvciwgXCIgKlwiKSkpIHtcbiAgICAgIHZhciBjbG9zZXN0ID0gdGFyZ2V0LmNsb3Nlc3Qoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoKGN1cnJlbnRUYXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSA/IGN1cnJlbnRUYXJnZXQuZG9jdW1lbnRFbGVtZW50IDogY3VycmVudFRhcmdldCkuY29udGFpbnMoY2xvc2VzdCkpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF1bmNoaW5nRGV0YWlscyhldnQpIHtcbiAgaWYgKCFldnQgfHwgdHlwZW9mIGV2dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB7XG4gICAgICBsYXVuY2hpbmdFbGVtZW50OiBudWxsLFxuICAgICAgbGF1bmNoaW5nRXZlbnQ6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdmFyIGxhdW5jaGluZ0VsZW1lbnQgPSBldnQuZGVsZWdhdGVUYXJnZXQgfHwgZXZ0LmN1cnJlbnRUYXJnZXQgfHwgZXZ0O1xuICB2YXIgbGF1bmNoaW5nRXZlbnQgPSBldnQuY3VycmVudFRhcmdldCAmJiBldnQ7XG5cbiAgaWYgKGxhdW5jaGluZ0VsZW1lbnQgJiYgIWxhdW5jaGluZ0VsZW1lbnQubm9kZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdET00gTm9kZSBzaG91bGQgYmUgZ2l2ZW4gZm9yIGxhdW5jaGluZyBlbGVtZW50LicpO1xuICB9XG5cbiAgaWYgKGxhdW5jaGluZ0V2ZW50ICYmICFsYXVuY2hpbmdFdmVudC50eXBlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRE9NIGV2ZW50IHNob3VsZCBiZSBnaXZlbiBmb3IgbGF1bmNoaW5nIGV2ZW50LicpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsYXVuY2hpbmdFbGVtZW50OiBsYXVuY2hpbmdFbGVtZW50LFxuICAgIGxhdW5jaGluZ0V2ZW50OiBsYXVuY2hpbmdFdmVudFxuICB9O1xufSIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYSBBbiBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBhcnJheS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuICByZXR1cm4gYS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaXRlbSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF90b0NvbnN1bWFibGVBcnJheShmbGF0dGVuKGl0ZW0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtdKTtcbn1cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciBkZWZpbmluZyBtaXgtaW4gY2xhc3Nlcy4gVXNlZCB3aXRoIHtAbGluayBtaXhpbn0uXG4gKiBAZnVuY3Rpb24gbWl4aW5mblxuICogQHBhcmFtIHtDbGFzc30gVG9NaXggVGhlIGNsYXNzIHRvIG1peC5cbiAqIEByZXR1cm5zIHtDbGFzc30gVGhlIGNsYXNzIG1peGVkLWluIHdpdGggdGhlIGdpdmVuIFRvTWl4IGNsYXNzLlxuICovXG5cbi8qKlxuICogQGZ1bmN0aW9uIG1peGluXG4gKiBAcGFyYW0gey4uLm1peGluZm59IG1peGluZm5zIFRoZSBmdW5jdGlvbnMgZ2VuZXJhdGluZyBtaXgtaW5zLlxuICogQHJldHVybnMge0NsYXNzfSBUaGUgY2xhc3MgZ2VuZXJhdGVkIHdpdGggdGhlIGdpdmVuIG1peC1pbnMuXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXhpbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1peGluZm5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1peGluZm5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZsYXR0ZW4obWl4aW5mbnMpLnJlZHVjZShmdW5jdGlvbiAoQ2xhc3MsIG1peGluZm4pIHtcbiAgICByZXR1cm4gbWl4aW5mbihDbGFzcyk7XG4gIH0sIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX2NsYXNzKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jbGFzcztcbiAgfSgpKTtcbn0iLCIvKipcbiAqIERpZmZlcmVudGlhdGUgYmV0d2VlbiBrZXlib2FyZCBhbmQgbW91c2UtdHJpZ2dlcmVkIGZvY3Vzb3V0L2JsdXIgZXZlbnRzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgIFRoZSBlbGVtZW50IHRvIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0b1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHJldHVybnMge0hhbmRsZX0gVGhlIGhhbmRsZSB0byByZWxlYXNlIHRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9uRm9jdXNCeUtleWJvYXJkKG5vZGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBoYXNGb2N1c291dCA9ICgnb25mb2N1c291dCcgaW4gd2luZG93KTtcbiAgdmFyIGZvY3VzaW5FdmVudE5hbWUgPSBoYXNGb2N1c291dCA/ICdmb2N1c2luJyA6ICdmb2N1cyc7XG4gIHZhciBmb2N1c291dEV2ZW50TmFtZSA9IGhhc0ZvY3Vzb3V0ID8gJ2ZvY3Vzb3V0JyA6ICdibHVyJztcbiAgLyoqXG4gICAqIEV2ZW50IHR5cGVzIHN1cHBvcnRlZCBieSB0aGlzIGZ1bmN0aW9uXG4gICAqIEB0eXBlIHtvYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cblxuICB2YXIgc3VwcG9ydGVkRXZlbnRzID0ge1xuICAgIGZvY3VzOiBmb2N1c2luRXZlbnROYW1lLFxuICAgIGJsdXI6IGZvY3Vzb3V0RXZlbnROYW1lXG4gIH07XG4gIHZhciBldmVudE5hbWUgPSBzdXBwb3J0ZWRFdmVudHNbbmFtZV07XG5cbiAgaWYgKCFldmVudE5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGV2ZW50IScpO1xuICB9XG5cbiAgdmFyIGNsaWNrZWQ7XG5cbiAgdmFyIGhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlZG93bigpIHtcbiAgICBjbGlja2VkID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgY2xpY2tlZCA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVGb2N1c2luID0gZnVuY3Rpb24gaGFuZGxlRm9jdXNpbihldnQpIHtcbiAgICBpZiAoIWNsaWNrZWQpIHtcbiAgICAgIGNhbGxiYWNrKGV2dCk7XG4gICAgfVxuICB9O1xuXG4gIG5vZGUub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZWRvd24pO1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVGb2N1c2luLCAhaGFzRm9jdXNvdXQpO1xuICByZXR1cm4ge1xuICAgIHJlbGVhc2U6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgICBpZiAoaGFuZGxlRm9jdXNpbikge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVGb2N1c2luLCAhaGFzRm9jdXNvdXQpO1xuICAgICAgICBoYW5kbGVGb2N1c2luID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZU1vdXNlZG93bikge1xuICAgICAgICBub2RlLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgaGFuZGxlTW91c2Vkb3duID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufSIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvbihlbGVtZW50KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lci5hcHBseShlbGVtZW50LCBhcmdzKTtcbiAgcmV0dXJuIHtcbiAgICByZWxlYXNlOiBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KGVsZW1lbnQsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufSIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4vLyBtZG4gcmVzaXplIGZ1bmN0aW9uXG52YXIgb3B0aW1pemVkUmVzaXplID0gLyogI19fUFVSRV9fICovZnVuY3Rpb24gb3B0aW1pemVkUmVzaXplKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBydW5uaW5nID0gZmFsc2U7IC8vIHJ1biB0aGUgYWN0dWFsIGNhbGxiYWNrc1xuXG4gIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrcygpIHtcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcnVubmluZyA9IGZhbHNlO1xuICB9IC8vIGZpcmVkIG9uIHJlc2l6ZSBldmVudFxuXG5cbiAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIGlmICghcnVubmluZykge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1bkNhbGxiYWNrcyk7XG4gICAgfVxuICB9IC8vIGFkZHMgY2FsbGJhY2sgdG8gbG9vcFxuXG5cbiAgZnVuY3Rpb24gYWRkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBwdWJsaWMgbWV0aG9kIHRvIGFkZCBhZGRpdGlvbmFsIGNhbGxiYWNrXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoY2FsbGJhY2spIHtcbiAgICAgIGlmICghY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplKTtcbiAgICAgIH1cblxuICAgICAgYWRkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVsZWFzZTogZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgb3B0aW1pemVkUmVzaXplOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiBzdmdUb2dnbGVDbGFzcyhzdmcsIG5hbWUsIGZvcmNlQWRkKSB7XG4gIHZhciBsaXN0ID0gc3ZnLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgdmFyIHVuaXF1ZUxpc3QgPSBPYmplY3Qua2V5cyhsaXN0LnJlZHVjZShmdW5jdGlvbiAobywgaXRlbSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG8sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlbSwgMSkpO1xuICB9LCB7fSkpO1xuICB2YXIgaW5kZXggPSB1bmlxdWVMaXN0LmluZGV4T2YobmFtZSk7XG4gIHZhciBmb3VuZCA9IGluZGV4ID49IDA7XG4gIHZhciBhZGQgPSBmb3JjZUFkZCA9PT0gdW5kZWZpbmVkID8gIWZvdW5kIDogZm9yY2VBZGQ7XG5cbiAgaWYgKGZvdW5kID09PSAhYWRkKSB7XG4gICAgaWYgKGFkZCkge1xuICAgICAgdW5pcXVlTGlzdC5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmlxdWVMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB1bmlxdWVMaXN0LmpvaW4oJyAnKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc3ZnVG9nZ2xlQ2xhc3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyoqXG4gKiBUb2dnbGVzIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gVGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFkZCBgdHJ1ZWAgdG8gc2V0IHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvZ2dsZUF0dHJpYnV0ZShlbGVtLCBuYW1lLCBhZGQpIHtcbiAgaWYgKGFkZCkge1xuICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufSIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKFRvTWl4KSB7XG4gIHZhciBDcmVhdGVDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ub01peCkge1xuICAgIF9pbmhlcml0cyhDcmVhdGVDb21wb25lbnQsIF9Ub01peCk7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENyZWF0ZUNvbXBvbmVudCk7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBpbnN0YW5jZXMgbWFuYWdlZCBieSB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBSZWxlYXNpbmcgdGhpcyBjb21wb25lbnQgYWxzbyByZWxlYXNlcyB0aGUgY29tcG9uZW50cyBpbiBgdGhpcy5jaGlsZHJlbmAuXG4gICAgICogQHR5cGUge0NvbXBvbmVudFtdfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTWl4LWluIGNsYXNzIHRvIG1hbmFnZSBsaWZlY3ljbGUgb2YgY29tcG9uZW50LlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBzZXRzIHVwIHRoaXMgY29tcG9uZW50J3MgZWZmZWN0aXZlIG9wdGlvbnMsXG4gICAgICogYW5kIHJlZ2lzdGVycyB0aGlzIGNvbXBvbmVudCd0IGluc3RhbmNlIGFzc29jaWF0ZWQgdG8gYW4gZWxlbWVudC5cbiAgICAgKiBAaW1wbGVtZW50cyBIYW5kbGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdvcmtpbmcgYXMgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIENyZWF0ZUNvbXBvbmVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyZWF0ZUNvbXBvbmVudCk7XG5cbiAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICBfdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRE9NIGVsZW1lbnQgc2hvdWxkIGJlIGdpdmVuIHRvIGluaXRpYWxpemUgdGhpcyB3aWRnZXQuJyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBlbGVtZW50IHRoZSBjb21wb25lbnQgaXMgb2YuXG4gICAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgICAqL1xuXG5cbiAgICAgIF90aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICovXG5cbiAgICAgIF90aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoX3RoaXMuY29uc3RydWN0b3Iub3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgICBfdGhpcy5jb25zdHJ1Y3Rvci5jb21wb25lbnRzLnNldChfdGhpcy5lbGVtZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIHRoaXMgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDcmVhdGVDb21wb25lbnQsIFt7XG4gICAgICBrZXk6IFwicmVsZWFzZVwiLFxuICAgICAgdmFsdWU6XG4gICAgICAvKipcbiAgICAgICAqIFJlbGVhc2VzIHRoaXMgY29tcG9uZW50J3MgaW5zdGFuY2UgZnJvbSB0aGUgYXNzb2NpYXRlZCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4ucG9wKCk7IGNoaWxkOyBjaGlsZCA9IHRoaXMuY2hpbGRyZW4ucG9wKCkpIHtcbiAgICAgICAgICBjaGlsZC5yZWxlYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNvbXBvbmVudHMuZGVsZXRlKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImNyZWF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuZ2V0KGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDcmVhdGVDb21wb25lbnQ7XG4gIH0oVG9NaXgpO1xuXG4gIHJldHVybiBDcmVhdGVDb21wb25lbnQ7XG59IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgZXZlbnRlZFN0YXRlIGZyb20gJy4vZXZlbnRlZC1zdGF0ZSc7XG5pbXBvcnQgZ2V0TGF1bmNoaW5nRGV0YWlscyBmcm9tICcuLi9taXNjL2dldC1sYXVuY2hpbmctZGV0YWlscyc7XG5cbmZ1bmN0aW9uIGV2ZW50ZWRTaG93SGlkZVN0YXRlKFRvTWl4KSB7XG4gIC8qKlxuICAgKiBNaXgtaW4gY2xhc3MgdG8gbGF1bmNoIGEgZmxvYXRpbmcgbWVudS5cbiAgICogQGNsYXNzIEV2ZW50ZWRTaG93SGlkZVN0YXRlXG4gICAqL1xuICB2YXIgRXZlbnRlZFNob3dIaWRlU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ub01peCkge1xuICAgIF9pbmhlcml0cyhFdmVudGVkU2hvd0hpZGVTdGF0ZSwgX1RvTWl4KTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXZlbnRlZFNob3dIaWRlU3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gRXZlbnRlZFNob3dIaWRlU3RhdGUoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRlZFNob3dIaWRlU3RhdGUpO1xuXG4gICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEV2ZW50ZWRTaG93SGlkZVN0YXRlLCBbe1xuICAgICAga2V5OiBcInNob3dcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyoqXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBTd2l0Y2ggdG8gJ3Nob3duJyBzdGF0ZS5cbiAgICAgICAqIEBwYXJhbSBbZXZ0T3JFbGVtXSBUaGUgbGF1bmNoaW5nIGV2ZW50IG9yIGVsZW1lbnQuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50ZWRTdGF0ZX5jaGFuZ2VTdGF0ZUNhbGxiYWNrfSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjay5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc2hvdyhldnRPckVsZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghZXZ0T3JFbGVtIHx8IHR5cGVvZiBldnRPckVsZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGV2dE9yRWxlbTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnc2hvd24nLCBnZXRMYXVuY2hpbmdEZXRhaWxzKGV2dE9yRWxlbSksIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU3dpdGNoIHRvICdoaWRkZW4nIHN0YXRlLlxuICAgICAgICogQHBhcmFtIFtldnRPckVsZW1dIFRoZSBsYXVuY2hpbmcgZXZlbnQgb3IgZWxlbWVudC5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnRlZFN0YXRlfmNoYW5nZVN0YXRlQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGlkZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoZXZ0T3JFbGVtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWV2dE9yRWxlbSB8fCB0eXBlb2YgZXZ0T3JFbGVtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBldnRPckVsZW07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2hpZGRlbicsIGdldExhdW5jaGluZ0RldGFpbHMoZXZ0T3JFbGVtKSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFdmVudGVkU2hvd0hpZGVTdGF0ZTtcbiAgfShUb01peCk7XG5cbiAgcmV0dXJuIEV2ZW50ZWRTaG93SGlkZVN0YXRlO1xufVxuXG52YXIgZXhwb3J0cyA9IFtldmVudGVkU3RhdGUsIGV2ZW50ZWRTaG93SGlkZVN0YXRlXTtcbmV4cG9ydCBkZWZhdWx0IGV4cG9ydHM7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChUb01peCkge1xuICAvKipcbiAgICogTWl4LWluIGNsYXNzIHRvIG1hbmFnZSBldmVudHMgYXNzb2NpYXRlZCB3aXRoIHN0YXRlcy5cbiAgICogQGNsYXNzIEV2ZW50ZWRTdGF0ZVxuICAgKi9cbiAgdmFyIEV2ZW50ZWRTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RvTWl4KSB7XG4gICAgX2luaGVyaXRzKEV2ZW50ZWRTdGF0ZSwgX1RvTWl4KTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXZlbnRlZFN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIEV2ZW50ZWRTdGF0ZSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudGVkU3RhdGUpO1xuXG4gICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEV2ZW50ZWRTdGF0ZSwgW3tcbiAgICAgIGtleTogXCJfY2hhbmdlU3RhdGVcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvY2hlY2stcGFyYW0tbmFtZXMgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBFdmVudGVkU3RhdGUjY2hhbmdlU3RhdGUgYC5jaGFuZ2VTdGF0ZSgpYH0sIHBlcmZvcm1pbmcgYWN0dWFsIGNoYW5nZSBpbiBzdGF0ZS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhdGVdIFRoZSBuZXcgc3RhdGUuIENhbiBiZSBhbiBvbWl0dGVkLCB3aGljaCBtZWFucyB0b2dnbGluZy5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZGV0YWlsXVxuICAgICAgICogICBUaGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHB1dCB0byBldmVudCBkZXRhaWxzIHRoYXQgaXMgZmlyZWQgYmVmb3JlL2FmdGVyIGNoYW5naW5nIHN0YXRlLlxuICAgICAgICogICBDYW4gaGF2ZSBhIGBncm91cGAgcHJvcGVydHksIHdoaWNoIHNwZWNpZmllcyB3aGF0IHN0YXRlIHRvIGJlIGNoYW5nZWQuXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50ZWRTdGF0ZX5jaGFuZ2VTdGF0ZUNhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgY2FsbGVkIG9uY2UgY2hhbmdpbmcgc3RhdGUgaXMgZmluaXNoZWQgb3IgaXMgY2FuY2VsZWQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBfY2hhbmdlU3RhdGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignX2NoYW5nZVN0YXRlKCkgc2hvdWxkIGJlIG92ZXJyaWRlbiB0byBwZXJmb3JtIGFjdHVhbCBjaGFuZ2UgaW4gc3RhdGUuJyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENoYW5nZXMgdGhlIHN0YXRlIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZV0gVGhlIG5ldyBzdGF0ZS4gQ2FuIGJlIGFuIG9taXR0ZWQsIHdoaWNoIG1lYW5zIHRvZ2dsaW5nLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtkZXRhaWxdXG4gICAgICAgKiAgIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgcHV0IHRvIGV2ZW50IGRldGFpbHMgdGhhdCBpcyBmaXJlZCBiZWZvcmUvYWZ0ZXIgY2hhbmdpbmcgc3RhdGUuXG4gICAgICAgKiAgIENhbiBoYXZlIGEgYGdyb3VwYCBwcm9wZXJ0eSwgd2hpY2ggc3BlY2lmaWVzIHdoYXQgc3RhdGUgdG8gYmUgY2hhbmdlZC5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnRlZFN0YXRlfmNoYW5nZVN0YXRlQ2FsbGJhY2t9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIGNhbGxlZCBvbmNlIGNoYW5naW5nIHN0YXRlIGlzIGZpbmlzaGVkIG9yIGlzIGNhbmNlbGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hhbmdlU3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VTdGF0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJncy5zaGlmdCgpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZGV0YWlsID0gT2JqZWN0KGFyZ3NbMF0pID09PSBhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdICE9PSAnZnVuY3Rpb24nID8gYXJncy5zaGlmdCgpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3Muc2hpZnQoKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2hvdWxkU3RhdGVCZUNoYW5nZWQgPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuc2hvdWxkU3RhdGVCZUNoYW5nZWQoc3RhdGUsIGRldGFpbCkpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIGdyb3VwOiBkZXRhaWwgJiYgZGV0YWlsLmdyb3VwLFxuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZXZlbnROYW1lU3VmZml4ID0gW2RhdGEuZ3JvdXAsIHN0YXRlXS5maWx0ZXIoQm9vbGVhbikuam9pbignLScpLnNwbGl0KCctJykgLy8gR3JvdXAgb3Igc3RhdGUgbWF5IGNvbnRhaW4gaHlwaGVuXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbVswXS50b1VwcGVyQ2FzZSgpICsgaXRlbS5zdWJzdHIoMSk7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB2YXIgZXZlbnRTdGFydCA9IG5ldyBDdXN0b21FdmVudCh0aGlzLm9wdGlvbnNbXCJldmVudEJlZm9yZVwiLmNvbmNhdChldmVudE5hbWVTdWZmaXgpXSwge1xuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpcmVPbk5vZGUgPSBkZXRhaWwgJiYgZGV0YWlsLmRlbGVnYXRvck5vZGUgfHwgdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgY2FuY2VsZWQgPSAhZmlyZU9uTm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50U3RhcnQpO1xuXG4gICAgICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQ2hhbmdpbmcgc3RhdGUgKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShkYXRhKSwgXCIpIGhhcyBiZWVuIGNhbmNlbGVkLlwiKSk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGFuZ2VTdGF0ZUFyZ3MgPSBbc3RhdGUsIGRldGFpbF0uZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICAgICAgdGhpcy5fY2hhbmdlU3RhdGUuYXBwbHkodGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KGNoYW5nZVN0YXRlQXJncykuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmaXJlT25Ob2RlLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KF90aGlzLm9wdGlvbnNbXCJldmVudEFmdGVyXCIuY29uY2F0KGV2ZW50TmFtZVN1ZmZpeCldLCB7XG4gICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUganNkb2MvY2hlY2stcGFyYW0tbmFtZXMgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBUZXN0cyBpZiBjaGFuZ2UgaW4gc3RhdGUgc2hvdWxkIGhhcHBlbiBvciBub3QuXG4gICAgICAgKiBDbGFzc2VzIGluaGVyaXRpbmcge0BsaW5rIEV2ZW50ZWRTdGF0ZSBgRXZlbnRlZFN0YXRlYH0gc2hvdWxkIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgKiBAZnVuY3Rpb24gRXZlbnRlZFN0YXRlI3Nob3VsZFN0YXRlQmVDaGFuZ2VkXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXRlXSBUaGUgbmV3IHN0YXRlLiBDYW4gYmUgYW4gb21pdHRlZCwgd2hpY2ggbWVhbnMgdG9nZ2xpbmcuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW2RldGFpbF1cbiAgICAgICAqICAgVGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZSBwdXQgdG8gZXZlbnQgZGV0YWlscyB0aGF0IGlzIGZpcmVkIGJlZm9yZS9hZnRlciBjaGFuZ2luZyBzdGF0ZS5cbiAgICAgICAqICAgQ2FuIGhhdmUgYSBgZ3JvdXBgIHByb3BlcnR5LCB3aGljaCBzcGVjaWZpZXMgd2hhdCBzdGF0ZSB0byBiZSBjaGFuZ2VkLlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKiAgIGBmYWxzZWAgaWYgY2hhbmdlIGluIHN0YXRlIHNob3VsZG4ndCBoYXBwZW4sIGUuZy4gd2hlbiB0aGUgZ2l2ZW4gbmV3IHN0YXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAqL1xuXG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEV2ZW50ZWRTdGF0ZTtcbiAgfShUb01peCk7XG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgY2FsbGVkIG9uY2UgY2hhbmdpbmcgc3RhdGUgaXMgZmluaXNoZWQgb3IgaXMgY2FuY2VsZWQuXG4gICAqIEBjYWxsYmFjayBFdmVudGVkU3RhdGV+Y2hhbmdlU3RhdGVDYWxsYmFja1xuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgKiAgIEFuIGVycm9yIG9iamVjdCB3aXRoIGB0cnVlYCBpbiBpdHMgYGNhbmNlbGVkYCBwcm9wZXJ0eSBpZiBjaGFuZ2luZyBzdGF0ZSBpcyBjYW5jZWxlZC5cbiAgICogICBDYW5jZWxsYXRpb24gaGFwcGVucyBpZiB0aGUgaGFuZGxlciBvZiBhIGN1c3RvbSBldmVudCwgdGhhdCBpcyBmaXJlZCBiZWZvcmUgY2hhbmdpbmcgc3RhdGUgaGFwcGVucyxcbiAgICogICBjYWxscyBgLnByZXZlbnREZWZhdWx0KClgIGFnYWluc3QgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlcHRTdGF0ZVxuICAgKiAgIGB0cnVlYCBpZiB0aGUgY2FsbCB0byB7QGxpbmsgRXZlbnRlZFN0YXRlI2NoYW5nZVN0YXRlIGAuY2hhbmdlU3RhdGUoKWB9IGRpZG4ndCBjYXVzZSBhY3R1YWwgY2hhbmdlIGluIHN0YXRlLlxuICAgKi9cblxuXG4gIHJldHVybiBFdmVudGVkU3RhdGU7XG59IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKFRvTWl4KSB7XG4gIC8qKlxuICAgKiBNaXgtaW4gY2xhc3MgdG8gbWFuYWdlIGhhbmRsZXMgaW4gY29tcG9uZW50LlxuICAgKiBNYW5hZ2VkIGhhbmRsZXMgYXJlIGF1dG9tYXRpY2FsbHkgcmVsZWFzZWQgd2hlbiB0aGUgY29tcG9uZW50IHdpdGggdGhpcyBjbGFzcyBtaXhlZCBpbiBpcyByZWxlYXNlZC5cbiAgICogQGNsYXNzIEhhbmRsZXNcbiAgICogQGltcGxlbWVudHMgSGFuZGxlXG4gICAqL1xuICB2YXIgSGFuZGxlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RvTWl4KSB7XG4gICAgX2luaGVyaXRzKEhhbmRsZXMsIF9Ub01peCk7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEhhbmRsZXMpO1xuXG4gICAgZnVuY3Rpb24gSGFuZGxlcygpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhbmRsZXMpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgX3RoaXMuaGFuZGxlcyA9IG5ldyBTZXQoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGFuZGxlcywgW3tcbiAgICAgIGtleTogXCJtYW5hZ2VcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyoqXG4gICAgICAgKiBNYW5hZ2VzIHRoZSBnaXZlbiBoYW5kbGUuXG4gICAgICAgKiBAcGFyYW0ge0hhbmRsZX0gaGFuZGxlIFRoZSBoYW5kbGUgdG8gbWFuYWdlLlxuICAgICAgICogQHJldHVybnMge0hhbmRsZX0gVGhlIGdpdmVuIGhhbmRsZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbWFuYWdlKGhhbmRsZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXMuYWRkKGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFN0b3AgbWFuYWdpbmcgdGhlIGdpdmVuIGhhbmRsZS5cbiAgICAgICAqIEBwYXJhbSB7SGFuZGxlfSBoYW5kbGUgVGhlIGhhbmRsZSB0byBzdG9wIG1hbmFnaW5nLlxuICAgICAgICogQHJldHVybnMge0hhbmRsZX0gVGhlIGdpdmVuIGhhbmRsZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInVubWFuYWdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5tYW5hZ2UoaGFuZGxlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcy5kZWxldGUoaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVsZWFzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgICAgICBoYW5kbGUucmVsZWFzZSgpO1xuXG4gICAgICAgICAgX3RoaXMyLmhhbmRsZXMuZGVsZXRlKGhhbmRsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoSGFuZGxlcy5wcm90b3R5cGUpLCBcInJlbGVhc2VcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGFuZGxlcztcbiAgfShUb01peCk7XG5cbiAgcmV0dXJuIEhhbmRsZXM7XG59IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgZXZlbnRNYXRjaGVzIGZyb20gJy4uL21pc2MvZXZlbnQtbWF0Y2hlcyc7XG5pbXBvcnQgb24gZnJvbSAnLi4vbWlzYy9vbic7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoVG9NaXgpIHtcbiAgLyoqXG4gICAqIE1peC1pbiBjbGFzcyB0byBpbnN0YW50aWF0ZSBjb21wb25lbnRzIHVwb24gZXZlbnRzLlxuICAgKiBAY2xhc3MgSW5pdENvbXBvbmVudEJ5RXZlbnRcbiAgICovXG4gIHZhciBJbml0Q29tcG9uZW50QnlFdmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RvTWl4KSB7XG4gICAgX2luaGVyaXRzKEluaXRDb21wb25lbnRCeUV2ZW50LCBfVG9NaXgpO1xuXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihJbml0Q29tcG9uZW50QnlFdmVudCk7XG5cbiAgICBmdW5jdGlvbiBJbml0Q29tcG9uZW50QnlFdmVudCgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbml0Q29tcG9uZW50QnlFdmVudCk7XG5cbiAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5pdENvbXBvbmVudEJ5RXZlbnQsIG51bGwsIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6XG4gICAgICAvKipcbiAgICAgICAqIGB0cnVlYCBzdWdnZXN0cyB0aGF0IHRoaXMgY29tcG9uZW50IGlzIGxhemlseSBpbml0aWFsaXplZCB1cG9uIGFuIGFjdGlvbi9ldmVudCwgZXRjLlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBJbnN0YW50aWF0ZXMgdGhpcyBjb21wb25lbnQgaW4gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgKiBJZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbmRpY2F0ZXMgdGhhdCBpdCdzIGFuIGNvbXBvbmVudCBvZiB0aGlzIGNsYXNzLCBpbnN0YW50aWF0ZXMgaXQuXG4gICAgICAgKiBPdGhlcndpc2UsIGluc3RhbnRpYXRlcyB0aGlzIGNvbXBvbmVudCBieSBjbGlja2luZyBvbiB0aGlzIGNvbXBvbmVudCBpbiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IFRoZSBET00gbm9kZSB0byBpbnN0YW50aWF0ZSB0aGlzIGNvbXBvbmVudCBpbi4gU2hvdWxkIGJlIGEgZG9jdW1lbnQgb3IgYW4gZWxlbWVudC5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlbGVjdG9ySW5pdF0gVGhlIENTUyBzZWxlY3RvciB0byBmaW5kIHRoaXMgY29tcG9uZW50LlxuICAgICAgICogQHJldHVybnMge0hhbmRsZX0gVGhlIGhhbmRsZSB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIGhhbmRsZSBjbGlja2luZy5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkb2N1bWVudDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHRhcmdldC5ub2RlVHlwZSAhPT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRE9NIGRvY3VtZW50IG9yIERPTSBlbGVtZW50IHNob3VsZCBiZSBnaXZlbiB0byBzZWFyY2ggZm9yIGFuZCBpbml0aWFsaXplIHRoaXMgd2lkZ2V0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGFyZ2V0Lm1hdGNoZXMoZWZmZWN0aXZlT3B0aW9ucy5zZWxlY3RvckluaXQpKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCBub24tYnViYmxpbmcgYGZvY3VzYCBldmVudCwgdXNlIGBmb2N1c2luYCBldmVudCBpbnN0ZWFkIG9mIGl0J3MgYXZhaWxhYmxlLCBhbmQgXCJjYXB0dXJlIG1vZGVcIiBvdGhlcndpc2VcbiAgICAgICAgICB2YXIgaGFzRm9jdXNpbiA9ICgnb25mb2N1c2luJyBpbiAodGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA/IHRhcmdldC5vd25lckRvY3VtZW50IDogdGFyZ2V0KS5kZWZhdWx0Vmlldyk7XG4gICAgICAgICAgdmFyIGhhbmRsZXMgPSBlZmZlY3RpdmVPcHRpb25zLmluaXRFdmVudE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG5hbWUgPT09ICdmb2N1cycgJiYgaGFzRm9jdXNpbiA/ICdmb2N1c2luJyA6IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gb24odGFyZ2V0LCBldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50TWF0Y2hlcyhldmVudCwgZWZmZWN0aXZlT3B0aW9ucy5zZWxlY3RvckluaXQpOyAvLyBJbnN0YW50aWF0ZWQgY29tcG9uZW50cyBoYW5kbGVzIGV2ZW50cyBieSB0aGVtc2VsdmVzXG5cbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgIV90aGlzLmNvbXBvbmVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLmNyZWF0ZShlbGVtZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmNyZWF0ZWRCeUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQuY3JlYXRlZEJ5RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbmFtZSA9PT0gJ2ZvY3VzJyAmJiAhaGFzRm9jdXNpbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGhhbmRsZSA9IGhhbmRsZXMucG9wKCk7IGhhbmRsZTsgaGFuZGxlID0gaGFuZGxlcy5wb3AoKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZS5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIEluaXRDb21wb25lbnRCeUV2ZW50LmZvckxhenlJbml0ID0gdHJ1ZTtcbiAgICByZXR1cm4gSW5pdENvbXBvbmVudEJ5RXZlbnQ7XG4gIH0oVG9NaXgpO1xuXG4gIHJldHVybiBJbml0Q29tcG9uZW50QnlFdmVudDtcbn0iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmltcG9ydCBldmVudE1hdGNoZXMgZnJvbSAnLi4vbWlzYy9ldmVudC1tYXRjaGVzJztcbmltcG9ydCBvbiBmcm9tICcuLi9taXNjL29uJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChUb01peCkge1xuICAvKipcbiAgICogTWl4LWluIGNsYXNzIHRvIGluc3RhbnRpYXRlIGNvbXBvbmVudHMgZXZlbnRzIG9uIGxhdW5jaGVyIGJ1dHRvbi5cbiAgICogQGNsYXNzIEluaXRDb21wb25lbnRCeUxhdW5jaGVyXG4gICAqL1xuICB2YXIgSW5pdENvbXBvbmVudEJ5TGF1bmNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ub01peCkge1xuICAgIF9pbmhlcml0cyhJbml0Q29tcG9uZW50QnlMYXVuY2hlciwgX1RvTWl4KTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSW5pdENvbXBvbmVudEJ5TGF1bmNoZXIpO1xuXG4gICAgZnVuY3Rpb24gSW5pdENvbXBvbmVudEJ5TGF1bmNoZXIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5pdENvbXBvbmVudEJ5TGF1bmNoZXIpO1xuXG4gICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEluaXRDb21wb25lbnRCeUxhdW5jaGVyLCBudWxsLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyoqXG4gICAgICAgKiBgdHJ1ZWAgc3VnZ2VzdHMgdGhhdCB0aGlzIGNvbXBvbmVudCBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgdXBvbiBhbiBhY3Rpb24vZXZlbnQsIGV0Yy5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogSW5zdGFudGlhdGVzIHRoaXMgY29tcG9uZW50IGluIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICogSWYgdGhlIGdpdmVuIGVsZW1lbnQgaW5kaWNhdGVzIHRoYXQgaXQncyBhbiBjb21wb25lbnQgb2YgdGhpcyBjbGFzcywgaW5zdGFudGlhdGVzIGl0LlxuICAgICAgICogT3RoZXJ3aXNlLCBpbnN0YW50aWF0ZXMgdGhpcyBjb21wb25lbnQgYnkgY2xpY2tpbmcgb24gbGF1bmNoZXIgYnV0dG9uc1xuICAgICAgICogKGJ1dHRvbnMgd2l0aCBhdHRyaWJ1dGUgdGhhdCBgb3B0aW9ucy5hdHRyaWJJbml0VGFyZ2V0YCBwb2ludHMgdG8pIG9mIHRoaXMgY29tcG9uZW50IGluIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXQgVGhlIERPTSBub2RlIHRvIGluc3RhbnRpYXRlIHRoaXMgY29tcG9uZW50IGluLiBTaG91bGQgYmUgYSBkb2N1bWVudCBvciBhbiBlbGVtZW50LlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VsZWN0b3JJbml0XSBUaGUgQ1NTIHNlbGVjdG9yIHRvIGZpbmQgdGhpcyBjb21wb25lbnQuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXR0cmliSW5pdFRhcmdldF0gVGhlIGF0dHJpYnV0ZSBuYW1lIGluIHRoZSBsYXVuY2hlciBidXR0b25zIHRvIGZpbmQgdGFyZ2V0IGNvbXBvbmVudC5cbiAgICAgICAqIEByZXR1cm5zIHtIYW5kbGV9IFRoZSBoYW5kbGUgdG8gcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lciB0byBoYW5kbGUgY2xpY2tpbmcuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZG9jdW1lbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0YXJnZXQubm9kZVR5cGUgIT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RPTSBkb2N1bWVudCBvciBET00gZWxlbWVudCBzaG91bGQgYmUgZ2l2ZW4gdG8gc2VhcmNoIGZvciBhbmQgaW5pdGlhbGl6ZSB0aGlzIHdpZGdldC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHRhcmdldC5tYXRjaGVzKGVmZmVjdGl2ZU9wdGlvbnMuc2VsZWN0b3JJbml0KSkge1xuICAgICAgICAgIHRoaXMuY3JlYXRlKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXMgPSBlZmZlY3RpdmVPcHRpb25zLmluaXRFdmVudE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9uKHRhcmdldCwgbmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhciBsYXVuY2hlciA9IGV2ZW50TWF0Y2hlcyhldmVudCwgXCJbXCIuY29uY2F0KGVmZmVjdGl2ZU9wdGlvbnMuYXR0cmliSW5pdFRhcmdldCwgXCJdXCIpKTtcblxuICAgICAgICAgICAgICBpZiAobGF1bmNoZXIpIHtcbiAgICAgICAgICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IGxhdW5jaGVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBsYXVuY2hlci5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwobGF1bmNoZXIuZ2V0QXR0cmlidXRlKGVmZmVjdGl2ZU9wdGlvbnMuYXR0cmliSW5pdFRhcmdldCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IHdpZGdldCBtdXN0IGJlIHVuaXF1ZS4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF1bmNoZXIudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jcmVhdGUoZWxlbWVudHNbMF0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5jcmVhdGVkQnlMYXVuY2hlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuY3JlYXRlZEJ5TGF1bmNoZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGhhbmRsZSA9IGhhbmRsZXMucG9wKCk7IGhhbmRsZTsgaGFuZGxlID0gaGFuZGxlcy5wb3AoKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZS5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIEluaXRDb21wb25lbnRCeUxhdW5jaGVyLmZvckxhenlJbml0ID0gdHJ1ZTtcbiAgICByZXR1cm4gSW5pdENvbXBvbmVudEJ5TGF1bmNoZXI7XG4gIH0oVG9NaXgpO1xuXG4gIHJldHVybiBJbml0Q29tcG9uZW50QnlMYXVuY2hlcjtcbn0iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChUb01peCkge1xuICAvKipcbiAgICogTWl4LWluIGNsYXNzIHRvIGluc3RhbnRpYXRlIGNvbXBvbmVudHMgYnkgc2VhcmNoaW5nIGZvciB0aGVpciByb290IGVsZW1lbnRzLlxuICAgKiBAY2xhc3MgSW5pdENvbXBvbmVudEJ5U2VhcmNoXG4gICAqL1xuICB2YXIgSW5pdENvbXBvbmVudEJ5U2VhcmNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVG9NaXgpIHtcbiAgICBfaW5oZXJpdHMoSW5pdENvbXBvbmVudEJ5U2VhcmNoLCBfVG9NaXgpO1xuXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihJbml0Q29tcG9uZW50QnlTZWFyY2gpO1xuXG4gICAgZnVuY3Rpb24gSW5pdENvbXBvbmVudEJ5U2VhcmNoKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluaXRDb21wb25lbnRCeVNlYXJjaCk7XG5cbiAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5pdENvbXBvbmVudEJ5U2VhcmNoLCBudWxsLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyoqXG4gICAgICAgKiBJbnN0YW50aWF0ZXMgY29tcG9uZW50IGluIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICogSWYgdGhlIGdpdmVuIGVsZW1lbnQgaW5kaWNhdGVzIHRoYXQgaXQncyBhbiBjb21wb25lbnQgb2YgdGhpcyBjbGFzcywgaW5zdGFudGlhdGVzIGl0LlxuICAgICAgICogT3RoZXJ3aXNlLCBpbnN0YW50aWF0ZXMgY29tcG9uZW50cyBieSBzZWFyY2hpbmcgZm9yIGNvbXBvbmVudHMgaW4gdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCBUaGUgRE9NIG5vZGUgdG8gaW5zdGFudGlhdGUgY29tcG9uZW50cyBpbi4gU2hvdWxkIGJlIGEgZG9jdW1lbnQgb3IgYW4gZWxlbWVudC5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWxlY3RvckluaXRdIFRoZSBDU1Mgc2VsZWN0b3IgdG8gZmluZCBjb21wb25lbnRzLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRvY3VtZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIHZhciBlZmZlY3RpdmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICghdGFyZ2V0IHx8IHRhcmdldC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGFyZ2V0Lm5vZGVUeXBlICE9PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdET00gZG9jdW1lbnQgb3IgRE9NIGVsZW1lbnQgc2hvdWxkIGJlIGdpdmVuIHRvIHNlYXJjaCBmb3IgYW5kIGluaXRpYWxpemUgdGhpcyB3aWRnZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0YXJnZXQubWF0Y2hlcyhlZmZlY3RpdmVPcHRpb25zLnNlbGVjdG9ySW5pdCkpIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZSh0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoZWZmZWN0aXZlT3B0aW9ucy5zZWxlY3RvckluaXQpLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbml0Q29tcG9uZW50QnlTZWFyY2g7XG4gIH0oVG9NaXgpO1xuXG4gIHJldHVybiBJbml0Q29tcG9uZW50QnlTZWFyY2g7XG59IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5pbXBvcnQgb24gZnJvbSAnLi4vbWlzYy9vbic7XG5pbXBvcnQgaGFuZGxlcyBmcm9tICcuL2hhbmRsZXMnO1xuXG5mdW5jdGlvbiB0cmFja0JsdXIoVG9NaXgpIHtcbiAgdmFyIFRyYWNrQmx1ciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RvTWl4KSB7XG4gICAgX2luaGVyaXRzKFRyYWNrQmx1ciwgX1RvTWl4KTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVHJhY2tCbHVyKTtcbiAgICAvKipcbiAgICAgKiBNaXgtaW4gY2xhc3MgdG8gYWRkIGFuIGhhbmRsZXIgZm9yIGxvc2luZyBmb2N1cy5cbiAgICAgKiBAZXh0ZW5kcyBIYW5kbGVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3b3JraW5nIGFzIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBUcmFja0JsdXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2tCbHVyKTtcblxuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIHZhciBoYXNGb2N1c2luID0gKCdvbmZvY3VzaW4nIGluIHdpbmRvdyk7XG4gICAgICB2YXIgZm9jdXNpbkV2ZW50TmFtZSA9IGhhc0ZvY3VzaW4gPyAnZm9jdXNpbicgOiAnZm9jdXMnO1xuICAgICAgdmFyIGZvY3Vzb3V0RXZlbnROYW1lID0gaGFzRm9jdXNpbiA/ICdmb2N1c291dCcgOiAnYmx1cic7XG5cbiAgICAgIF90aGlzLm1hbmFnZShvbihfdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQsIGZvY3VzaW5FdmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIShfdGhpcy5vcHRpb25zLmNvbnRlbnROb2RlIHx8IF90aGlzLmVsZW1lbnQpLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBfdGhpcy5oYW5kbGVCbHVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgIWhhc0ZvY3VzaW4pKTtcblxuICAgICAgX3RoaXMubWFuYWdlKG9uKF90aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudCwgZm9jdXNvdXRFdmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICBfdGhpcy5oYW5kbGVCbHVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgIWhhc0ZvY3VzaW4pKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGxvc2VzIGZvY3VzLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJhY2tCbHVyLCBbe1xuICAgICAga2V5OiBcImhhbmRsZUJsdXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudHMgaW5oZXJpdGluZyBUcmFja0JsdXIgbWl4LWluIG11c3QgaW1wbGVtZW50IGhhbmRsZUJsdXIoKSBtZXRob2QuJyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRyYWNrQmx1cjtcbiAgfShUb01peCk7XG5cbiAgcmV0dXJuIFRyYWNrQmx1cjtcbn1cblxudmFyIGV4cG9ydHMgPSBbaGFuZGxlcywgdHJhY2tCbHVyXTtcbmV4cG9ydCBkZWZhdWx0IGV4cG9ydHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyoqXG4gKiBTZXR0aW5ncy5cbiAqIEBleHBvcnRzIENhcmJvbkNvbXBvbmVudHMuc2V0dGluZ3NcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZUF1dG9Jbml0XVxuICogICBEaXNhYmxlcyBhdXRvbWF0aWMgaW5zdGFudGlhdGlvbiBvZiBjb21wb25lbnRzLlxuICogICBCeSBkZWZhdWx0IChgQ2FyYm9uQ29tcG9uZW50cy5kaXNhYmxlQXV0b0luaXRgIGlzIGBmYWxzZWApLFxuICogICBjYXJib24tY29tcG9uZW50cyBhdHRlbXB0cyB0byBpbnN0YW50aWF0ZSBjb21wb25lbnRzIGF1dG9tYXRpY2FsbHlcbiAqICAgYnkgc2VhcmNoaW5nIGZvciBlbGVtZW50cyB3aXRoIGBkYXRhLWNvbXBvbmVudC1uYW1lYCAoZS5nLiBgZGF0YS1sb2FkaW5nYCkgYXR0cmlidXRlXG4gKiAgIG9yIHVwb24gRE9NIGV2ZW50cyAoZS5nLiBjbGlja2luZykgb24gc3VjaCBlbGVtZW50cy5cbiAqICAgU2VlIGVhY2ggY29tcG9uZW50cycgc3RhdGljIGAuaW5pdCgpYCBtZXRob2RzIGZvciBkZXRhaWxzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwcmVmaXg9YnhdXG4gKiAgIEJyYW5kIHByZWZpeC4gU2hvdWxkIGJlIGluIHN5bmMgd2l0aCBgJHByZWZpeGAgU2FzcyB2YXJpYWJsZSBpbiBjYXJib24tY29tcG9uZW50cy9zcmMvZ2xvYmFscy9zY3NzL192YXJzLnNjc3MuXG4gKiAvLyBAdG9kbyBnaXZlbiB0aGF0IHRoZSBkZWZhdWx0IHZhbHVlIGlzIHNvIGxvbmcsIGlzIGl0IGFwcHJvcHJpYXRlIHRvIHB1dCBpbiB0aGUgSlNEb2M/XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yVGFiYmFibGVdXG4gKiAgIEEgc2VsZWN0b3Igc2VsZWN0aW5nIHRhYmJhYmxlL2ZvY3VzYWJsZSBub2Rlcy5cbiAqICAgQnkgZGVmYXVsdCBzZWxlY3RvclRhYmJhYmxlIHJlZmVyZW5jZXMgbGlua3MsIGFyZWFzLCBpbnB1dHMsIGJ1dHRvbnMsIHNlbGVjdHMsIHRleHRhcmVhcyxcbiAqICAgaWZyYW1lcywgb2JqZWN0cywgZW1iZWRzLCBvciBlbGVtZW50cyBleHBsaWNpdGx5IHVzaW5nIHRhYmluZGV4IG9yIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGVzXG4gKiAgIGFzIGxvbmcgYXMgdGhlIGVsZW1lbnQgaXMgbm90IGBkaXNhYmxlZGAgb3IgdGhlIGB0YWJpbmRleD1cIi0xXCJgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvckZvY3VzYWJsZV1cbiAqICAgQ1NTIHNlbGVjdG9yIHRoYXQgc2VsZWN0cyBtYWpvciBub2RlcyB0aGF0IGFyZSBjbGljayBmb2N1c2FibGVcbiAqICAgVGhpcyBwcm9wZXJ0eSBpcyBpZGVudGljYWwgdG8gc2VsZWN0b3JUYWJiYWJsZSB3aXRoIHRoZSBleGNlcHRpb24gb2ZcbiAqICAgdGhlIGA6bm90KFt0YWJpbmRleD0nLTEnXSlgIHBzZXVkbyBjbGFzc1xuICovXG52YXIgc2V0dGluZ3MgPSB7XG4gIHByZWZpeDogJ2J4JyxcbiAgc2VsZWN0b3JUYWJiYWJsZTogXCJcXG4gICAgYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9Jy0xJ10pLFxcbiAgICBidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9Jy0xJ10pLHNlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD0nLTEnXSksXFxuICAgIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PSctMSddKSxcXG4gICAgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PSctMSddKSwgKltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cXG4gIFwiLFxuICBzZWxlY3RvckZvY3VzYWJsZTogXCJcXG4gICAgYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLFxcbiAgICBidXR0b246bm90KFtkaXNhYmxlZF0pLHNlbGVjdDpub3QoW2Rpc2FibGVkXSksXFxuICAgIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSxcXG4gICAgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cXG4gIFwiXG59O1xudmFyIHNldHRpbmdzXzEgPSBzZXR0aW5ncztcbmV4cG9ydCBkZWZhdWx0IHNldHRpbmdzXzE7IiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMThcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbi8vID09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEltcG9ydHMgYW5kIEV4cG9ydHMgLy9cbi8vID09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEJhc2UgRWxlbWVudHMgJiBDb21wb25lbnRzXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAtIEphdmFTY3JpcHQgY2xhc3NlcyBmb3IgdXNlIHdpdGggY29tcG9uZW50cyBhbmQgYmFzZS1lbGVtZW50cy5cbi8vIC0gVGhlIGZvbGxvd2luZyBzdGF0ZW1lbnRzIGltcG9ydCBjbGFzc2VzIGZyb20gYWN0dWFsIGxvY2F0aW9ucyB0b1xuLy8gICBiZSBjb25zdW1lZCBmcm9tIHRoaXMgZmlsZSBpbnN0ZWFkIG9mIHRoZWlyIGFjdHVhbCBsb2NhdGlvbnMuXG5leHBvcnQgKiBmcm9tICcuL2dsb2JhbHMvanMvY29tcG9uZW50cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNldHRpbmdzIH0gZnJvbSAnLi9nbG9iYWxzL2pzL3NldHRpbmdzJzsiLCIvKiBmbGF0cGlja3IgdjQuNi4xLCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuZmxhdHBpY2tyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbiAgICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG4gICAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAgICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbiAgICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gICAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcbiAgICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuICAgIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcblxuICAgIHZhciBIT09LUyA9IFtcbiAgICAgICAgXCJvbkNoYW5nZVwiLFxuICAgICAgICBcIm9uQ2xvc2VcIixcbiAgICAgICAgXCJvbkRheUNyZWF0ZVwiLFxuICAgICAgICBcIm9uRGVzdHJveVwiLFxuICAgICAgICBcIm9uS2V5RG93blwiLFxuICAgICAgICBcIm9uTW9udGhDaGFuZ2VcIixcbiAgICAgICAgXCJvbk9wZW5cIixcbiAgICAgICAgXCJvblBhcnNlQ29uZmlnXCIsXG4gICAgICAgIFwib25SZWFkeVwiLFxuICAgICAgICBcIm9uVmFsdWVVcGRhdGVcIixcbiAgICAgICAgXCJvblllYXJDaGFuZ2VcIixcbiAgICAgICAgXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIixcbiAgICBdO1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgX2Rpc2FibGU6IFtdLFxuICAgICAgICBfZW5hYmxlOiBbXSxcbiAgICAgICAgYWxsb3dJbnB1dDogZmFsc2UsXG4gICAgICAgIGFsdEZvcm1hdDogXCJGIGosIFlcIixcbiAgICAgICAgYWx0SW5wdXQ6IGZhbHNlLFxuICAgICAgICBhbHRJbnB1dENsYXNzOiBcImZvcm0tY29udHJvbCBpbnB1dFwiLFxuICAgICAgICBhbmltYXRlOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA9PT0gLTEsXG4gICAgICAgIGFyaWFEYXRlRm9ybWF0OiBcIkYgaiwgWVwiLFxuICAgICAgICBjbGlja09wZW5zOiB0cnVlLFxuICAgICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgICBjb25qdW5jdGlvbjogXCIsIFwiLFxuICAgICAgICBkYXRlRm9ybWF0OiBcIlktbS1kXCIsXG4gICAgICAgIGRlZmF1bHRIb3VyOiAxMixcbiAgICAgICAgZGVmYXVsdE1pbnV0ZTogMCxcbiAgICAgICAgZGVmYXVsdFNlY29uZHM6IDAsXG4gICAgICAgIGRpc2FibGU6IFtdLFxuICAgICAgICBkaXNhYmxlTW9iaWxlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlOiBbXSxcbiAgICAgICAgZW5hYmxlU2Vjb25kczogZmFsc2UsXG4gICAgICAgIGVuYWJsZVRpbWU6IGZhbHNlLFxuICAgICAgICBlcnJvckhhbmRsZXI6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2VlazogZnVuY3Rpb24gKGdpdmVuRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShnaXZlbkRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAvLyBUaHVyc2RheSBpbiBjdXJyZW50IHdlZWsgZGVjaWRlcyB0aGUgeWVhci5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDMgLSAoKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpKTtcbiAgICAgICAgICAgIC8vIEphbnVhcnkgNCBpcyBhbHdheXMgaW4gd2VlayAxLlxuICAgICAgICAgICAgdmFyIHdlZWsxID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0byBUaHVyc2RheSBpbiB3ZWVrIDEgYW5kIGNvdW50IG51bWJlciBvZiB3ZWVrcyBmcm9tIGRhdGUgdG8gd2VlazEuXG4gICAgICAgICAgICByZXR1cm4gKDEgK1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKChkYXRlLmdldFRpbWUoKSAtIHdlZWsxLmdldFRpbWUoKSkgLyA4NjQwMDAwMCAtXG4gICAgICAgICAgICAgICAgICAgIDMgK1xuICAgICAgICAgICAgICAgICAgICAoKHdlZWsxLmdldERheSgpICsgNikgJSA3KSkgL1xuICAgICAgICAgICAgICAgICAgICA3KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhvdXJJbmNyZW1lbnQ6IDEsXG4gICAgICAgIGlnbm9yZWRGb2N1c0VsZW1lbnRzOiBbXSxcbiAgICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgICAgbG9jYWxlOiBcImRlZmF1bHRcIixcbiAgICAgICAgbWludXRlSW5jcmVtZW50OiA1LFxuICAgICAgICBtb2RlOiBcInNpbmdsZVwiLFxuICAgICAgICBuZXh0QXJyb3c6IFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J00xMy4yMDcgOC40NzJsLTcuODU0IDcuODU0LTAuNzA3LTAuNzA3IDcuMTQ2LTcuMTQ2LTcuMTQ2LTcuMTQ4IDAuNzA3LTAuNzA3IDcuODU0IDcuODU0eicgLz48L3N2Zz5cIixcbiAgICAgICAgbm9DYWxlbmRhcjogZmFsc2UsXG4gICAgICAgIG5vdzogbmV3IERhdGUoKSxcbiAgICAgICAgb25DaGFuZ2U6IFtdLFxuICAgICAgICBvbkNsb3NlOiBbXSxcbiAgICAgICAgb25EYXlDcmVhdGU6IFtdLFxuICAgICAgICBvbkRlc3Ryb3k6IFtdLFxuICAgICAgICBvbktleURvd246IFtdLFxuICAgICAgICBvbk1vbnRoQ2hhbmdlOiBbXSxcbiAgICAgICAgb25PcGVuOiBbXSxcbiAgICAgICAgb25QYXJzZUNvbmZpZzogW10sXG4gICAgICAgIG9uUmVhZHk6IFtdLFxuICAgICAgICBvblZhbHVlVXBkYXRlOiBbXSxcbiAgICAgICAgb25ZZWFyQ2hhbmdlOiBbXSxcbiAgICAgICAgb25QcmVDYWxlbmRhclBvc2l0aW9uOiBbXSxcbiAgICAgICAgcGx1Z2luczogW10sXG4gICAgICAgIHBvc2l0aW9uOiBcImF1dG9cIixcbiAgICAgICAgcG9zaXRpb25FbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTUuMjA3IDguNDcxbDcuMTQ2IDcuMTQ3LTAuNzA3IDAuNzA3LTcuODUzLTcuODU0IDcuODU0LTcuODUzIDAuNzA3IDAuNzA3LTcuMTQ3IDcuMTQ2eicgLz48L3N2Zz5cIixcbiAgICAgICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoOiBmYWxzZSxcbiAgICAgICAgc2hvd01vbnRoczogMSxcbiAgICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgICAgdGltZV8yNGhyOiBmYWxzZSxcbiAgICAgICAgd2Vla051bWJlcnM6IGZhbHNlLFxuICAgICAgICB3cmFwOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YXIgZW5nbGlzaCA9IHtcbiAgICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgICAgIHNob3J0aGFuZDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIlN1bmRheVwiLFxuICAgICAgICAgICAgICAgIFwiTW9uZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJUdWVzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJXZWRuZXNkYXlcIixcbiAgICAgICAgICAgICAgICBcIlRodXJzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJGcmlkYXlcIixcbiAgICAgICAgICAgICAgICBcIlNhdHVyZGF5XCIsXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoczoge1xuICAgICAgICAgICAgc2hvcnRoYW5kOiBbXG4gICAgICAgICAgICAgICAgXCJKYW5cIixcbiAgICAgICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgICAgIFwiTWFyXCIsXG4gICAgICAgICAgICAgICAgXCJBcHJcIixcbiAgICAgICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgICAgIFwiSnVuXCIsXG4gICAgICAgICAgICAgICAgXCJKdWxcIixcbiAgICAgICAgICAgICAgICBcIkF1Z1wiLFxuICAgICAgICAgICAgICAgIFwiU2VwXCIsXG4gICAgICAgICAgICAgICAgXCJPY3RcIixcbiAgICAgICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgICAgIFwiRGVjXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIkphbnVhcnlcIixcbiAgICAgICAgICAgICAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgICAgICAgICAgICAgXCJNYXJjaFwiLFxuICAgICAgICAgICAgICAgIFwiQXByaWxcIixcbiAgICAgICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgICAgIFwiSnVuZVwiLFxuICAgICAgICAgICAgICAgIFwiSnVseVwiLFxuICAgICAgICAgICAgICAgIFwiQXVndXN0XCIsXG4gICAgICAgICAgICAgICAgXCJTZXB0ZW1iZXJcIixcbiAgICAgICAgICAgICAgICBcIk9jdG9iZXJcIixcbiAgICAgICAgICAgICAgICBcIk5vdmVtYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJEZWNlbWJlclwiLFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBkYXlzSW5Nb250aDogWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdLFxuICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG50aCkge1xuICAgICAgICAgICAgdmFyIHMgPSBudGggJSAxMDA7XG4gICAgICAgICAgICBpZiAocyA+IDMgJiYgcyA8IDIxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICBzd2l0Y2ggKHMgJSAxMCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyZFwiO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiB0byBcIixcbiAgICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJXa1wiLFxuICAgICAgICBzY3JvbGxUaXRsZTogXCJTY3JvbGwgdG8gaW5jcmVtZW50XCIsXG4gICAgICAgIHRvZ2dsZVRpdGxlOiBcIkNsaWNrIHRvIHRvZ2dsZVwiLFxuICAgICAgICBhbVBNOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgICAgICB5ZWFyQXJpYUxhYmVsOiBcIlllYXJcIixcbiAgICAgICAgdGltZV8yNGhyOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YXIgcGFkID0gZnVuY3Rpb24gKG51bWJlcikgeyByZXR1cm4gKFwiMFwiICsgbnVtYmVyKS5zbGljZSgtMik7IH07XG4gICAgdmFyIGludCA9IGZ1bmN0aW9uIChib29sKSB7IHJldHVybiAoYm9vbCA9PT0gdHJ1ZSA/IDEgOiAwKTsgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgICAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aW1lb3V0ICE9PSBudWxsICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgICAgIGlmIChpbW1lZGlhdGUgJiYgIXRpbWVvdXQpXG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGFycmF5aWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiBbb2JqXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lLCBib29sKSB7XG4gICAgICAgIGlmIChib29sID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZSwgY29udGVudCkge1xuICAgICAgICB2YXIgZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCBcIlwiO1xuICAgICAgICBjb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgICAgICBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFBhcmVudChub2RlLCBjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmluZFBhcmVudChub2RlLnBhcmVudE5vZGUsIGNvbmRpdGlvbik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIG5vdGhpbmcgZm91bmRcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTnVtYmVySW5wdXQoaW5wdXRDbGFzc05hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwibnVtSW5wdXRXcmFwcGVyXCIpLCBudW1JbnB1dCA9IGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBcIm51bUlucHV0IFwiICsgaW5wdXRDbGFzc05hbWUpLCBhcnJvd1VwID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd1VwXCIpLCBhcnJvd0Rvd24gPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImFycm93RG93blwiKTtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgOS4wXCIpID09PSAtMSkge1xuICAgICAgICAgICAgbnVtSW5wdXQudHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBudW1JbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBudW1JbnB1dC5wYXR0ZXJuID0gXCJcXFxcZCpcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXG4gICAgICAgICAgICAgICAgbnVtSW5wdXQuc2V0QXR0cmlidXRlKGtleSwgb3B0c1trZXldKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChudW1JbnB1dCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dVcCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dEb3duKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuY29tcG9zZWRQYXRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb05vdGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgdmFyIG1vbnRoVG9TdHIgPSBmdW5jdGlvbiAobW9udGhOdW1iZXIsIHNob3J0aGFuZCwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUubW9udGhzW3Nob3J0aGFuZCA/IFwic2hvcnRoYW5kXCIgOiBcImxvbmdoYW5kXCJdW21vbnRoTnVtYmVyXTsgfTtcbiAgICB2YXIgcmV2Rm9ybWF0ID0ge1xuICAgICAgICBEOiBkb05vdGhpbmcsXG4gICAgICAgIEY6IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aE5hbWUsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLmxvbmdoYW5kLmluZGV4T2YobW9udGhOYW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEc6IGZ1bmN0aW9uIChkYXRlT2JqLCBob3VyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgICB9LFxuICAgICAgICBIOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSjogZnVuY3Rpb24gKGRhdGVPYmosIGRheSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICAgIH0sXG4gICAgICAgIEs6IGZ1bmN0aW9uIChkYXRlT2JqLCBhbVBNLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMoKGRhdGVPYmouZ2V0SG91cnMoKSAlIDEyKSArXG4gICAgICAgICAgICAgICAgMTIgKiBpbnQobmV3IFJlZ0V4cChsb2NhbGUuYW1QTVsxXSwgXCJpXCIpLnRlc3QoYW1QTSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgTTogZnVuY3Rpb24gKGRhdGVPYmosIHNob3J0TW9udGgsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLnNob3J0aGFuZC5pbmRleE9mKHNob3J0TW9udGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgUzogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgVTogZnVuY3Rpb24gKF8sIHVuaXhTZWNvbmRzKSB7IHJldHVybiBuZXcgRGF0ZShwYXJzZUZsb2F0KHVuaXhTZWNvbmRzKSAqIDEwMDApOyB9LFxuICAgICAgICBXOiBmdW5jdGlvbiAoZGF0ZU9iaiwgd2Vla051bSwgbG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlciA9IHBhcnNlSW50KHdlZWtOdW0pO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShkYXRlT2JqLmdldEZ1bGxZZWFyKCksIDAsIDIgKyAod2Vla051bWJlciAtIDEpICogNywgMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpICsgbG9jYWxlLmZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9LFxuICAgICAgICBZOiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcihwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgWjogZnVuY3Rpb24gKF8sIElTT0RhdGUpIHsgcmV0dXJuIG5ldyBEYXRlKElTT0RhdGUpOyB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlT2JqLCBtaW51dGVzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1pbnV0ZXMocGFyc2VGbG9hdChtaW51dGVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBsOiBkb05vdGhpbmcsXG4gICAgICAgIG06IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aCkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBuOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgczogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdTogZnVuY3Rpb24gKF8sIHVuaXhNaWxsU2Vjb25kcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peE1pbGxTZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHc6IGRvTm90aGluZyxcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGVPYmosIHllYXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RnVsbFllYXIoMjAwMCArIHBhcnNlRmxvYXQoeWVhcikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdG9rZW5SZWdleCA9IHtcbiAgICAgICAgRDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBGOiBcIihcXFxcdyspXCIsXG4gICAgICAgIEc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEo6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXFxcXHcrXCIsXG4gICAgICAgIEs6IFwiXCIsXG4gICAgICAgIE06IFwiKFxcXFx3KylcIixcbiAgICAgICAgUzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgVTogXCIoLispXCIsXG4gICAgICAgIFc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIFk6IFwiKFxcXFxkezR9KVwiLFxuICAgICAgICBaOiBcIiguKylcIixcbiAgICAgICAgZDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaTogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgajogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgbDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBtOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBuOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBzOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICB1OiBcIiguKylcIixcbiAgICAgICAgdzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgeTogXCIoXFxcXGR7Mn0pXCJcbiAgICB9O1xuICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgICAvLyBnZXQgdGhlIGRhdGUgaW4gVVRDXG4gICAgICAgIFo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7IH0sXG4gICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgc2hvcnQsIGUuZy4gVGh1XG4gICAgICAgIEQ6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXMuc2hvcnRoYW5kW2Zvcm1hdHMudyhkYXRlLCBsb2NhbGUsIG9wdGlvbnMpXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZnVsbCBtb250aCBuYW1lIGUuZy4gSmFudWFyeVxuICAgICAgICBGOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhUb1N0cihmb3JtYXRzLm4oZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSAtIDEsIGZhbHNlLCBsb2NhbGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwYWRkZWQgaG91ciAxLTEyXG4gICAgICAgIEc6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWQoZm9ybWF0cy5oKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBob3VycyB3aXRoIGxlYWRpbmcgemVybyBlLmcuIDAzXG4gICAgICAgIEg6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRIb3VycygpKTsgfSxcbiAgICAgICAgLy8gZGF5ICgxLTMwKSB3aXRoIG9yZGluYWwgc3VmZml4IGUuZy4gMXN0LCAybmRcbiAgICAgICAgSjogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5vcmRpbmFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGRhdGUuZ2V0RGF0ZSgpICsgbG9jYWxlLm9yZGluYWwoZGF0ZS5nZXREYXRlKCkpXG4gICAgICAgICAgICAgICAgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQU0vUE1cbiAgICAgICAgSzogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkgeyByZXR1cm4gbG9jYWxlLmFtUE1baW50KGRhdGUuZ2V0SG91cnMoKSA+IDExKV07IH0sXG4gICAgICAgIC8vIHNob3J0aGFuZCBtb250aCBlLmcuIEphbiwgU2VwLCBPY3QsIGV0Y1xuICAgICAgICBNOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhUb1N0cihkYXRlLmdldE1vbnRoKCksIHRydWUsIGxvY2FsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHNlY29uZHMgMDAtNTlcbiAgICAgICAgUzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldFNlY29uZHMoKSk7IH0sXG4gICAgICAgIC8vIHVuaXggdGltZXN0YW1wXG4gICAgICAgIFU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7IH0sXG4gICAgICAgIFc6IGZ1bmN0aW9uIChkYXRlLCBfLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXRXZWVrKGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmdWxsIHllYXIgZS5nLiAyMDE2XG4gICAgICAgIFk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7IH0sXG4gICAgICAgIC8vIGRheSBpbiBtb250aCwgcGFkZGVkICgwMS0zMClcbiAgICAgICAgZDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSk7IH0sXG4gICAgICAgIC8vIGhvdXIgZnJvbSAxLTEyIChhbS9wbSlcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChkYXRlLmdldEhvdXJzKCkgJSAxMiA/IGRhdGUuZ2V0SG91cnMoKSAlIDEyIDogMTIpOyB9LFxuICAgICAgICAvLyBtaW51dGVzLCBwYWRkZWQgd2l0aCBsZWFkaW5nIHplcm8gZS5nLiAwOVxuICAgICAgICBpOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0TWludXRlcygpKTsgfSxcbiAgICAgICAgLy8gZGF5IGluIG1vbnRoICgxLTMwKVxuICAgICAgICBqOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXRlKCk7IH0sXG4gICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgZnVsbCwgZS5nLiBUaHVyc2RheVxuICAgICAgICBsOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzLmxvbmdoYW5kW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwYWRkZWQgbW9udGggbnVtYmVyICgwMS0xMilcbiAgICAgICAgbTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKTsgfSxcbiAgICAgICAgLy8gdGhlIG1vbnRoIG51bWJlciAoMS0xMilcbiAgICAgICAgbjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7IH0sXG4gICAgICAgIC8vIHNlY29uZHMgMC01OVxuICAgICAgICBzOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7IH0sXG4gICAgICAgIC8vIFVuaXggTWlsbGlzZWNvbmRzXG4gICAgICAgIHU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfSxcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgdzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7IH0sXG4gICAgICAgIC8vIGxhc3QgdHdvIGRpZ2l0cyBvZiB5ZWFyIGUuZy4gMTYgZm9yIDIwMTZcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIFN0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpLnN1YnN0cmluZygyKTsgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGF0ZUZvcm1hdHRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jb25maWcsIGNvbmZpZyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyA6IF9iLCBfYyA9IF9hLmwxMG4sIGwxMG4gPSBfYyA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9jO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGVPYmosIGZybXQsIG92ZXJyaWRlTG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gb3ZlcnJpZGVMb2NhbGUgfHwgbDEwbjtcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9ybWF0RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5mb3JtYXREYXRlKGRhdGVPYmosIGZybXQsIGxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJtdFxuICAgICAgICAgICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRzW2NdICYmIGFycltpIC0gMV0gIT09IFwiXFxcXFwiXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0c1tjXShkYXRlT2JqLCBsb2NhbGUsIGNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgOiBjICE9PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZURhdGVQYXJzZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuY29uZmlnLCBjb25maWcgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdHMgOiBfYiwgX2MgPSBfYS5sMTBuLCBsMTBuID0gX2MgPT09IHZvaWQgMCA/IGVuZ2xpc2ggOiBfYztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBnaXZlbkZvcm1hdCwgdGltZWxlc3MsIGN1c3RvbUxvY2FsZSkge1xuICAgICAgICAgICAgaWYgKGRhdGUgIT09IDAgJiYgIWRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBjdXN0b21Mb2NhbGUgfHwgbDEwbjtcbiAgICAgICAgICAgIHZhciBwYXJzZWREYXRlO1xuICAgICAgICAgICAgdmFyIGRhdGVPcmlnID0gZGF0ZTtcbiAgICAgICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRlLnRvRml4ZWQgIT09IHVuZGVmaW5lZCAvLyB0aW1lc3RhbXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb3B5XG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkYXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBnaXZlbkZvcm1hdCB8fCAoY29uZmlnIHx8IGRlZmF1bHRzKS5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgICAgIHZhciBkYXRlc3RyID0gU3RyaW5nKGRhdGUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXN0ciA9PT0gXCJ0b2RheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9aJC8udGVzdChkYXRlc3RyKSB8fFxuICAgICAgICAgICAgICAgICAgICAvR01UJC8udGVzdChkYXRlc3RyKSAvLyBkYXRlc3RyaW5ncyB3LyB0aW1lem9uZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZyAmJiBjb25maWcucGFyc2VEYXRlKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gY29uZmlnLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFjb25maWcgfHwgIWNvbmZpZy5ub0NhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSB2b2lkIDAsIG9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF0Y2hJbmRleCA9IDAsIHJlZ2V4U3RyID0gXCJcIjsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuXzEgPSBmb3JtYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNCYWNrU2xhc2ggPSB0b2tlbl8xID09PSBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkID0gZm9ybWF0W2kgLSAxXSA9PT0gXCJcXFxcXCIgfHwgaXNCYWNrU2xhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWdleFt0b2tlbl8xXSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4U3RyICs9IHRva2VuUmVnZXhbdG9rZW5fMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbmV3IFJlZ0V4cChyZWdleFN0cikuZXhlYyhkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoZWQgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHNbdG9rZW5fMSAhPT0gXCJZXCIgPyBcInB1c2hcIiA6IFwidW5zaGlmdFwiXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogcmV2Rm9ybWF0W3Rva2VuXzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiBtYXRjaFsrK21hdGNoSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JhY2tTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFN0ciArPSBcIi5cIjsgLy8gZG9uJ3QgcmVhbGx5IGNhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IF9hLmZuLCB2YWwgPSBfYS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZWREYXRlID0gZm4ocGFyc2VkRGF0ZSwgdmFsLCBsb2NhbGUpIHx8IHBhcnNlZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG1hdGNoZWQgPyBwYXJzZWREYXRlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIShwYXJzZWREYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocGFyc2VkRGF0ZS5nZXRUaW1lKCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHByb3ZpZGVkOiBcIiArIGRhdGVPcmlnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZERhdGU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGluIGRhdGVzLCBtZWFzdXJlZCBpbiBtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVEYXRlcyhkYXRlMSwgZGF0ZTIsIHRpbWVsZXNzKSB7XG4gICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGltZWxlc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKGRhdGUxLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkgLVxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGRhdGUyLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRUaW1lKCkgLSBkYXRlMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHZhciBpc0JldHdlZW4gPSBmdW5jdGlvbiAodHMsIHRzMSwgdHMyKSB7XG4gICAgICAgIHJldHVybiB0cyA+IE1hdGgubWluKHRzMSwgdHMyKSAmJiB0cyA8IE1hdGgubWF4KHRzMSwgdHMyKTtcbiAgICB9O1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgREFZOiA4NjQwMDAwMFxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBhcmdzXzEgPSBhcmdzOyBfYSA8IGFyZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJnc18xW19hXTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBERUJPVU5DRURfQ0hBTkdFX01TID0gMzAwO1xuICAgIGZ1bmN0aW9uIEZsYXRwaWNrckluc3RhbmNlKGVsZW1lbnQsIGluc3RhbmNlQ29uZmlnKSB7XG4gICAgICAgIHZhciBzZWxmID0ge1xuICAgICAgICAgICAgY29uZmlnOiBfX2Fzc2lnbih7fSwgZGVmYXVsdHMsIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnKSxcbiAgICAgICAgICAgIGwxMG46IGVuZ2xpc2hcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICBzZWxmLnBsdWdpbkVsZW1lbnRzID0gW107XG4gICAgICAgIHNlbGYubG9hZGVkUGx1Z2lucyA9IFtdO1xuICAgICAgICBzZWxmLl9iaW5kID0gYmluZDtcbiAgICAgICAgc2VsZi5fc2V0SG91cnNGcm9tRGF0ZSA9IHNldEhvdXJzRnJvbURhdGU7XG4gICAgICAgIHNlbGYuX3Bvc2l0aW9uQ2FsZW5kYXIgPSBwb3NpdGlvbkNhbGVuZGFyO1xuICAgICAgICBzZWxmLmNoYW5nZU1vbnRoID0gY2hhbmdlTW9udGg7XG4gICAgICAgIHNlbGYuY2hhbmdlWWVhciA9IGNoYW5nZVllYXI7XG4gICAgICAgIHNlbGYuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgc2VsZi5jbG9zZSA9IGNsb3NlO1xuICAgICAgICBzZWxmLl9jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgICAgICAgc2VsZi5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gICAgICAgIHNlbGYuanVtcFRvRGF0ZSA9IGp1bXBUb0RhdGU7XG4gICAgICAgIHNlbGYub3BlbiA9IG9wZW47XG4gICAgICAgIHNlbGYucmVkcmF3ID0gcmVkcmF3O1xuICAgICAgICBzZWxmLnNldCA9IHNldDtcbiAgICAgICAgc2VsZi5zZXREYXRlID0gc2V0RGF0ZTtcbiAgICAgICAgc2VsZi50b2dnbGUgPSB0b2dnbGU7XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwSGVscGVyRnVuY3Rpb25zKCkge1xuICAgICAgICAgICAgc2VsZi51dGlscyA9IHtcbiAgICAgICAgICAgICAgICBnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKG1vbnRoLCB5cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IHNlbGYuY3VycmVudE1vbnRoOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ciA9PT0gdm9pZCAwKSB7IHlyID0gc2VsZi5jdXJyZW50WWVhcjsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEgJiYgKCh5ciAlIDQgPT09IDAgJiYgeXIgJSAxMDAgIT09IDApIHx8IHlyICUgNDAwID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubDEwbi5kYXlzSW5Nb250aFttb250aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5pbnB1dCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyc2VDb25maWcoKTtcbiAgICAgICAgICAgIHNldHVwTG9jYWxlKCk7XG4gICAgICAgICAgICBzZXR1cElucHV0cygpO1xuICAgICAgICAgICAgc2V0dXBEYXRlcygpO1xuICAgICAgICAgICAgc2V0dXBIZWxwZXJGdW5jdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICBidWlsZCgpO1xuICAgICAgICAgICAgYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fCBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENhbGVuZGFyV2lkdGgoKTtcbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDAgfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcjtcbiAgICAgICAgICAgIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICAvKiBUT0RPOiBpbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXJcbiAgICAgICAgXG4gICAgICAgICAgICAgIEN1cnJlbnRseSwgdGhlcmUgaXMgd2VpcmQgcG9zaXRpb25pbmcgYmVoYXZpb3IgaW4gc2FmYXJpIGNhdXNpbmcgcGFnZXNcbiAgICAgICAgICAgICAgdG8gc2Nyb2xsIHVwLiBodHRwczovL2dpdGh1Yi5jb20vY2htbG4vZmxhdHBpY2tyL2lzc3Vlcy81NjNcbiAgICAgICAgXG4gICAgICAgICAgICAgIEhvd2V2ZXIsIG1vc3QgYnJvd3NlcnMgYXJlIG5vdCBTYWZhcmkgYW5kIHBvc2l0aW9uaW5nIGlzIGV4cGVuc2l2ZSB3aGVuIHVzZWRcbiAgICAgICAgICAgICAgaW4gc2NhbGUuIGh0dHBzOi8vZ2l0aHViLmNvbS9jaG1sbi9mbGF0cGlja3IvaXNzdWVzLzEwOTZcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUgJiYgaXNTYWZhcmkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblJlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRUb0luc3RhbmNlKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZChzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDYWxlbmRhcldpZHRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuY29uZmlnO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWVrTnVtYmVycyA9PT0gZmFsc2UgJiYgY29uZmlnLnNob3dNb250aHMgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLm5vQ2FsZW5kYXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXlzV2lkdGggPSAoc2VsZi5kYXlzLm9mZnNldFdpZHRoICsgMSkgKiBjb25maWcuc2hvd01vbnRocztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRheXNXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheXNXaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWxmLndlZWtXcmFwcGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi53ZWVrV3JhcHBlci5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhhbmRsZXIgZm9yIGFsbCBldmVudHMgdGFyZ2V0aW5nIHRoZSB0aW1lIGlucHV0c1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGltZShlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNldERlZmF1bHRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkICYmIGUudHlwZSAhPT0gXCJibHVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aW1lV3JhcHBlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBzZWxmLl9pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC52YWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYW1wbTJtaWxpdGFyeShob3VyLCBhbVBNKSB7XG4gICAgICAgICAgICByZXR1cm4gKGhvdXIgJSAxMikgKyAxMiAqIGludChhbVBNID09PSBzZWxmLmwxMG4uYW1QTVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWlsaXRhcnkyYW1wbShob3VyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhvdXIgJSAyNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgJSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGhlIHNlbGVjdGVkIGRhdGUgb2JqZWN0IHRpbWUgd2l0aCB1c2VyJ3MgdGltZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tSW5wdXRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCBzZWxmLm1pbnV0ZUVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG91cnMgPSAocGFyc2VJbnQoc2VsZi5ob3VyRWxlbWVudC52YWx1ZS5zbGljZSgtMiksIDEwKSB8fCAwKSAlIDI0LCBtaW51dGVzID0gKHBhcnNlSW50KHNlbGYubWludXRlRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjAsIHNlY29uZHMgPSBzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gKHBhcnNlSW50KHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjBcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBob3VycyA9IGFtcG0ybWlsaXRhcnkoaG91cnMsIHNlbGYuYW1QTS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGltaXRNaW5Ib3VycyA9IHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5taW5EYXRlLCB0cnVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdmFyIGxpbWl0TWF4SG91cnMgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5jb25maWcubWF4RGF0ZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIGlmIChsaW1pdE1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFRpbWUgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhUaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4VGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWludXRlcywgbWF4VGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtYXhUaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWluKHNlY29uZHMsIG1heFRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdE1pbkhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblRpbWUgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5UaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5UaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluVGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5tYXgobWludXRlcywgbWluVGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtaW5UaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWF4KHNlY29uZHMsIG1pblRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGltZSBpbnB1dCB2YWx1ZXMgd2l0aCBhIGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzRnJvbURhdGUoZGF0ZU9iaikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBkYXRlT2JqIHx8IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqO1xuICAgICAgICAgICAgaWYgKGRhdGUpXG4gICAgICAgICAgICAgICAgc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHRIb3VycygpIHtcbiAgICAgICAgICAgIHZhciBob3VycyA9IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0TWludXRlO1xuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0U2Vjb25kcztcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluSHIgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbk1pbnV0ZXMgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5Icik7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5IcilcbiAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGgubWF4KG1pbk1pbnV0ZXMsIG1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluSHIgJiYgbWludXRlcyA9PT0gbWluTWludXRlcylcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhIciA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4TWludXRlcyA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5taW4oaG91cnMsIG1heEhyKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1heEhyKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWF4TWludXRlcywgbWludXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhIciAmJiBtaW51dGVzID09PSBtYXhNaW51dGVzKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIb3Vycyhob3VycywgbWludXRlcywgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhvdXJzLCBtaW51dGVzLCBhbmQgb3B0aW9uYWxseSBzZWNvbmRzXG4gICAgICAgICAqIG9mIHRoZSBsYXRlc3Qgc2VsZWN0ZWQgZGF0ZSBvYmplY3QgYW5kIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHRpbWUgaW5wdXRzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyB0aGUgaG91ci4gd2hldGhlciBpdHMgbWlsaXRhcnlcbiAgICAgICAgICogICAgICAgICAgICAgICAgIG9yIGFtLXBtIGdldHMgaW5mZXJyZWQgZnJvbSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgdGhlIG1pbnV0ZXNcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgdGhlIHNlY29uZHMgKG9wdGlvbmFsKVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouc2V0SG91cnMoaG91cnMgJSAyNCwgbWludXRlcywgc2Vjb25kcyB8fCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5ob3VyRWxlbWVudCB8fCAhc2VsZi5taW51dGVFbGVtZW50IHx8IHNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHBhZCghc2VsZi5jb25maWcudGltZV8yNGhyXG4gICAgICAgICAgICAgICAgPyAoKDEyICsgaG91cnMpICUgMTIpICsgMTIgKiBpbnQoaG91cnMgJSAxMiA9PT0gMClcbiAgICAgICAgICAgICAgICA6IGhvdXJzKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC52YWx1ZSA9IHBhZChtaW51dGVzKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVtpbnQoaG91cnMgPj0gMTIpXTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUgPSBwYWQoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgdGhlIHllYXIgaW5wdXQgYW5kIGluY3JlbWVudGluZyBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGtleXVwIG9yIGluY3JlbWVudCBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gb25ZZWFySW5wdXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LnZhbHVlKSArIChldmVudC5kZWx0YSB8fCAwKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIC8gMTAwMCA+IDEgfHxcbiAgICAgICAgICAgICAgICAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIS9bXlxcZF0vLnRlc3QoeWVhci50b1N0cmluZygpKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VZZWFyKHllYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFc3NlbnRpYWxseSBhZGRFdmVudExpc3RlbmVyICsgdHJhY2tpbmdcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGFkZEV2ZW50TGlzdGVuZXIgdG9cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJpbmQoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldikgeyByZXR1cm4gYmluZChlbGVtZW50LCBldiwgaGFuZGxlciwgb3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gYmluZChlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1vdXNlZG93biBoYW5kbGVyIHdoaWNoIG1pbWljcyBjbGljay5cbiAgICAgICAgICogTWluaW1pemVzIGxhdGVuY3ksIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gd2FpdCBmb3IgbW91c2V1cCBpbiBtb3N0IGNhc2VzLlxuICAgICAgICAgKiBBbHNvLCBhdm9pZHMgaGFuZGxpbmcgcmlnaHQgY2xpY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgZXZ0LndoaWNoID09PSAxICYmIGhhbmRsZXIoZXZ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy53cmFwKSB7XG4gICAgICAgICAgICAgICAgW1wib3BlblwiLCBcImNsb3NlXCIsIFwidG9nZ2xlXCIsIFwiY2xlYXJcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc2VsZi5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1cIiArIGV2dCArIFwiXVwiKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZChlbCwgXCJjbGlja1wiLCBzZWxmW2V2dF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgc2V0dXBNb2JpbGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVib3VuY2VkUmVzaXplID0gZGVib3VuY2Uob25SZXNpemUsIDUwKTtcbiAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSA9IGRlYm91bmNlKHRyaWdnZXJDaGFuZ2UsIERFQk9VTkNFRF9DSEFOR0VfTVMpO1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAmJiAhL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQuYm9keSwgXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLmlubGluZSAmJiAhc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LCBcInJlc2l6ZVwiLCBkZWJvdW5jZWRSZXNpemUpO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJ0b3VjaHN0YXJ0XCIsIGRvY3VtZW50Q2xpY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKGRvY3VtZW50Q2xpY2spKTtcbiAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcImZvY3VzXCIsIGRvY3VtZW50Q2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbGlja09wZW5zID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJmb2N1c1wiLCBzZWxmLm9wZW4pO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soc2VsZi5vcGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2sob25Nb250aE5hdkNsaWNrKSk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLm1vbnRoTmF2LCBbXCJrZXl1cFwiLCBcImluY3JlbWVudFwiXSwgb25ZZWFySW5wdXQpO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHNlbGVjdERhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnRpbWVDb250YWluZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbFRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgW1wiaW5jcmVtZW50XCJdLCB1cGRhdGVUaW1lKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJibHVyXCIsIHVwZGF0ZVRpbWUsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJtb3VzZWRvd25cIiwgb25DbGljayh0aW1lSW5jcmVtZW50KSk7XG4gICAgICAgICAgICAgICAgYmluZChbc2VsZi5ob3VyRWxlbWVudCwgc2VsZi5taW51dGVFbGVtZW50XSwgW1wiZm9jdXNcIiwgXCJjbGlja1wiXSwgc2VsVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBiaW5kKHNlbGYuc2Vjb25kRWxlbWVudCwgXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLnNlY29uZEVsZW1lbnQgJiYgc2VsZi5zZWNvbmRFbGVtZW50LnNlbGVjdCgpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZChzZWxmLmFtUE0sIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY2FsZW5kYXIgdmlldyB0byBhIHBhcnRpY3VsYXIgZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHtEYXRlfSBqdW1wRGF0ZSB0aGUgZGF0ZSB0byBzZXQgdGhlIHZpZXcgdG9cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB0cmlnZ2VyQ2hhbmdlIGlmIGNoYW5nZSBldmVudHMgc2hvdWxkIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24ganVtcFRvRGF0ZShqdW1wRGF0ZSwgdHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIGp1bXBUbyA9IGp1bXBEYXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHNlbGYucGFyc2VEYXRlKGp1bXBEYXRlKVxuICAgICAgICAgICAgICAgIDogc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jb25maWcubWluRGF0ZSA+IHNlbGYubm93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJiBzZWxmLmNvbmZpZy5tYXhEYXRlIDwgc2VsZi5ub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93KTtcbiAgICAgICAgICAgIHZhciBvbGRZZWFyID0gc2VsZi5jdXJyZW50WWVhcjtcbiAgICAgICAgICAgIHZhciBvbGRNb250aCA9IHNlbGYuY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IGp1bXBUby5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IGp1bXBUby5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXCIgKyBqdW1wVG87XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgJiYgc2VsZi5jdXJyZW50WWVhciAhPT0gb2xkWWVhcikge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSAmJlxuICAgICAgICAgICAgICAgIChzZWxmLmN1cnJlbnRZZWFyICE9PSBvbGRZZWFyIHx8IHNlbGYuY3VycmVudE1vbnRoICE9PSBvbGRNb250aCkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVwL2Rvd24gYXJyb3cgaGFuZGxlciBmb3IgdGltZSBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVJbmNyZW1lbnQoZSkge1xuICAgICAgICAgICAgaWYgKH5lLnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihcImFycm93XCIpKVxuICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KGUsIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNyZW1lbnRzL2RlY3JlbWVudHMgdGhlIHZhbHVlIG9mIGlucHV0IGFzc29jaS1cbiAgICAgICAgICogYXRlZCB3aXRoIHRoZSB1cC9kb3duIGFycm93IGJ5IGRpc3BhdGNoaW5nIGFuXG4gICAgICAgICAqIFwiaW5jcmVtZW50XCIgZXZlbnQgb24gdGhlIGlucHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHRoZSBjbGljayBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgdGhlIGRpZmYgKHVzdWFsbHkgMSBvciAtMSlcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dEVsZW0gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluY3JlbWVudE51bUlucHV0KGUsIGRlbHRhLCBpbnB1dEVsZW0pIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlICYmIGUudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRFbGVtIHx8XG4gICAgICAgICAgICAgICAgKHRhcmdldCAmJiB0YXJnZXQucGFyZW50Tm9kZSAmJiB0YXJnZXQucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUV2ZW50KFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIGlucHV0ICYmIGlucHV0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRNb250aE5hdigpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1pbm5lckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcud2Vla051bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gYnVpbGRXZWVrcygpLCB3ZWVrV3JhcHBlciA9IF9hLndlZWtXcmFwcGVyLCB3ZWVrTnVtYmVycyA9IF9hLndlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHdlZWtXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycyA9IHdlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndlZWtXcmFwcGVyID0gd2Vla1dyYXBwZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoYnVpbGRXZWVrZGF5cygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWRheXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5kYXlzQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc2VsZi5pbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGJ1aWxkVGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmFuZ2VNb2RlXCIsIHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIik7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFuaW1hdGVcIiwgc2VsZi5jb25maWcuYW5pbWF0ZSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcIm11bHRpTW9udGhcIiwgc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQXBwZW5kID0gc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmFwcGVuZFRvLm5vZGVUeXBlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lIHx8IHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChzZWxmLmNvbmZpZy5pbmxpbmUgPyBcImlubGluZVwiIDogXCJzdGF0aWNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1c3RvbUFwcGVuZCAmJiBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBzZWxmLl9pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hcHBlbmRUby5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd3JhcHBlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hcHBlbmRUb1xuICAgICAgICAgICAgICAgICAgICA6IHdpbmRvdy5kb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYXkoY2xhc3NOYW1lLCBkYXRlLCBkYXlOdW1iZXIsIGkpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSXNFbmFibGVkID0gaXNFbmFibGVkKGRhdGUsIHRydWUpLCBkYXlFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItZGF5IFwiICsgY2xhc3NOYW1lLCBkYXRlLmdldERhdGUoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuZGF0ZU9iaiA9IGRhdGU7XG4gICAgICAgICAgICBkYXlFbGVtZW50LiRpID0gaTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmZvcm1hdERhdGUoZGF0ZSwgc2VsZi5jb25maWcuYXJpYURhdGVGb3JtYXQpKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5ub3cpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2RheURhdGVFbGVtID0gZGF5RWxlbWVudDtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJ0b2RheVwiKTtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiLCBcImRhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSA9IGRheUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRheUVsZW1lbnQsIFwic3RhcnRSYW5nZVwiLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB0cnVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcImVuZFJhbmdlXCIsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0sIHRydWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09IFwibmV4dE1vbnRoRGF5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlSW5SYW5nZShkYXRlKSAmJiAhaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgIT09IFwicHJldk1vbnRoRGF5XCIgJiZcbiAgICAgICAgICAgICAgICBkYXlOdW1iZXIgJSA3ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCI8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLWRheSc+XCIgKyBzZWxmLmNvbmZpZy5nZXRXZWVrKGRhdGUpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25EYXlDcmVhdGVcIiwgZGF5RWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c09uRGF5RWxlbSh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpcnN0QXZhaWxhYmxlRGF5KGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRNb250aCA9IGRlbHRhID4gMCA/IDAgOiBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMTtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzdGFydE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gZGVsdGEgPiAwID8gMCA6IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gZGVsdGEgPiAwID8gbW9udGguY2hpbGRyZW4ubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgKz0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtb250aC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmIGlzRW5hYmxlZChjLmRhdGVPYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0QXZhaWxhYmxlRGF5KGN1cnJlbnQsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZ2l2ZW5Nb250aCA9IGN1cnJlbnQuY2xhc3NOYW1lLmluZGV4T2YoXCJNb250aFwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQuZGF0ZU9iai5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIHZhciBsb29wRGVsdGEgPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gZ2l2ZW5Nb250aCAtIHNlbGYuY3VycmVudE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGdpdmVuTW9udGggLSBzZWxmLmN1cnJlbnRNb250aCA9PT0gbVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQuJGkgKyBkZWx0YVxuICAgICAgICAgICAgICAgICAgICA6IGRlbHRhIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtb250aC5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIG51bU1vbnRoRGF5cyA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA+PSAwICYmIGkgPCBudW1Nb250aERheXMgJiYgaSAhPSAoZGVsdGEgPiAwID8gbnVtTW9udGhEYXlzIDogLTEpOyBpICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1vbnRoLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5hYmxlZChjLmRhdGVPYmopICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhjdXJyZW50LiRpIC0gaSkgPj0gTWF0aC5hYnMoZGVsdGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY2hhbmdlTW9udGgobG9vcERlbHRhKTtcbiAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkobG9vcERlbHRhKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzT25EYXkoY3VycmVudCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgZGF5Rm9jdXNlZCA9IGlzSW5WaWV3KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbGVtID0gY3VycmVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50XG4gICAgICAgICAgICAgICAgOiBkYXlGb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYuc2VsZWN0ZWREYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVFbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYudG9kYXlEYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYudG9kYXlEYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYudG9kYXlEYXRlRWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0Rmlyc3RBdmFpbGFibGVEYXkob2Zmc2V0ID4gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRFbGVtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoIWRheUZvY3VzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKHN0YXJ0RWxlbSk7XG4gICAgICAgICAgICBnZXROZXh0QXZhaWxhYmxlRGF5KHN0YXJ0RWxlbSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoRGF5cyh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0T2ZNb250aCA9IChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCkgLSBzZWxmLmwxMG4uZmlyc3REYXlPZldlZWsgKyA3KSAlIDc7XG4gICAgICAgICAgICB2YXIgcHJldk1vbnRoRGF5cyA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgoKG1vbnRoIC0gMSArIDEyKSAlIDEyKTtcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgobW9udGgpLCBkYXlzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgaXNNdWx0aU1vbnRoID0gc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEsIHByZXZNb250aERheUNsYXNzID0gaXNNdWx0aU1vbnRoID8gXCJwcmV2TW9udGhEYXkgaGlkZGVuXCIgOiBcInByZXZNb250aERheVwiLCBuZXh0TW9udGhEYXlDbGFzcyA9IGlzTXVsdGlNb250aCA/IFwibmV4dE1vbnRoRGF5IGhpZGRlblwiIDogXCJuZXh0TW9udGhEYXlcIjtcbiAgICAgICAgICAgIHZhciBkYXlOdW1iZXIgPSBwcmV2TW9udGhEYXlzICsgMSAtIGZpcnN0T2ZNb250aCwgZGF5SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gcHJlcGVuZCBkYXlzIGZyb20gdGhlIGVuZGluZyBvZiBwcmV2aW91cyBtb250aFxuICAgICAgICAgICAgZm9yICg7IGRheU51bWJlciA8PSBwcmV2TW9udGhEYXlzOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KHByZXZNb250aERheUNsYXNzLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGF0IDEgc2luY2UgdGhlcmUgaXMgbm8gMHRoIGRheVxuICAgICAgICAgICAgZm9yIChkYXlOdW1iZXIgPSAxOyBkYXlOdW1iZXIgPD0gZGF5c0luTW9udGg7IGRheU51bWJlcisrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkoXCJcIiwgbmV3IERhdGUoeWVhciwgbW9udGgsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCBkYXlzIGZyb20gdGhlIG5leHQgbW9udGhcbiAgICAgICAgICAgIGZvciAodmFyIGRheU51bSA9IGRheXNJbk1vbnRoICsgMTsgZGF5TnVtIDw9IDQyIC0gZmlyc3RPZk1vbnRoICYmXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgfHwgZGF5SW5kZXggJSA3ICE9PSAwKTsgZGF5TnVtKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShuZXh0TW9udGhEYXlDbGFzcywgbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCBkYXlOdW0gJSBkYXlzSW5Nb250aCksIGRheU51bSwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgdmFyIGRheUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJkYXlDb250YWluZXJcIik7XG4gICAgICAgICAgICBkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkRGF5cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgICAgLy8gVE9ETzogd2VlayBudW1iZXJzIGZvciBlYWNoIG1vbnRoXG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycylcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrTnVtYmVycyk7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoYnVpbGRNb250aERheXMoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJiBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoU3dpdGNoKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBzaG91bGRCdWlsZE1vbnRoID0gZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIShzZWxmLmNvbmZpZy5tYXhEYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICBzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEJ1aWxkTW9udGgoaSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IGNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwgXCJmbGF0cGlja3ItbW9udGhEcm9wZG93bi1tb250aFwiKTtcbiAgICAgICAgICAgICAgICBtb250aC52YWx1ZSA9IG5ldyBEYXRlKHNlbGYuY3VycmVudFllYXIsIGkpLmdldE1vbnRoKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBtb250aC50ZXh0Q29udGVudCA9IG1vbnRoVG9TdHIoaSwgZmFsc2UsIHNlbGYubDEwbik7XG4gICAgICAgICAgICAgICAgbW9udGgudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50TW9udGggPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGguc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLmFwcGVuZENoaWxkKG1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItbW9udGhcIik7XG4gICAgICAgICAgICB2YXIgbW9udGhOYXZGcmFnbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB2YXIgbW9udGhFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxKSB7XG4gICAgICAgICAgICAgICAgbW9udGhFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJjdXItbW9udGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCBcImZsYXRwaWNrci1tb250aERyb3Bkb3duLW1vbnRoc1wiKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTW9udGggPSBwYXJzZUludCh0YXJnZXQudmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VNb250aChzZWxlY3RlZE1vbnRoIC0gc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJ1aWxkTW9udGhTd2l0Y2goKTtcbiAgICAgICAgICAgICAgICBtb250aEVsZW1lbnQgPSBzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXJJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiY3VyLXllYXJcIiwgeyB0YWJpbmRleDogXCItMVwiIH0pO1xuICAgICAgICAgICAgdmFyIHllYXJFbGVtZW50ID0geWVhcklucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHNlbGYubDEwbi55ZWFyQXJpYUxhYmVsKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlKSB7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlKSB7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5kaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICEhc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudE1vbnRoID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1jdXJyZW50LW1vbnRoXCIpO1xuICAgICAgICAgICAgY3VycmVudE1vbnRoLmFwcGVuZENoaWxkKG1vbnRoRWxlbWVudCk7XG4gICAgICAgICAgICBjdXJyZW50TW9udGguYXBwZW5kQ2hpbGQoeWVhcklucHV0KTtcbiAgICAgICAgICAgIG1vbnRoTmF2RnJhZ21lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtb250aE5hdkZyYWdtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQ6IHllYXJFbGVtZW50LFxuICAgICAgICAgICAgICAgIG1vbnRoRWxlbWVudDogbW9udGhFbGVtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhzKCkge1xuICAgICAgICAgICAgY2xlYXJOb2RlKHNlbGYubW9udGhOYXYpO1xuICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChzZWxmLnByZXZNb250aE5hdik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2hvd01vbnRocykge1xuICAgICAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgbS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IGJ1aWxkTW9udGgoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cy5wdXNoKG1vbnRoLnllYXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMucHVzaChtb250aC5tb250aEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQobW9udGguY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQoc2VsZi5uZXh0TW9udGhOYXYpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhOYXYoKSB7XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aHNcIik7XG4gICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBzZWxmLnByZXZNb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXByZXYtbW9udGhcIik7XG4gICAgICAgICAgICBzZWxmLnByZXZNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5wcmV2QXJyb3c7XG4gICAgICAgICAgICBzZWxmLm5leHRNb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLW5leHQtbW9udGhcIik7XG4gICAgICAgICAgICBzZWxmLm5leHRNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5uZXh0QXJyb3c7XG4gICAgICAgICAgICBidWlsZE1vbnRocygpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9faGlkZVByZXZNb250aEFycm93OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3cgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYucHJldk1vbnRoTmF2LCBcImZsYXRwaWNrci1kaXNhYmxlZFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3cgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJfaGlkZU5leHRNb250aEFycm93XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3c7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdyAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5uZXh0TW9udGhOYXYsIFwiZmxhdHBpY2tyLWRpc2FibGVkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdyA9IGJvb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50ID0gc2VsZi55ZWFyRWxlbWVudHNbMF07XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tb250aE5hdjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFRpbWUoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNUaW1lXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpXG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9DYWxlbmRhclwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItdGltZVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBob3VySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1ob3VyXCIpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCA9IGhvdXJJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZUlucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItbWludXRlXCIpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50ID0gbWludXRlSW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudGFiSW5kZXggPSBzZWxmLm1pbnV0ZUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldEhvdXJzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLnRpbWVfMjRoclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyXG4gICAgICAgICAgICAgICAgICAgIDogbWlsaXRhcnkyYW1wbShzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRNaW51dGVzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGUpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYuY29uZmlnLmhvdXJJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBzZWxmLmNvbmZpZy5taW51dGVJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyBcIjBcIiA6IFwiMVwiKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMjNcIiA6IFwiMTJcIik7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCI1OVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChob3VySW5wdXQpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQobWludXRlSW5wdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRpbWVfMjRocilcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRpbWUyNGhyXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1NlY29uZHNcIik7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZElucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3Itc2Vjb25kXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCA9IHNlY29uZElucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0U2Vjb25kcygpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHMpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIFwiNTlcIik7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKSk7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlY29uZElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcudGltZV8yNGhyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHNlbGYuYW1QTSBpZiBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgIHNlbGYuYW1QTSA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWFtLXBtXCIsIHNlbGYubDEwbi5hbVBNW2ludCgoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmhvdXJFbGVtZW50LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdEhvdXIpID4gMTEpXSk7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRpdGxlID0gc2VsZi5sMTBuLnRvZ2dsZVRpdGxlO1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmFtUE0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYudGltZUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFdlZWtkYXlzKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLndlZWtkYXlDb250YWluZXIpXG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5c1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrZGF5Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla2RheWNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVdlZWtkYXlzKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi53ZWVrZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdlZWtkYXlzKCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICAgICAgdmFyIHdlZWtkYXlzID0gc2VsZi5sMTBuLndlZWtkYXlzLnNob3J0aGFuZC5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrID4gMCAmJiBmaXJzdERheU9mV2VlayA8IHdlZWtkYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlzID0gd2Vla2RheXMuc3BsaWNlKGZpcnN0RGF5T2ZXZWVrLCB3ZWVrZGF5cy5sZW5ndGgpLmNvbmNhdCh3ZWVrZGF5cy5zcGxpY2UoMCwgZmlyc3REYXlPZldlZWspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyLmNoaWxkcmVuW2ldLmlubmVySFRNTCA9IFwiXFxuICAgICAgPHNwYW4gY2xhc3M9J2ZsYXRwaWNrci13ZWVrZGF5Jz5cXG4gICAgICAgIFwiICsgd2Vla2RheXMuam9pbihcIjwvc3Bhbj48c3BhbiBjbGFzcz0nZmxhdHBpY2tyLXdlZWtkYXknPlwiKSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla3MoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNXZWVrc1wiKTtcbiAgICAgICAgICAgIHZhciB3ZWVrV3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla3dyYXBwZXJcIik7XG4gICAgICAgICAgICB3ZWVrV3JhcHBlci5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci13ZWVrZGF5XCIsIHNlbGYubDEwbi53ZWVrQWJicmV2aWF0aW9uKSk7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlcnMgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtzXCIpO1xuICAgICAgICAgICAgd2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQod2Vla051bWJlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3ZWVrV3JhcHBlcjogd2Vla1dyYXBwZXIsXG4gICAgICAgICAgICAgICAgd2Vla051bWJlcnM6IHdlZWtOdW1iZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZU1vbnRoKHZhbHVlLCBpc09mZnNldCkge1xuICAgICAgICAgICAgaWYgKGlzT2Zmc2V0ID09PSB2b2lkIDApIHsgaXNPZmZzZXQgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBpc09mZnNldCA/IHZhbHVlIDogdmFsdWUgLSBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIGlmICgoZGVsdGEgPCAwICYmIHNlbGYuX2hpZGVQcmV2TW9udGhBcnJvdyA9PT0gdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZGVsdGEgPiAwICYmIHNlbGYuX2hpZGVOZXh0TW9udGhBcnJvdyA9PT0gdHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggKz0gZGVsdGE7XG4gICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50TW9udGggPCAwIHx8IHNlbGYuY3VycmVudE1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyICs9IHNlbGYuY3VycmVudE1vbnRoID4gMTEgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSAoc2VsZi5jdXJyZW50TW9udGggKyAxMikgJSAxMjtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgYnVpbGRNb250aFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyKHRyaWdnZXJDaGFuZ2VFdmVudCwgdG9Jbml0aWFsKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50ID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZUV2ZW50ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdm9pZCAwKSB7IHRvSW5pdGlhbCA9IHRydWU7IH1cbiAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZXREZWZhdWx0SG91cnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KVxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJDaGFuZ2VFdmVudCBpcyB0cnVlIChkZWZhdWx0KSBvciBhbiBFdmVudFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkRlc3Ryb3lcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5faGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBzZWxmLl9oYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBoLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoLmV2ZW50LCBoLmhhbmRsZXIsIGgub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5tb2JpbGVJbnB1dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgJiYgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYyAmJiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIubGFzdENoaWxkICYmIHdyYXBwZXIucmVtb3ZlQ2hpbGQod3JhcHBlci5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlci5maXJzdENoaWxkLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBzZWxmLmlucHV0Ll90eXBlO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiX3Nob3dUaW1lSW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImxhdGVzdFNlbGVjdGVkRGF0ZU9ialwiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX19oaWRlTmV4dE1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcIl9faGlkZVByZXZNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJpc01vYmlsZVwiLFxuICAgICAgICAgICAgICAgIFwiaXNPcGVuXCIsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZERhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJtaW5EYXRlSGFzVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibWF4RGF0ZUhhc1RpbWVcIixcbiAgICAgICAgICAgICAgICBcImRheXNcIixcbiAgICAgICAgICAgICAgICBcImRheXNDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIl9pbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiX3Bvc2l0aW9uRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwiaW5uZXJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcInJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJ0b2RheURhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJjYWxlbmRhckNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwid2Vla2RheUNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwicHJldk1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0TW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50TW9udGhFbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50WWVhckVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcIm5hdmlnYXRpb25DdXJyZW50TW9udGhcIixcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkRGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiLFxuICAgICAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGZba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FsZW5kYXJFbGVtKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAmJiBzZWxmLmNvbmZpZy5hcHBlbmRUby5jb250YWlucyhlbGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNvbnRhaW5zKGVsZW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXRfMSA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgICAgIHZhciBpc0NhbGVuZGFyRWxlbWVudCA9IGlzQ2FsZW5kYXJFbGVtKGV2ZW50VGFyZ2V0XzEpO1xuICAgICAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZXZlbnRUYXJnZXRfMSA9PT0gc2VsZi5pbnB1dCB8fFxuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldF8xID09PSBzZWxmLmFsdElucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5jb250YWlucyhldmVudFRhcmdldF8xKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZWIgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBlLnBhdGggaXMgbm90IHByZXNlbnQgaW4gYWxsIGJyb3dzZXJzLiBjaXJjdW12ZW50aW5nIHR5cGVjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgKGUucGF0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXRoLmluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh+ZS5wYXRoLmluZGV4T2Yoc2VsZi5pbnB1dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB+ZS5wYXRoLmluZGV4T2Yoc2VsZi5hbHRJbnB1dCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9zdEZvY3VzID0gZS50eXBlID09PSBcImJsdXJcIlxuICAgICAgICAgICAgICAgICAgICA/IGlzSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtKGUucmVsYXRlZFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJZ25vcmVkID0gIXNlbGYuY29uZmlnLmlnbm9yZWRGb2N1c0VsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGFpbnMoZXZlbnRUYXJnZXRfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvc3RGb2N1cyAmJiBpc0lnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VZZWFyKG5ld1llYXIpIHtcbiAgICAgICAgICAgIGlmICghbmV3WWVhciB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmIG5ld1llYXIgPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiYgbmV3WWVhciA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld1llYXJOdW0gPSBuZXdZZWFyLCBpc05ld1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyICE9PSBuZXdZZWFyTnVtO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IG5ld1llYXJOdW0gfHwgc2VsZi5jdXJyZW50WWVhcjtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1pbihzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IE1hdGgubWF4KHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKSwgc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmV3WWVhcikge1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIGJ1aWxkTW9udGhTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoZGF0ZSwgdGltZWxlc3MpIHtcbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGRhdGVUb0NoZWNrID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgdW5kZWZpbmVkLCB0aW1lbGVzcyk7IC8vIHRpbWVsZXNzXG4gICAgICAgICAgICBpZiAoKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlVG9DaGVjaywgc2VsZi5jb25maWcubWluRGF0ZSwgdGltZWxlc3MgIT09IHVuZGVmaW5lZCA/IHRpbWVsZXNzIDogIXNlbGYubWluRGF0ZUhhc1RpbWUpIDwgMCkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZVRvQ2hlY2ssIHNlbGYuY29uZmlnLm1heERhdGUsIHRpbWVsZXNzICE9PSB1bmRlZmluZWQgPyB0aW1lbGVzcyA6ICFzZWxmLm1heERhdGVIYXNUaW1lKSA+IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID09PSAwICYmIHNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGRhdGVUb0NoZWNrID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGJvb2wgPSBzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID4gMCwgYXJyYXkgPSBib29sID8gc2VsZi5jb25maWcuZW5hYmxlIDogc2VsZi5jb25maWcuZGlzYWJsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBkID0gdm9pZCAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZChkYXRlVG9DaGVjaykgLy8gZGlzYWJsZWQgYnkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQgaW5zdGFuY2VvZiBEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgZGF0ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IGRhdGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBzZWxmLnBhcnNlRGF0ZShkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkICYmIHBhcnNlZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBib29sXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICFib29sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSByYW5nZVxuICAgICAgICAgICAgICAgIHR5cGVvZiBkID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5mcm9tICYmXG4gICAgICAgICAgICAgICAgICAgIGQudG8gJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpID49IGQuZnJvbS5nZXRUaW1lKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpIDw9IGQudG8uZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhYm9vbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0luVmlldyhlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLmNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIuY29udGFpbnMoZWxlbSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgICAgICAvLyBlLmtleSAgICAgICAgICAgICAgICAgICAgICBlLmtleUNvZGVcbiAgICAgICAgICAgIC8vIFwiQmFja3NwYWNlXCIgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAvLyBcIlRhYlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOVxuICAgICAgICAgICAgLy8gXCJFbnRlclwiICAgICAgICAgICAgICAgICAgICAgICAgICAgMTNcbiAgICAgICAgICAgIC8vIFwiRXNjYXBlXCIgICAgIChJRSBcIkVzY1wiKSAgICAgICAgICAgMjdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dMZWZ0XCIgIChJRSBcIkxlZnRcIikgICAgICAgICAgMzdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dVcFwiICAgIChJRSBcIlVwXCIpICAgICAgICAgICAgMzhcbiAgICAgICAgICAgIC8vIFwiQXJyb3dSaWdodFwiIChJRSBcIlJpZ2h0XCIpICAgICAgICAgMzlcbiAgICAgICAgICAgIC8vIFwiQXJyb3dEb3duXCIgIChJRSBcIkRvd25cIikgICAgICAgICAgNDBcbiAgICAgICAgICAgIC8vIFwiRGVsZXRlXCIgICAgIChJRSBcIkRlbFwiKSAgICAgICAgICAgNDZcbiAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZS50YXJnZXQgPT09IHNlbGYuX2lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93SW5wdXQgPSBzZWxmLmNvbmZpZy5hbGxvd0lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93S2V5ZG93biA9IHNlbGYuaXNPcGVuICYmICghYWxsb3dJbnB1dCB8fCAhaXNJbnB1dCk7XG4gICAgICAgICAgICB2YXIgYWxsb3dJbmxpbmVLZXlkb3duID0gc2VsZi5jb25maWcuaW5saW5lICYmIGlzSW5wdXQgJiYgIWFsbG93SW5wdXQ7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMyAmJiBpc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKHNlbGYuX2lucHV0LnZhbHVlLCB0cnVlLCBlLnRhcmdldCA9PT0gc2VsZi5hbHRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hbHRGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NhbGVuZGFyRWxlbShlLnRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICBhbGxvd0tleWRvd24gfHxcbiAgICAgICAgICAgICAgICBhbGxvd0lubGluZUtleWRvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUaW1lT2JqID0gISFzZWxmLnRpbWVDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdERhdGUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5wdXQgJiYgIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaiAmJiAhaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93SW5wdXQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBpc0luVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YV8xID0gZS5rZXlDb2RlID09PSAzOSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmN0cmxLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KHVuZGVmaW5lZCwgZGVsdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGRlbHRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmhvdXJFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZS5rZXlDb2RlID09PSA0MCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2VsZi5kYXlzQ29udGFpbmVyICYmIGUudGFyZ2V0LiRpICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPT09IHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1RpbWVPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCBkZWx0YSAqIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS50YXJnZXQgPT09IHNlbGYuY3VycmVudFllYXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqICYmIHNlbGYuaG91ckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNlbGYucGx1Z2luRWxlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZWxlbXMuaW5kZXhPZihlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbGVtc1tpICsgKGUuc2hpZnRLZXkgPyAtMSA6IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0IHx8IHNlbGYuX2lucHV0KS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkICYmIGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMF0uY2hhckF0KDApOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzBdLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMV0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0lucHV0IHx8IGlzQ2FsZW5kYXJFbGVtKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uS2V5RG93blwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlT3ZlcihlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgICAgICAgIChlbGVtICYmXG4gICAgICAgICAgICAgICAgICAgICghZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGF5XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kaXNhYmxlZFwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob3ZlckRhdGUgPSBlbGVtXG4gICAgICAgICAgICAgICAgPyBlbGVtLmRhdGVPYmouZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmRheXMuZmlyc3RFbGVtZW50Q2hpbGQuZGF0ZU9iai5nZXRUaW1lKCksIGluaXRpYWxEYXRlID0gc2VsZi5wYXJzZURhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB1bmRlZmluZWQsIHRydWUpLmdldFRpbWUoKSwgcmFuZ2VTdGFydERhdGUgPSBNYXRoLm1pbihob3ZlckRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCkpLCByYW5nZUVuZERhdGUgPSBNYXRoLm1heChob3ZlckRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5zRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBtaW5SYW5nZSA9IDAsIG1heFJhbmdlID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSByYW5nZVN0YXJ0RGF0ZTsgdCA8IHJhbmdlRW5kRGF0ZTsgdCArPSBkdXJhdGlvbi5EQVkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW5hYmxlZChuZXcgRGF0ZSh0KSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc0Rpc2FibGVkIHx8ICh0ID4gcmFuZ2VTdGFydERhdGUgJiYgdCA8IHJhbmdlRW5kRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgaW5pdGlhbERhdGUgJiYgKCFtaW5SYW5nZSB8fCB0ID4gbWluUmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluUmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID4gaW5pdGlhbERhdGUgJiYgKCFtYXhSYW5nZSB8fCB0IDwgbWF4UmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGksIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheUVsZW0gPSBtb250aC5jaGlsZHJlbltpXSwgZGF0ZSA9IGRheUVsZW0uZGF0ZU9iajtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0T2ZSYW5nZSA9IChtaW5SYW5nZSA+IDAgJiYgdGltZXN0YW1wIDwgbWluUmFuZ2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobWF4UmFuZ2UgPiAwICYmIHRpbWVzdGFtcCA+IG1heFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dE9mUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcIm5vdEFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJpblJhbmdlXCIsIFwic3RhcnRSYW5nZVwiLCBcImVuZFJhbmdlXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnNEaXNhYmxlZCAmJiAhb3V0T2ZSYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIFtcInN0YXJ0UmFuZ2VcIiwgXCJpblJhbmdlXCIsIFwiZW5kUmFuZ2VcIiwgXCJub3RBbGxvd2VkXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChob3ZlckRhdGUgPD0gc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJzdGFydFJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZW5kUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbERhdGUgPCBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJzdGFydFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5pdGlhbERhdGUgPiBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJlbmRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbWluUmFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4UmFuZ2UgPT09IDAgfHwgdGltZXN0YW1wIDw9IG1heFJhbmdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQmV0d2Vlbih0aW1lc3RhbXAsIGluaXRpYWxEYXRlLCBob3ZlckRhdGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbW9udGguY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSwgbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0RGVmYXVsdFRpbWUoKSB7XG4gICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKCksIHRydWUpO1xuICAgICAgICAgICAgc2V0RGVmYXVsdEhvdXJzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9wZW4oZSwgcG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25FbGVtZW50ID09PSB2b2lkIDApIHsgcG9zaXRpb25FbGVtZW50ID0gc2VsZi5fcG9zaXRpb25FbGVtZW50OyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc01vYmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgJiYgZS50YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5jbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0LmRpc2FibGVkIHx8IHNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgd2FzT3BlbiA9IHNlbGYuaXNPcGVuO1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF3YXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uT3BlblwiKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKHBvc2l0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSA9PT0gdHJ1ZSAmJiBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGVmYXVsdFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFsbG93SW5wdXQgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgIChlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFzZWxmLnRpbWVDb250YWluZXIuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmhvdXJFbGVtZW50LnNlbGVjdCgpOyB9LCA1MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1pbk1heERhdGVTZXR0ZXIodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVPYmogPSAoc2VsZi5jb25maWdbXCJfXCIgKyB0eXBlICsgXCJEYXRlXCJdID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgc2VsZi5jb25maWcuZGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlRGF0ZU9iaiA9IHNlbGYuY29uZmlnW1wiX1wiICsgKHR5cGUgPT09IFwibWluXCIgPyBcIm1heFwiIDogXCJtaW5cIikgKyBcIkRhdGVcIl07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmW3R5cGUgPT09IFwibWluXCIgPyBcIm1pbkRhdGVIYXNUaW1lXCIgOiBcIm1heERhdGVIYXNUaW1lXCJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmouZ2V0SG91cnMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldFNlY29uZHMoKSA+IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gc2VsZi5zZWxlY3RlZERhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gaXNFbmFibGVkKGQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICYmIHR5cGUgPT09IFwibWluXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKGRhdGVPYmopO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZU9iaiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnRbdHlwZV0gPSBkYXRlT2JqLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudC5kaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAhIWludmVyc2VEYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iaiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZURhdGVPYmouZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZU9iai5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VDb25maWcoKSB7XG4gICAgICAgICAgICB2YXIgYm9vbE9wdHMgPSBbXG4gICAgICAgICAgICAgICAgXCJ3cmFwXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrTnVtYmVyc1wiLFxuICAgICAgICAgICAgICAgIFwiYWxsb3dJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiY2xpY2tPcGVuc1wiLFxuICAgICAgICAgICAgICAgIFwidGltZV8yNGhyXCIsXG4gICAgICAgICAgICAgICAgXCJlbmFibGVUaW1lXCIsXG4gICAgICAgICAgICAgICAgXCJub0NhbGVuZGFyXCIsXG4gICAgICAgICAgICAgICAgXCJhbHRJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwic2hvcnRoYW5kQ3VycmVudE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJpbmxpbmVcIixcbiAgICAgICAgICAgICAgICBcInN0YXRpY1wiLFxuICAgICAgICAgICAgICAgIFwiZW5hYmxlU2Vjb25kc1wiLFxuICAgICAgICAgICAgICAgIFwiZGlzYWJsZU1vYmlsZVwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciB1c2VyQ29uZmlnID0gX19hc3NpZ24oe30sIGluc3RhbmNlQ29uZmlnLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnQuZGF0YXNldCB8fCB7fSkpKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXRzID0ge307XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5wYXJzZURhdGUgPSB1c2VyQ29uZmlnLnBhcnNlRGF0ZTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmZvcm1hdERhdGUgPSB1c2VyQ29uZmlnLmZvcm1hdERhdGU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZW5hYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9lbmFibGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuX2VuYWJsZSA9IHBhcnNlRGF0ZVJ1bGVzKGRhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJkaXNhYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9kaXNhYmxlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLl9kaXNhYmxlID0gcGFyc2VEYXRlUnVsZXMoZGF0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRpbWVNb2RlID0gdXNlckNvbmZpZy5tb2RlID09PSBcInRpbWVcIjtcbiAgICAgICAgICAgIGlmICghdXNlckNvbmZpZy5kYXRlRm9ybWF0ICYmICh1c2VyQ29uZmlnLmVuYWJsZVRpbWUgfHwgdGltZU1vZGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRlRm9ybWF0ID0gZmxhdHBpY2tyLmRlZmF1bHRDb25maWcuZGF0ZUZvcm1hdCB8fCBkZWZhdWx0cy5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdHMuZGF0ZUZvcm1hdCA9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcubm9DYWxlbmRhciB8fCB0aW1lTW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHREYXRlRm9ybWF0ICsgXCIgSDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5hbHRJbnB1dCAmJlxuICAgICAgICAgICAgICAgICh1c2VyQ29uZmlnLmVuYWJsZVRpbWUgfHwgdGltZU1vZGUpICYmXG4gICAgICAgICAgICAgICAgIXVzZXJDb25maWcuYWx0Rm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRBbHRGb3JtYXQgPSBmbGF0cGlja3IuZGVmYXVsdENvbmZpZy5hbHRGb3JtYXQgfHwgZGVmYXVsdHMuYWx0Rm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdHMuYWx0Rm9ybWF0ID1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5ub0NhbGVuZGFyIHx8IHRpbWVNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6UyBLXCIgOiBcIiBLXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRBbHRGb3JtYXQgKyAoXCIgaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIikgKyBcIiBLXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1c2VyQ29uZmlnLmFsdElucHV0Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbHRJbnB1dENsYXNzID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc05hbWUgKyBcIiBcIiArIHNlbGYuY29uZmlnLmFsdElucHV0Q2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWluRGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWluRGF0ZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heERhdGVTZXR0ZXIoXCJtaW5cIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heERhdGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21heERhdGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhEYXRlU2V0dGVyKFwibWF4XCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtaW5NYXhUaW1lU2V0dGVyID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1t0eXBlID09PSBcIm1pblwiID8gXCJfbWluVGltZVwiIDogXCJfbWF4VGltZVwiXSA9IHNlbGYucGFyc2VEYXRlKHZhbCwgXCJIOmlcIik7XG4gICAgICAgICAgICB9OyB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1pblRpbWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21pblRpbWU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhUaW1lU2V0dGVyKFwibWluXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtYXhUaW1lXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhUaW1lOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4VGltZVNldHRlcihcIm1heFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5tb2RlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgZm9ybWF0cywgdXNlckNvbmZpZyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xPcHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID09PSBcInRydWVcIjtcbiAgICAgICAgICAgIEhPT0tTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gc2VsZi5jb25maWdbaG9va10gIT09IHVuZGVmaW5lZDsgfSkuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2hvb2tdID0gYXJyYXlpZnkoc2VsZi5jb25maWdbaG9va10gfHwgW10pLm1hcChiaW5kVG9JbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuaXNNb2JpbGUgPVxuICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5kaXNhYmxlTW9iaWxlICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5pbmxpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZGlzYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLndlZWtOdW1iZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5Db25mID0gc2VsZi5jb25maWcucGx1Z2luc1tpXShzZWxmKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGx1Z2luQ29uZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSE9PS1MuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2tleV0gPSBhcnJheWlmeShwbHVnaW5Db25mW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChiaW5kVG9JbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNlbGYuY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1c2VyQ29uZmlnW2tleV0gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1trZXldID0gcGx1Z2luQ29uZltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUGFyc2VDb25maWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBMb2NhbGUoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBmbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiZmxhdHBpY2tyOiBpbnZhbGlkIGxvY2FsZSBcIiArIHNlbGYuY29uZmlnLmxvY2FsZSkpO1xuICAgICAgICAgICAgc2VsZi5sMTBuID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0sICh0eXBlb2Ygc2VsZi5jb25maWcubG9jYWxlID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5sb2NhbGVcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBmbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgdG9rZW5SZWdleC5LID0gXCIoXCIgKyBzZWxmLmwxMG4uYW1QTVswXSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMV0gKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzBdLnRvTG93ZXJDYXNlKCkgKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzFdLnRvTG93ZXJDYXNlKCkgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciB1c2VyQ29uZmlnID0gX19hc3NpZ24oe30sIGluc3RhbmNlQ29uZmlnLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnQuZGF0YXNldCB8fCB7fSkpKTtcbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLnRpbWVfMjRociA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcudGltZV8yNGhyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPSBzZWxmLmwxMG4udGltZV8yNGhyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcihzZWxmKTtcbiAgICAgICAgICAgIHNlbGYucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7IGNvbmZpZzogc2VsZi5jb25maWcsIGwxMG46IHNlbGYubDEwbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwb3NpdGlvbkNhbGVuZGFyKGN1c3RvbVBvc2l0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIik7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25FbGVtZW50ID0gY3VzdG9tUG9zaXRpb25FbGVtZW50IHx8IHNlbGYuX3Bvc2l0aW9uRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhckhlaWdodCA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNoaWxkcmVuLCAoZnVuY3Rpb24gKGFjYywgY2hpbGQpIHsgcmV0dXJuIGFjYyArIGNoaWxkLm9mZnNldEhlaWdodDsgfSksIDApLCBjYWxlbmRhcldpZHRoID0gc2VsZi5jYWxlbmRhckNvbnRhaW5lci5vZmZzZXRXaWR0aCwgY29uZmlnUG9zID0gc2VsZi5jb25maWcucG9zaXRpb24uc3BsaXQoXCIgXCIpLCBjb25maWdQb3NWZXJ0aWNhbCA9IGNvbmZpZ1Bvc1swXSwgY29uZmlnUG9zSG9yaXpvbnRhbCA9IGNvbmZpZ1Bvcy5sZW5ndGggPiAxID8gY29uZmlnUG9zWzFdIDogbnVsbCwgaW5wdXRCb3VuZHMgPSBwb3NpdGlvbkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRpc3RhbmNlRnJvbUJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0Qm91bmRzLmJvdHRvbSwgc2hvd09uVG9wID0gY29uZmlnUG9zVmVydGljYWwgPT09IFwiYWJvdmVcIiB8fFxuICAgICAgICAgICAgICAgIChjb25maWdQb3NWZXJ0aWNhbCAhPT0gXCJiZWxvd1wiICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlRnJvbUJvdHRvbSA8IGNhbGVuZGFySGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCA+IGNhbGVuZGFySGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCArXG4gICAgICAgICAgICAgICAgKCFzaG93T25Ub3AgPyBwb3NpdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgMiA6IC1jYWxlbmRhckhlaWdodCAtIDIpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd1RvcFwiLCAhc2hvd09uVG9wKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dCb3R0b21cIiwgc2hvd09uVG9wKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLmxlZnQgLVxuICAgICAgICAgICAgICAgIChjb25maWdQb3NIb3Jpem9udGFsICE9IG51bGwgJiYgY29uZmlnUG9zSG9yaXpvbnRhbCA9PT0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICA/IChjYWxlbmRhcldpZHRoIC0gaW5wdXRCb3VuZHMud2lkdGgpIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLSBpbnB1dEJvdW5kcy5yaWdodDtcbiAgICAgICAgICAgIHZhciByaWdodE1vc3QgPSBsZWZ0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdmFyIGNlbnRlck1vc3QgPSByaWdodCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmlnaHRNb3N0XCIsIHJpZ2h0TW9zdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgaWYgKCFyaWdodE1vc3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjZW50ZXJNb3N0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IHJpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzWzBdO1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgdGVzdGluZyBlbnZpcm9ubWVudHMgZG9uJ3QgaGF2ZSBjc3Mgc3VwcG9ydFxuICAgICAgICAgICAgICAgIGlmIChkb2MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBib2R5V2lkdGggPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyTGVmdCA9IE1hdGgubWF4KDAsIGJvZHlXaWR0aCAvIDIgLSBjYWxlbmRhcldpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckJlZm9yZSA9IFwiLmZsYXRwaWNrci1jYWxlbmRhci5jZW50ZXJNb3N0OmJlZm9yZVwiO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJBZnRlciA9IFwiLmZsYXRwaWNrci1jYWxlbmRhci5jZW50ZXJNb3N0OmFmdGVyXCI7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckluZGV4ID0gZG9jLmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyU3R5bGUgPSBcIntsZWZ0OlwiICsgaW5wdXRCb3VuZHMubGVmdCArIFwicHg7cmlnaHQ6YXV0bzt9XCI7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyaWdodE1vc3RcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiY2VudGVyTW9zdFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0UnVsZShjZW50ZXJCZWZvcmUgKyBcIixcIiArIGNlbnRlckFmdGVyICsgY2VudGVyU3R5bGUsIGNlbnRlckluZGV4KTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBjZW50ZXJMZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhciB8fCBzZWxmLmlzTW9iaWxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzQW5kQ2xvc2UoKSB7XG4gICAgICAgICAgICBzZWxmLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYWNrIC0gYnVncyBpbiB0aGUgd2F5IElFIGhhbmRsZXMgZm9jdXMga2VlcHMgdGhlIGNhbGVuZGFyIG9wZW5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHNlbGYuY2xvc2UsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdERhdGUoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBpc1NlbGVjdGFibGUgPSBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheS5jbGFzc0xpc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF5LmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGlzYWJsZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJub3RBbGxvd2VkXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0ID0gZmluZFBhcmVudChlLnRhcmdldCwgaXNTZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gbmV3IERhdGUodGFyZ2V0LmRhdGVPYmouZ2V0VGltZSgpKSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2hhbmdlTW9udGggPSAoc2VsZWN0ZWREYXRlLmdldE1vbnRoKCkgPCBzZWxmLmN1cnJlbnRNb250aCB8fFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpID5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggKyBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMSkgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCI7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIilcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbc2VsZWN0ZWREYXRlXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwibXVsdGlwbGVcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gaXNEYXRlU2VsZWN0ZWQoc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNwbGljZShwYXJzZUludChzZWxlY3RlZEluZGV4KSwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMucHVzaChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcihmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHNlbGVjdGVkRGF0ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMucHVzaChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBzZWxlY3Rpbmcgc2FtZSBkYXRlIHR3aWNlLCBzb3J0IGFzY2VuZGluZ2x5XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxlY3RlZERhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdHJ1ZSkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgaWYgKHNob3VsZENoYW5nZU1vbnRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTmV3WWVhciA9IHNlbGYuY3VycmVudFllYXIgIT09IHNlbGVjdGVkRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05ld1llYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChzZWxmLnNob3dUaW1lSW5wdXQgPSB0cnVlKTsgfSwgNTApO1xuICAgICAgICAgICAgLy8gbWFpbnRhaW4gZm9jdXNcbiAgICAgICAgICAgIGlmICghc2hvdWxkQ2hhbmdlTW9udGggJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxKVxuICAgICAgICAgICAgICAgIGZvY3VzT25EYXlFbGVtKHRhcmdldCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAmJiBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbG9zZU9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZSA9IHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBDQUxMQkFDS1MgPSB7XG4gICAgICAgICAgICBsb2NhbGU6IFtzZXR1cExvY2FsZSwgdXBkYXRlV2Vla2RheXNdLFxuICAgICAgICAgICAgc2hvd01vbnRoczogW2J1aWxkTW9udGhzLCBzZXRDYWxlbmRhcldpZHRoLCBidWlsZFdlZWtkYXlzXSxcbiAgICAgICAgICAgIG1pbkRhdGU6IFtqdW1wVG9EYXRlXSxcbiAgICAgICAgICAgIG1heERhdGU6IFtqdW1wVG9EYXRlXVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBzZXQob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDQUxMQkFDS1Nba2V5XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgQ0FMTEJBQ0tTW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tvcHRpb25dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKENBTExCQUNLU1tvcHRpb25dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIENBTExCQUNLU1tvcHRpb25dLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgoKTsgfSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoSE9PS1MuaW5kZXhPZihvcHRpb24pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW29wdGlvbl0gPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkRGF0ZShpbnB1dERhdGUsIGZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgICAgICBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGUubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0RGF0ZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5jb25maWcubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoc2VsZi5jb25maWcuY29uanVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJhbmdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChzZWxmLmwxMG4ucmFuZ2VTZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHN1cHBsaWVkOiBcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0RGF0ZSkpKTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IGRhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCBpbnN0YW5jZW9mIERhdGUgJiYgaXNFbmFibGVkKGQsIGZhbHNlKTsgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXREYXRlKGRhdGUsIHRyaWdnZXJDaGFuZ2UsIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkgeyBmb3JtYXQgPSBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0OyB9XG4gICAgICAgICAgICBpZiAoKGRhdGUgIT09IDAgJiYgIWRhdGUpIHx8IChkYXRlIGluc3RhbmNlb2YgQXJyYXkgJiYgZGF0ZS5sZW5ndGggPT09IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsZWFyKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgICAgICBzZWxmLnNob3dUaW1lSW5wdXQgPSBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZi5zZWxlY3RlZERhdGVzW3NlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICBqdW1wVG9EYXRlKCk7XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlVmFsdWUodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSlcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwYXJzZURhdGVSdWxlcyhhcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgcnVsZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyc2VEYXRlKHJ1bGUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5mcm9tICYmXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBzZWxmLnBhcnNlRGF0ZShydWxlLmZyb20sIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogc2VsZi5wYXJzZURhdGUocnVsZS50bywgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTsgLy8gcmVtb3ZlIGZhbHN5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwRGF0ZXMoKSB7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubm93ID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubm93KSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBJRTExIHNldHRpbmcgcGxhY2Vob2xkZXIgYXMgdGhlIGlucHV0J3MgdmFsdWVcbiAgICAgICAgICAgIHZhciBwcmVsb2FkZWREYXRlID0gc2VsZi5jb25maWcuZGVmYXVsdERhdGUgfHxcbiAgICAgICAgICAgICAgICAoKHNlbGYuaW5wdXQubm9kZU5hbWUgPT09IFwiSU5QVVRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0Lm5vZGVOYW1lID09PSBcIlRFWFRBUkVBXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGxhY2Vob2xkZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9PT0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVsb2FkZWREYXRlKVxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShwcmVsb2FkZWREYXRlLCBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgIHNlbGYuX2luaXRpYWxEYXRlID1cbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuc2VsZWN0ZWREYXRlc1swXVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpID4gc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0VGltZSgpIDwgc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhEYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLm5vdztcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZi5zZWxlY3RlZERhdGVzWzBdO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5UaW1lID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubWluVGltZSwgXCJIOmlcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4VGltZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heFRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5tYXhUaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgPVxuICAgICAgICAgICAgICAgICEhc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKSA+IDApO1xuICAgICAgICAgICAgc2VsZi5tYXhEYXRlSGFzVGltZSA9XG4gICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0U2Vjb25kcygpID4gMCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJzaG93VGltZUlucHV0XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX3Nob3dUaW1lSW5wdXQ7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zaG93VGltZUlucHV0ID0gYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInNob3dUaW1lSW5wdXRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaXNPcGVuICYmIHBvc2l0aW9uQ2FsZW5kYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cElucHV0cygpIHtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQgPSBzZWxmLmNvbmZpZy53cmFwXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1pbnB1dF1cIilcbiAgICAgICAgICAgICAgICA6IGVsZW1lbnQ7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZWxlbWVudCBzcGVjaWZpZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhY2s6IHN0b3JlIHByZXZpb3VzIHR5cGUgdG8gcmVzdG9yZSBpdCBhZnRlciBkZXN0cm95KClcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuX3R5cGUgPSBzZWxmLmlucHV0LnR5cGU7XG4gICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5pbnB1dDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxpY2F0ZSBzZWxmLmVsZW1lbnRcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0ID0gY3JlYXRlRWxlbWVudChzZWxmLmlucHV0Lm5vZGVOYW1lLCBzZWxmLmNvbmZpZy5hbHRJbnB1dENsYXNzKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dCA9IHNlbGYuYWx0SW5wdXQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5yZXF1aXJlZCA9IHNlbGYuaW5wdXQucmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50YWJJbmRleCA9IHNlbGYuaW5wdXQudGFiSW5kZXg7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljICYmIHNlbGYuaW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmFsdElucHV0LCBzZWxmLmlucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuYWxsb3dJbnB1dClcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgc2VsZi5fcG9zaXRpb25FbGVtZW50ID0gc2VsZi5jb25maWcucG9zaXRpb25FbGVtZW50IHx8IHNlbGYuX2lucHV0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwTW9iaWxlKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0VHlwZSA9IHNlbGYuY29uZmlnLmVuYWJsZVRpbWVcbiAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgPyBcInRpbWVcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZGF0ZXRpbWUtbG9jYWxcIlxuICAgICAgICAgICAgICAgIDogXCJkYXRlXCI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0ID0gY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHNlbGYuaW5wdXQuY2xhc3NOYW1lICsgXCIgZmxhdHBpY2tyLW1vYmlsZVwiKTtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuc3RlcCA9IHNlbGYuaW5wdXQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSB8fCBcImFueVwiO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC50YWJJbmRleCA9IDE7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnR5cGUgPSBpbnB1dFR5cGU7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmRpc2FibGVkID0gc2VsZi5pbnB1dC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucmVxdWlyZWQgPSBzZWxmLmlucHV0LnJlcXVpcmVkO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUZvcm1hdFN0ciA9XG4gICAgICAgICAgICAgICAgaW5wdXRUeXBlID09PSBcImRhdGV0aW1lLWxvY2FsXCJcbiAgICAgICAgICAgICAgICAgICAgPyBcIlktbS1kXFxcXFRIOmk6U1wiXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXRUeXBlID09PSBcImRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlktbS1kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJIOmk6U1wiO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5kZWZhdWx0VmFsdWUgPSBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5taW4gPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5jb25maWcubWluRGF0ZSwgXCJZLW0tZFwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQubWF4ID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1heERhdGUsIFwiWS1tLWRcIik7XG4gICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYubW9iaWxlSW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIGJpbmQoc2VsZi5tb2JpbGVJbnB1dCwgXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUoZS50YXJnZXQudmFsdWUsIGZhbHNlLCBzZWxmLm1vYmlsZUZvcm1hdFN0cik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DbG9zZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvZ2dsZShlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4gPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgIHNlbGYub3BlbihlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYWxyZWFkeSwgYWxsIGhvb2tzIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG9va3MgPSBzZWxmLmNvbmZpZ1tldmVudF07XG4gICAgICAgICAgICBpZiAoaG9va3MgIT09IHVuZGVmaW5lZCAmJiBob29rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGhvb2tzW2ldICYmIGkgPCBob29rcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaG9va3NbaV0oc2VsZi5zZWxlY3RlZERhdGVzLCBzZWxmLmlucHV0LnZhbHVlLCBzZWxmLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gXCJvbkNoYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KFwiY2hhbmdlXCIpKTtcbiAgICAgICAgICAgICAgICAvLyBtYW55IGZyb250LWVuZCBmcmFtZXdvcmtzIGJpbmQgdG8gdGhlIGlucHV0IGV2ZW50XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KFwiaW5wdXRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICAgICAgICAgIGUuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNEYXRlU2VsZWN0ZWQoZGF0ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZURhdGVzKHNlbGYuc2VsZWN0ZWREYXRlc1tpXSwgZGF0ZSkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RhdGVJblJhbmdlKGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgfHwgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSkgPD0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUgfHwgIXNlbGYubW9udGhOYXYpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoeWVhckVsZW1lbnQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHNlbGYuY3VycmVudFllYXIsIHNlbGYuY3VycmVudE1vbnRoLCAxKTtcbiAgICAgICAgICAgICAgICBkLnNldE1vbnRoKHNlbGYuY3VycmVudE1vbnRoICsgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50c1tpXS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aFRvU3RyKGQuZ2V0TW9udGgoKSwgc2VsZi5jb25maWcuc2hvcnRoYW5kQ3VycmVudE1vbnRoLCBzZWxmLmwxMG4pICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLnZhbHVlID0gZC5nZXRNb250aCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnZhbHVlID0gZC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuX2hpZGVQcmV2TW9udGhBcnJvdyA9XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jdXJyZW50TW9udGggPD0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY3VycmVudFllYXIgPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICAgICAgc2VsZi5faGlkZU5leHRNb250aEFycm93ID1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmN1cnJlbnRNb250aCArIDEgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jdXJyZW50WWVhciA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGF0ZVN0cihmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNlbGVjdGVkRGF0ZXNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkT2JqKSB7IHJldHVybiBzZWxmLmZvcm1hdERhdGUoZE9iaiwgZm9ybWF0KTsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgYXJyLmluZGV4T2YoZCkgPT09IGk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIlxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuY29uanVuY3Rpb25cbiAgICAgICAgICAgICAgICA6IHNlbGYubDEwbi5yYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiBpbnB1dHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxlbmRhclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmFsdWUodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQ2hhbmdlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZCAmJiBzZWxmLm1vYmlsZUZvcm1hdFN0cikge1xuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID0gZ2V0RGF0ZVN0cihzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnZhbHVlID0gZ2V0RGF0ZVN0cihzZWxmLmNvbmZpZy5hbHRGb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uVmFsdWVVcGRhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Nb250aE5hdkNsaWNrKGUpIHtcbiAgICAgICAgICAgIHZhciBpc1ByZXZNb250aCA9IHNlbGYucHJldk1vbnRoTmF2LmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBpc05leHRNb250aCA9IHNlbGYubmV4dE1vbnRoTmF2LmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXZNb250aCB8fCBpc05leHRNb250aCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGlzUHJldk1vbnRoID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYueWVhckVsZW1lbnRzLmluZGV4T2YoZS50YXJnZXQpID49IDApIHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dEb3duXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0aW1lV3JhcHBlcihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgaXNLZXlEb3duID0gZS50eXBlID09PSBcImtleWRvd25cIiwgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCAmJiBlLnRhcmdldCA9PT0gc2VsZi5hbVBNKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sMTBuLmFtUE1baW50KHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gc2VsZi5sMTBuLmFtUE1bMF0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcIm1pblwiKSksIG1heCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwibWF4XCIpKSwgc3RlcCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSksIGN1clZhbHVlID0gcGFyc2VJbnQoaW5wdXQudmFsdWUsIDEwKSwgZGVsdGEgPSBlLmRlbHRhIHx8XG4gICAgICAgICAgICAgICAgKGlzS2V5RG93biA/IChlLndoaWNoID09PSAzOCA/IDEgOiAtMSkgOiAwKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1clZhbHVlICsgc3RlcCAqIGRlbHRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNIb3VyRWxlbSA9IGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50LCBpc01pbnV0ZUVsZW0gPSBpbnB1dCA9PT0gc2VsZi5taW51dGVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQoIWlzSG91ckVsZW0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW50KGlzSG91ckVsZW0pICYmIGludCghc2VsZi5hbVBNKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dCh1bmRlZmluZWQsIC0xLCBzZWxmLmhvdXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPT09IHNlbGYuaG91ckVsZW1lbnQgPyBuZXdWYWx1ZSAtIG1heCAtIGludCghc2VsZi5hbVBNKSA6IG1pbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWludXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KHVuZGVmaW5lZCwgMSwgc2VsZi5ob3VyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gJiZcbiAgICAgICAgICAgICAgICAgICAgaXNIb3VyRWxlbSAmJlxuICAgICAgICAgICAgICAgICAgICAoc3RlcCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZSArIGN1clZhbHVlID09PSAyM1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLmFicyhuZXdWYWx1ZSAtIGN1clZhbHVlKSA+IHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmwxMG4uYW1QTVtpbnQoc2VsZi5hbVBNLnRleHRDb250ZW50ID09PSBzZWxmLmwxMG4uYW1QTVswXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHBhZChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5pdCgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBfZmxhdHBpY2tyKG5vZGVMaXN0LCBjb25maWcpIHtcbiAgICAgICAgLy8gc3RhdGljIGxpc3RcbiAgICAgICAgdmFyIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAgICAgICAuY2FsbChub2RlTGlzdClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudDsgfSk7XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1mcC1vbWl0XCIpICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fZmxhdHBpY2tyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLl9mbGF0cGlja3IgPSBGbGF0cGlja3JJbnN0YW5jZShub2RlLCBjb25maWcgfHwge30pO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlcy5wdXNoKG5vZGUuX2ZsYXRwaWNrcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcy5sZW5ndGggPT09IDEgPyBpbnN0YW5jZXNbMF0gOiBpbnN0YW5jZXM7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgSFRNTENvbGxlY3Rpb24gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIE5vZGVMaXN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGJyb3dzZXIgZW52XG4gICAgICAgIEhUTUxDb2xsZWN0aW9uLnByb3RvdHlwZS5mbGF0cGlja3IgPSBOb2RlTGlzdC5wcm90b3R5cGUuZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IodGhpcywgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKFt0aGlzXSwgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB2YXIgZmxhdHBpY2tyID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3Iod2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IoW3NlbGVjdG9yXSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHNlbGVjdG9yLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnID0ge307XG4gICAgZmxhdHBpY2tyLmwxMG5zID0ge1xuICAgICAgICBlbjogX19hc3NpZ24oe30sIGVuZ2xpc2gpLFxuICAgICAgICBcImRlZmF1bHRcIjogX19hc3NpZ24oe30sIGVuZ2xpc2gpXG4gICAgfTtcbiAgICBmbGF0cGlja3IubG9jYWxpemUgPSBmdW5jdGlvbiAobDEwbikge1xuICAgICAgICBmbGF0cGlja3IubDEwbnNbXCJkZWZhdWx0XCJdID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0sIGwxMG4pO1xuICAgIH07XG4gICAgZmxhdHBpY2tyLnNldERlZmF1bHRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyA9IF9fYXNzaWduKHt9LCBmbGF0cGlja3IuZGVmYXVsdENvbmZpZywgY29uZmlnKTtcbiAgICB9O1xuICAgIGZsYXRwaWNrci5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHt9KTtcbiAgICBmbGF0cGlja3IuZm9ybWF0RGF0ZSA9IGNyZWF0ZURhdGVGb3JtYXR0ZXIoe30pO1xuICAgIGZsYXRwaWNrci5jb21wYXJlRGF0ZXMgPSBjb21wYXJlRGF0ZXM7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgalF1ZXJ5LmZuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGpRdWVyeS5mbi5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZVxuICAgIERhdGUucHJvdG90eXBlLmZwX2luY3IgPSBmdW5jdGlvbiAoZGF5cykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLCB0aGlzLmdldE1vbnRoKCksIHRoaXMuZ2V0RGF0ZSgpICsgKHR5cGVvZiBkYXlzID09PSBcInN0cmluZ1wiID8gcGFyc2VJbnQoZGF5cywgMTApIDogZGF5cykpO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgd2luZG93LmZsYXRwaWNrciA9IGZsYXRwaWNrcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdHBpY2tyO1xuXG59KSk7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==